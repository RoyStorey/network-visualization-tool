{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nimport { arrayEach } from \"../../helpers/array.mjs\";\nimport { warn } from \"../../helpers/console.mjs\";\n/**\n * Class used to make all endpoint-related operations.\n *\n * @private\n * @class Endpoints\n */\nvar Endpoints = /*#__PURE__*/function () {\n  function Endpoints(plugin, settings) {\n    _classCallCheck(this, Endpoints);\n    /**\n     * The main plugin instance.\n     */\n    this.plugin = plugin;\n    /**\n     * Handsontable instance.\n     *\n     * @type {object}\n     */\n    this.hot = this.plugin.hot;\n    /**\n     * Array of declared plugin endpoints (calculation destination points).\n     *\n     * @type {Array}\n     * @default {Array} Empty array.\n     */\n    this.endpoints = [];\n    /**\n     * The plugin settings, taken from Handsontable configuration.\n     *\n     * @type {object|Function}\n     * @default null\n     */\n    this.settings = settings;\n    /**\n     * Settings type. Can be either 'array' or 'function.\n     *\n     * @type {string}\n     * @default {'array'}\n     */\n    this.settingsType = 'array';\n    /**\n     * The current endpoint (calculation destination point) in question.\n     *\n     * @type {object}\n     * @default null\n     */\n    this.currentEndpoint = null;\n    /**\n     * Array containing a list of changes to be applied.\n     *\n     * @private\n     * @type {Array}\n     * @default {[]}\n     */\n    this.cellsToSetCache = [];\n  }\n\n  /**\n   * Get a single endpoint object.\n   *\n   * @param {number} index Index of the endpoint.\n   * @returns {object}\n   */\n  _createClass(Endpoints, [{\n    key: \"getEndpoint\",\n    value: function getEndpoint(index) {\n      if (this.settingsType === 'function') {\n        return this.fillMissingEndpointData(this.settings)[index];\n      }\n      return this.endpoints[index];\n    }\n\n    /**\n     * Get an array with all the endpoints.\n     *\n     * @returns {Array}\n     */\n  }, {\n    key: \"getAllEndpoints\",\n    value: function getAllEndpoints() {\n      if (this.settingsType === 'function') {\n        return this.fillMissingEndpointData(this.settings);\n      }\n      return this.endpoints;\n    }\n\n    /**\n     * Used to fill the blanks in the endpoint data provided by a settings function.\n     *\n     * @private\n     * @param {Function} func Function provided in the HOT settings.\n     * @returns {Array} An array of endpoints.\n     */\n  }, {\n    key: \"fillMissingEndpointData\",\n    value: function fillMissingEndpointData(func) {\n      return this.parseSettings(func.call(this));\n    }\n\n    /**\n     * Parse plugin's settings.\n     *\n     * @param {Array} settings The settings array.\n     * @returns {object[]}\n     */\n  }, {\n    key: \"parseSettings\",\n    value: function parseSettings(settings) {\n      var _this = this;\n      var endpointsArray = [];\n      var settingsArray = settings;\n      if (!settingsArray && typeof this.settings === 'function') {\n        this.settingsType = 'function';\n        return;\n      }\n      if (!settingsArray) {\n        settingsArray = this.settings;\n      }\n      arrayEach(settingsArray, function (val) {\n        var newEndpoint = {};\n        _this.assignSetting(val, newEndpoint, 'ranges', [[0, _this.hot.countRows() - 1]]);\n        _this.assignSetting(val, newEndpoint, 'reversedRowCoords', false);\n        _this.assignSetting(val, newEndpoint, 'destinationRow', new Error(\"\\n        You must provide a destination row for the Column Summary plugin in order to work properly!\\n      \"));\n        _this.assignSetting(val, newEndpoint, 'destinationColumn', new Error(\"\\n        You must provide a destination column for the Column Summary plugin in order to work properly!\\n      \"));\n        _this.assignSetting(val, newEndpoint, 'sourceColumn', val.destinationColumn);\n        _this.assignSetting(val, newEndpoint, 'type', 'sum');\n        _this.assignSetting(val, newEndpoint, 'forceNumeric', false);\n        _this.assignSetting(val, newEndpoint, 'suppressDataTypeErrors', true);\n        _this.assignSetting(val, newEndpoint, 'suppressDataTypeErrors', true);\n        _this.assignSetting(val, newEndpoint, 'customFunction', null);\n        _this.assignSetting(val, newEndpoint, 'readOnly', true);\n        _this.assignSetting(val, newEndpoint, 'roundFloat', false);\n        endpointsArray.push(newEndpoint);\n      });\n      return endpointsArray;\n    }\n\n    /**\n     * Setter for the internal setting objects.\n     *\n     * @param {object} settings Object with the settings.\n     * @param {object} endpoint Contains information about the endpoint for the the calculation.\n     * @param {string} name Settings name.\n     * @param {object} defaultValue Default value for the settings.\n     */\n  }, {\n    key: \"assignSetting\",\n    value: function assignSetting(settings, endpoint, name, defaultValue) {\n      if (name === 'ranges' && settings[name] === void 0) {\n        endpoint[name] = defaultValue;\n        return;\n      } else if (name === 'ranges' && settings[name].length === 0) {\n        return;\n      }\n      if (settings[name] === void 0) {\n        if (defaultValue instanceof Error) {\n          throw defaultValue;\n        }\n        endpoint[name] = defaultValue;\n      } else {\n        /* eslint-disable no-lonely-if */\n        if (name === 'destinationRow' && endpoint.reversedRowCoords) {\n          endpoint[name] = this.hot.countRows() - settings[name] - 1;\n        } else {\n          endpoint[name] = settings[name];\n        }\n      }\n    }\n\n    /**\n     * Resets the endpoint setup before the structure alteration (like inserting or removing rows/columns). Used for settings provided as a function.\n     *\n     * @private\n     * @param {string} action Type of the action performed.\n     * @param {number} index Row/column index.\n     * @param {number} number Number of rows/columns added/removed.\n     */\n  }, {\n    key: \"resetSetupBeforeStructureAlteration\",\n    value: function resetSetupBeforeStructureAlteration(action, index, number) {\n      if (this.settingsType !== 'function') {\n        return;\n      }\n      var type = action.indexOf('row') > -1 ? 'row' : 'col';\n      var endpoints = this.getAllEndpoints();\n      arrayEach(endpoints, function (val) {\n        if (type === 'row' && val.destinationRow >= index) {\n          if (action === 'insert_row') {\n            val.alterRowOffset = number;\n          } else if (action === 'remove_row') {\n            val.alterRowOffset = -1 * number;\n          }\n        }\n        if (type === 'col' && val.destinationColumn >= index) {\n          if (action === 'insert_col') {\n            val.alterColumnOffset = number;\n          } else if (action === 'remove_col') {\n            val.alterColumnOffset = -1 * number;\n          }\n        }\n      });\n      this.resetAllEndpoints(endpoints, false);\n    }\n\n    /**\n     * AfterCreateRow/afterCreateRow/afterRemoveRow/afterRemoveCol hook callback. Reset and reenables the summary functionality\n     * after changing the table structure.\n     *\n     * @private\n     * @param {string} action Type of the action performed.\n     * @param {number} index Row/column index.\n     * @param {number} number Number of rows/columns added/removed.\n     * @param {Array} [logicRows] Array of the logical indexes.\n     * @param {string} [source] Source of change.\n     * @param {boolean} [forceRefresh] `true` of the endpoints should refresh after completing the function.\n     */\n  }, {\n    key: \"resetSetupAfterStructureAlteration\",\n    value: function resetSetupAfterStructureAlteration(action, index, number, logicRows, source) {\n      var _this2 = this;\n      var forceRefresh = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n      if (this.settingsType === 'function') {\n        // We need to run it on a next avaiable hook, because the TrimRows' `afterCreateRow` hook triggers after this one,\n        // and it needs to be run to properly calculate the endpoint value.\n        var beforeViewRenderCallback = function beforeViewRenderCallback() {\n          _this2.hot.removeHook('beforeViewRender', beforeViewRenderCallback);\n          return _this2.refreshAllEndpoints();\n        };\n        this.hot.addHookOnce('beforeViewRender', beforeViewRenderCallback);\n        return;\n      }\n      var type = action.indexOf('row') > -1 ? 'row' : 'col';\n      var multiplier = action.indexOf('remove') > -1 ? -1 : 1;\n      var endpoints = this.getAllEndpoints();\n      var rowMoving = action.indexOf('move_row') === 0;\n      var placeOfAlteration = index;\n      arrayEach(endpoints, function (val) {\n        if (type === 'row' && val.destinationRow >= placeOfAlteration) {\n          val.alterRowOffset = multiplier * number;\n        }\n        if (type === 'col' && val.destinationColumn >= placeOfAlteration) {\n          val.alterColumnOffset = multiplier * number;\n        }\n      });\n      this.resetAllEndpoints(endpoints, !rowMoving);\n      if (rowMoving) {\n        arrayEach(endpoints, function (endpoint) {\n          _this2.extendEndpointRanges(endpoint, placeOfAlteration, logicRows[0], logicRows.length);\n          _this2.recreatePhysicalRanges(endpoint);\n          _this2.clearOffsetInformation(endpoint);\n        });\n      } else {\n        arrayEach(endpoints, function (endpoint) {\n          _this2.shiftEndpointCoordinates(endpoint, placeOfAlteration);\n        });\n      }\n      if (forceRefresh) {\n        this.refreshAllEndpoints();\n      }\n    }\n\n    /**\n     * Clear the offset information from the endpoint object.\n     *\n     * @private\n     * @param {object} endpoint And endpoint object.\n     */\n  }, {\n    key: \"clearOffsetInformation\",\n    value: function clearOffsetInformation(endpoint) {\n      endpoint.alterRowOffset = void 0;\n      endpoint.alterColumnOffset = void 0;\n    }\n\n    /**\n     * Extend the row ranges for the provided endpoint.\n     *\n     * @private\n     * @param {object} endpoint The endpoint object.\n     * @param {number} placeOfAlteration Index of the row where the alteration takes place.\n     * @param {number} previousPosition Previous endpoint result position.\n     * @param {number} offset Offset generated by the alteration.\n     */\n  }, {\n    key: \"extendEndpointRanges\",\n    value: function extendEndpointRanges(endpoint, placeOfAlteration, previousPosition, offset) {\n      arrayEach(endpoint.ranges, function (range) {\n        // is a range, not a single row\n        if (range[1]) {\n          if (placeOfAlteration >= range[0] && placeOfAlteration <= range[1]) {\n            if (previousPosition > range[1]) {\n              range[1] += offset;\n            } else if (previousPosition < range[0]) {\n              range[0] -= offset;\n            }\n          } else if (previousPosition >= range[0] && previousPosition <= range[1]) {\n            range[1] -= offset;\n            if (placeOfAlteration <= range[0]) {\n              range[0] += 1;\n              range[1] += 1;\n            }\n          }\n        }\n      });\n    }\n\n    /**\n     * Recreate the physical ranges for the provided endpoint. Used (for example) when a row gets moved and extends an existing range.\n     *\n     * @private\n     * @param {object} endpoint An endpoint object.\n     */\n  }, {\n    key: \"recreatePhysicalRanges\",\n    value: function recreatePhysicalRanges(endpoint) {\n      var _this3 = this;\n      var ranges = endpoint.ranges;\n      var newRanges = [];\n      var allIndexes = [];\n      arrayEach(ranges, function (range) {\n        var newRange = [];\n        if (range[1]) {\n          for (var i = range[0]; i <= range[1]; i++) {\n            newRange.push(_this3.hot.toPhysicalRow(i));\n          }\n        } else {\n          newRange.push(_this3.hot.toPhysicalRow(range[0]));\n        }\n        allIndexes.push(newRange);\n      });\n      arrayEach(allIndexes, function (range) {\n        var newRange = [];\n        arrayEach(range, function (coord, index) {\n          if (index === 0) {\n            newRange.push(coord);\n          } else if (range[index] !== range[index - 1] + 1) {\n            newRange.push(range[index - 1]);\n            newRanges.push(newRange);\n            newRange = [];\n            newRange.push(coord);\n          }\n          if (index === range.length - 1) {\n            newRange.push(coord);\n            newRanges.push(newRange);\n          }\n        });\n      });\n      endpoint.ranges = newRanges;\n    }\n\n    /**\n     * Shifts the endpoint coordinates by the defined offset.\n     *\n     * @private\n     * @param {object} endpoint Endpoint object.\n     * @param {number} offsetStartIndex Index of the performed change (if the change is located after the endpoint, nothing about the endpoint has to be changed.\n     */\n  }, {\n    key: \"shiftEndpointCoordinates\",\n    value: function shiftEndpointCoordinates(endpoint, offsetStartIndex) {\n      if (endpoint.alterRowOffset && endpoint.alterRowOffset !== 0) {\n        endpoint.destinationRow += endpoint.alterRowOffset || 0;\n        arrayEach(endpoint.ranges, function (element) {\n          arrayEach(element, function (subElement, j) {\n            if (subElement >= offsetStartIndex) {\n              element[j] += endpoint.alterRowOffset || 0;\n            }\n          });\n        });\n      } else if (endpoint.alterColumnOffset && endpoint.alterColumnOffset !== 0) {\n        endpoint.destinationColumn += endpoint.alterColumnOffset || 0;\n        endpoint.sourceColumn += endpoint.alterColumnOffset || 0;\n      }\n    }\n\n    /**\n     * Resets (removes) the endpoints from the table.\n     *\n     * @param {Array} [endpoints] Array containing the endpoints.\n     * @param {boolean} [useOffset=true] Use the cell offset value.\n     */\n  }, {\n    key: \"resetAllEndpoints\",\n    value: function resetAllEndpoints() {\n      var _this4 = this;\n      var endpoints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAllEndpoints();\n      var useOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var anyEndpointOutOfRange = endpoints.some(function (endpoint) {\n        var alterRowOffset = endpoint.alterRowOffset || 0;\n        var alterColOffset = endpoint.alterColumnOffset || 0;\n        if (endpoint.destinationRow + alterRowOffset >= _this4.hot.countRows() || endpoint.destinationColumn + alterColOffset >= _this4.hot.countCols()) {\n          return true;\n        }\n        return false;\n      });\n      if (anyEndpointOutOfRange) {\n        return;\n      }\n      this.cellsToSetCache = [];\n      arrayEach(endpoints, function (endpoint) {\n        _this4.resetEndpointValue(endpoint, useOffset);\n      });\n      this.hot.setDataAtCell(this.cellsToSetCache, 'ColumnSummary.reset');\n      this.cellsToSetCache = [];\n    }\n\n    /**\n     * Calculate and refresh all defined endpoints.\n     */\n  }, {\n    key: \"refreshAllEndpoints\",\n    value: function refreshAllEndpoints() {\n      var _this5 = this;\n      this.cellsToSetCache = [];\n      arrayEach(this.getAllEndpoints(), function (value) {\n        _this5.currentEndpoint = value;\n        _this5.plugin.calculate(value);\n        _this5.setEndpointValue(value, 'init');\n      });\n      this.currentEndpoint = null;\n      this.hot.setDataAtCell(this.cellsToSetCache, 'ColumnSummary.reset');\n      this.cellsToSetCache = [];\n    }\n\n    /**\n     * Calculate and refresh endpoints only in the changed columns.\n     *\n     * @param {Array} changes Array of changes from the `afterChange` hook.\n     */\n  }, {\n    key: \"refreshChangedEndpoints\",\n    value: function refreshChangedEndpoints(changes) {\n      var _this6 = this;\n      var needToRefresh = [];\n      this.cellsToSetCache = [];\n      arrayEach(changes, function (value, key, changesObj) {\n        // if nothing changed, dont update anything\n        if (\"\".concat(value[2] || '') === \"\".concat(value[3])) {\n          return;\n        }\n        arrayEach(_this6.getAllEndpoints(), function (endpoint, j) {\n          if (_this6.hot.propToCol(changesObj[key][1]) === endpoint.sourceColumn && needToRefresh.indexOf(j) === -1) {\n            needToRefresh.push(j);\n          }\n        });\n      });\n      arrayEach(needToRefresh, function (value) {\n        _this6.refreshEndpoint(_this6.getEndpoint(value));\n      });\n      this.hot.setDataAtCell(this.cellsToSetCache, 'ColumnSummary.reset');\n      this.cellsToSetCache = [];\n    }\n\n    /**\n     * Calculate and refresh a single endpoint.\n     *\n     * @param {object} endpoint Contains the endpoint information.\n     */\n  }, {\n    key: \"refreshEndpoint\",\n    value: function refreshEndpoint(endpoint) {\n      this.currentEndpoint = endpoint;\n      this.plugin.calculate(endpoint);\n      this.setEndpointValue(endpoint);\n      this.currentEndpoint = null;\n    }\n\n    /**\n     * Reset the endpoint value.\n     *\n     * @param {object} endpoint Contains the endpoint information.\n     * @param {boolean} [useOffset=true] Use the cell offset value.\n     */\n  }, {\n    key: \"resetEndpointValue\",\n    value: function resetEndpointValue(endpoint) {\n      var useOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var alterRowOffset = endpoint.alterRowOffset || 0;\n      var alterColOffset = endpoint.alterColumnOffset || 0;\n      this.cellsToSetCache.push([this.hot.toVisualRow(endpoint.destinationRow + (useOffset ? alterRowOffset : 0)), this.hot.toVisualColumn(endpoint.destinationColumn + (useOffset ? alterColOffset : 0)), '']);\n    }\n\n    /**\n     * Set the endpoint value.\n     *\n     * @param {object} endpoint Contains the endpoint information.\n     * @param {string} [source] Source of the call information.\n     * @param {boolean} [render=false] `true` if it needs to render the table afterwards.\n     */\n  }, {\n    key: \"setEndpointValue\",\n    value: function setEndpointValue(endpoint, source) {\n      var render = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var visualEndpointRowIndex = this.hot.toVisualRow(endpoint.destinationRow);\n      if (endpoint.destinationRow >= this.hot.countRows() || endpoint.destinationColumn >= this.hot.countCols()) {\n        this.throwOutOfBoundsWarning();\n        return;\n      }\n      var destinationVisualRow = this.hot.toVisualRow(endpoint.destinationRow);\n      if (destinationVisualRow !== null) {\n        var cellMeta = this.hot.getCellMeta(destinationVisualRow, endpoint.destinationColumn);\n        if (source === 'init' || cellMeta.readOnly !== endpoint.readOnly) {\n          cellMeta.readOnly = endpoint.readOnly;\n          cellMeta.className = 'columnSummaryResult';\n        }\n      }\n      if (endpoint.roundFloat && !isNaN(endpoint.result)) {\n        endpoint.result = endpoint.result.toFixed(endpoint.roundFloat);\n      }\n      if (render) {\n        this.hot.setDataAtCell(visualEndpointRowIndex, endpoint.destinationColumn, endpoint.result, 'ColumnSummary.set');\n      } else {\n        this.cellsToSetCache.push([visualEndpointRowIndex, endpoint.destinationColumn, endpoint.result]);\n      }\n      endpoint.alterRowOffset = void 0;\n      endpoint.alterColumnOffset = void 0;\n    }\n\n    /**\n     * Throw an error for the calculation range being out of boundaries.\n     *\n     * @private\n     */\n  }, {\n    key: \"throwOutOfBoundsWarning\",\n    value: function throwOutOfBoundsWarning() {\n      warn('One of the Column Summary plugins\\' destination points you provided is beyond the table boundaries!');\n    }\n  }]);\n  return Endpoints;\n}();\nexport default Endpoints;","map":{"version":3,"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","_toPropertyKey","key","_createClass","protoProps","staticProps","arg","_toPrimitive","String","input","hint","prim","toPrimitive","undefined","res","call","Number","arrayEach","warn","Endpoints","plugin","settings","hot","endpoints","settingsType","currentEndpoint","cellsToSetCache","value","getEndpoint","index","fillMissingEndpointData","getAllEndpoints","func","parseSettings","_this","endpointsArray","settingsArray","val","newEndpoint","assignSetting","countRows","Error","destinationColumn","push","endpoint","name","defaultValue","reversedRowCoords","resetSetupBeforeStructureAlteration","action","number","type","indexOf","destinationRow","alterRowOffset","alterColumnOffset","resetAllEndpoints","resetSetupAfterStructureAlteration","logicRows","source","_this2","forceRefresh","arguments","beforeViewRenderCallback","removeHook","refreshAllEndpoints","addHookOnce","multiplier","rowMoving","placeOfAlteration","extendEndpointRanges","recreatePhysicalRanges","clearOffsetInformation","shiftEndpointCoordinates","previousPosition","offset","ranges","range","_this3","newRanges","allIndexes","newRange","toPhysicalRow","coord","offsetStartIndex","element","subElement","j","sourceColumn","_this4","useOffset","anyEndpointOutOfRange","some","alterColOffset","countCols","resetEndpointValue","setDataAtCell","_this5","calculate","setEndpointValue","refreshChangedEndpoints","changes","_this6","needToRefresh","changesObj","concat","propToCol","refreshEndpoint","toVisualRow","toVisualColumn","render","visualEndpointRowIndex","throwOutOfBoundsWarning","destinationVisualRow","cellMeta","getCellMeta","readOnly","className","roundFloat","isNaN","result","toFixed"],"sources":["/home/rstorey/wwwdev/Blucktool/node_modules/handsontable/plugins/columnSummary/endpoints.mjs"],"sourcesContent":["function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.number.to-fixed.js\";\nimport \"core-js/modules/es.symbol.to-primitive.js\";\nimport \"core-js/modules/es.date.to-primitive.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { arrayEach } from \"../../helpers/array.mjs\";\nimport { warn } from \"../../helpers/console.mjs\";\n/**\n * Class used to make all endpoint-related operations.\n *\n * @private\n * @class Endpoints\n */\nvar Endpoints = /*#__PURE__*/function () {\n  function Endpoints(plugin, settings) {\n    _classCallCheck(this, Endpoints);\n    /**\n     * The main plugin instance.\n     */\n    this.plugin = plugin;\n    /**\n     * Handsontable instance.\n     *\n     * @type {object}\n     */\n    this.hot = this.plugin.hot;\n    /**\n     * Array of declared plugin endpoints (calculation destination points).\n     *\n     * @type {Array}\n     * @default {Array} Empty array.\n     */\n    this.endpoints = [];\n    /**\n     * The plugin settings, taken from Handsontable configuration.\n     *\n     * @type {object|Function}\n     * @default null\n     */\n    this.settings = settings;\n    /**\n     * Settings type. Can be either 'array' or 'function.\n     *\n     * @type {string}\n     * @default {'array'}\n     */\n    this.settingsType = 'array';\n    /**\n     * The current endpoint (calculation destination point) in question.\n     *\n     * @type {object}\n     * @default null\n     */\n    this.currentEndpoint = null;\n    /**\n     * Array containing a list of changes to be applied.\n     *\n     * @private\n     * @type {Array}\n     * @default {[]}\n     */\n    this.cellsToSetCache = [];\n  }\n\n  /**\n   * Get a single endpoint object.\n   *\n   * @param {number} index Index of the endpoint.\n   * @returns {object}\n   */\n  _createClass(Endpoints, [{\n    key: \"getEndpoint\",\n    value: function getEndpoint(index) {\n      if (this.settingsType === 'function') {\n        return this.fillMissingEndpointData(this.settings)[index];\n      }\n      return this.endpoints[index];\n    }\n\n    /**\n     * Get an array with all the endpoints.\n     *\n     * @returns {Array}\n     */\n  }, {\n    key: \"getAllEndpoints\",\n    value: function getAllEndpoints() {\n      if (this.settingsType === 'function') {\n        return this.fillMissingEndpointData(this.settings);\n      }\n      return this.endpoints;\n    }\n\n    /**\n     * Used to fill the blanks in the endpoint data provided by a settings function.\n     *\n     * @private\n     * @param {Function} func Function provided in the HOT settings.\n     * @returns {Array} An array of endpoints.\n     */\n  }, {\n    key: \"fillMissingEndpointData\",\n    value: function fillMissingEndpointData(func) {\n      return this.parseSettings(func.call(this));\n    }\n\n    /**\n     * Parse plugin's settings.\n     *\n     * @param {Array} settings The settings array.\n     * @returns {object[]}\n     */\n  }, {\n    key: \"parseSettings\",\n    value: function parseSettings(settings) {\n      var _this = this;\n      var endpointsArray = [];\n      var settingsArray = settings;\n      if (!settingsArray && typeof this.settings === 'function') {\n        this.settingsType = 'function';\n        return;\n      }\n      if (!settingsArray) {\n        settingsArray = this.settings;\n      }\n      arrayEach(settingsArray, function (val) {\n        var newEndpoint = {};\n        _this.assignSetting(val, newEndpoint, 'ranges', [[0, _this.hot.countRows() - 1]]);\n        _this.assignSetting(val, newEndpoint, 'reversedRowCoords', false);\n        _this.assignSetting(val, newEndpoint, 'destinationRow', new Error(\"\\n        You must provide a destination row for the Column Summary plugin in order to work properly!\\n      \"));\n        _this.assignSetting(val, newEndpoint, 'destinationColumn', new Error(\"\\n        You must provide a destination column for the Column Summary plugin in order to work properly!\\n      \"));\n        _this.assignSetting(val, newEndpoint, 'sourceColumn', val.destinationColumn);\n        _this.assignSetting(val, newEndpoint, 'type', 'sum');\n        _this.assignSetting(val, newEndpoint, 'forceNumeric', false);\n        _this.assignSetting(val, newEndpoint, 'suppressDataTypeErrors', true);\n        _this.assignSetting(val, newEndpoint, 'suppressDataTypeErrors', true);\n        _this.assignSetting(val, newEndpoint, 'customFunction', null);\n        _this.assignSetting(val, newEndpoint, 'readOnly', true);\n        _this.assignSetting(val, newEndpoint, 'roundFloat', false);\n        endpointsArray.push(newEndpoint);\n      });\n      return endpointsArray;\n    }\n\n    /**\n     * Setter for the internal setting objects.\n     *\n     * @param {object} settings Object with the settings.\n     * @param {object} endpoint Contains information about the endpoint for the the calculation.\n     * @param {string} name Settings name.\n     * @param {object} defaultValue Default value for the settings.\n     */\n  }, {\n    key: \"assignSetting\",\n    value: function assignSetting(settings, endpoint, name, defaultValue) {\n      if (name === 'ranges' && settings[name] === void 0) {\n        endpoint[name] = defaultValue;\n        return;\n      } else if (name === 'ranges' && settings[name].length === 0) {\n        return;\n      }\n      if (settings[name] === void 0) {\n        if (defaultValue instanceof Error) {\n          throw defaultValue;\n        }\n        endpoint[name] = defaultValue;\n      } else {\n        /* eslint-disable no-lonely-if */\n        if (name === 'destinationRow' && endpoint.reversedRowCoords) {\n          endpoint[name] = this.hot.countRows() - settings[name] - 1;\n        } else {\n          endpoint[name] = settings[name];\n        }\n      }\n    }\n\n    /**\n     * Resets the endpoint setup before the structure alteration (like inserting or removing rows/columns). Used for settings provided as a function.\n     *\n     * @private\n     * @param {string} action Type of the action performed.\n     * @param {number} index Row/column index.\n     * @param {number} number Number of rows/columns added/removed.\n     */\n  }, {\n    key: \"resetSetupBeforeStructureAlteration\",\n    value: function resetSetupBeforeStructureAlteration(action, index, number) {\n      if (this.settingsType !== 'function') {\n        return;\n      }\n      var type = action.indexOf('row') > -1 ? 'row' : 'col';\n      var endpoints = this.getAllEndpoints();\n      arrayEach(endpoints, function (val) {\n        if (type === 'row' && val.destinationRow >= index) {\n          if (action === 'insert_row') {\n            val.alterRowOffset = number;\n          } else if (action === 'remove_row') {\n            val.alterRowOffset = -1 * number;\n          }\n        }\n        if (type === 'col' && val.destinationColumn >= index) {\n          if (action === 'insert_col') {\n            val.alterColumnOffset = number;\n          } else if (action === 'remove_col') {\n            val.alterColumnOffset = -1 * number;\n          }\n        }\n      });\n      this.resetAllEndpoints(endpoints, false);\n    }\n\n    /**\n     * AfterCreateRow/afterCreateRow/afterRemoveRow/afterRemoveCol hook callback. Reset and reenables the summary functionality\n     * after changing the table structure.\n     *\n     * @private\n     * @param {string} action Type of the action performed.\n     * @param {number} index Row/column index.\n     * @param {number} number Number of rows/columns added/removed.\n     * @param {Array} [logicRows] Array of the logical indexes.\n     * @param {string} [source] Source of change.\n     * @param {boolean} [forceRefresh] `true` of the endpoints should refresh after completing the function.\n     */\n  }, {\n    key: \"resetSetupAfterStructureAlteration\",\n    value: function resetSetupAfterStructureAlteration(action, index, number, logicRows, source) {\n      var _this2 = this;\n      var forceRefresh = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n      if (this.settingsType === 'function') {\n        // We need to run it on a next avaiable hook, because the TrimRows' `afterCreateRow` hook triggers after this one,\n        // and it needs to be run to properly calculate the endpoint value.\n        var beforeViewRenderCallback = function beforeViewRenderCallback() {\n          _this2.hot.removeHook('beforeViewRender', beforeViewRenderCallback);\n          return _this2.refreshAllEndpoints();\n        };\n        this.hot.addHookOnce('beforeViewRender', beforeViewRenderCallback);\n        return;\n      }\n      var type = action.indexOf('row') > -1 ? 'row' : 'col';\n      var multiplier = action.indexOf('remove') > -1 ? -1 : 1;\n      var endpoints = this.getAllEndpoints();\n      var rowMoving = action.indexOf('move_row') === 0;\n      var placeOfAlteration = index;\n      arrayEach(endpoints, function (val) {\n        if (type === 'row' && val.destinationRow >= placeOfAlteration) {\n          val.alterRowOffset = multiplier * number;\n        }\n        if (type === 'col' && val.destinationColumn >= placeOfAlteration) {\n          val.alterColumnOffset = multiplier * number;\n        }\n      });\n      this.resetAllEndpoints(endpoints, !rowMoving);\n      if (rowMoving) {\n        arrayEach(endpoints, function (endpoint) {\n          _this2.extendEndpointRanges(endpoint, placeOfAlteration, logicRows[0], logicRows.length);\n          _this2.recreatePhysicalRanges(endpoint);\n          _this2.clearOffsetInformation(endpoint);\n        });\n      } else {\n        arrayEach(endpoints, function (endpoint) {\n          _this2.shiftEndpointCoordinates(endpoint, placeOfAlteration);\n        });\n      }\n      if (forceRefresh) {\n        this.refreshAllEndpoints();\n      }\n    }\n\n    /**\n     * Clear the offset information from the endpoint object.\n     *\n     * @private\n     * @param {object} endpoint And endpoint object.\n     */\n  }, {\n    key: \"clearOffsetInformation\",\n    value: function clearOffsetInformation(endpoint) {\n      endpoint.alterRowOffset = void 0;\n      endpoint.alterColumnOffset = void 0;\n    }\n\n    /**\n     * Extend the row ranges for the provided endpoint.\n     *\n     * @private\n     * @param {object} endpoint The endpoint object.\n     * @param {number} placeOfAlteration Index of the row where the alteration takes place.\n     * @param {number} previousPosition Previous endpoint result position.\n     * @param {number} offset Offset generated by the alteration.\n     */\n  }, {\n    key: \"extendEndpointRanges\",\n    value: function extendEndpointRanges(endpoint, placeOfAlteration, previousPosition, offset) {\n      arrayEach(endpoint.ranges, function (range) {\n        // is a range, not a single row\n        if (range[1]) {\n          if (placeOfAlteration >= range[0] && placeOfAlteration <= range[1]) {\n            if (previousPosition > range[1]) {\n              range[1] += offset;\n            } else if (previousPosition < range[0]) {\n              range[0] -= offset;\n            }\n          } else if (previousPosition >= range[0] && previousPosition <= range[1]) {\n            range[1] -= offset;\n            if (placeOfAlteration <= range[0]) {\n              range[0] += 1;\n              range[1] += 1;\n            }\n          }\n        }\n      });\n    }\n\n    /**\n     * Recreate the physical ranges for the provided endpoint. Used (for example) when a row gets moved and extends an existing range.\n     *\n     * @private\n     * @param {object} endpoint An endpoint object.\n     */\n  }, {\n    key: \"recreatePhysicalRanges\",\n    value: function recreatePhysicalRanges(endpoint) {\n      var _this3 = this;\n      var ranges = endpoint.ranges;\n      var newRanges = [];\n      var allIndexes = [];\n      arrayEach(ranges, function (range) {\n        var newRange = [];\n        if (range[1]) {\n          for (var i = range[0]; i <= range[1]; i++) {\n            newRange.push(_this3.hot.toPhysicalRow(i));\n          }\n        } else {\n          newRange.push(_this3.hot.toPhysicalRow(range[0]));\n        }\n        allIndexes.push(newRange);\n      });\n      arrayEach(allIndexes, function (range) {\n        var newRange = [];\n        arrayEach(range, function (coord, index) {\n          if (index === 0) {\n            newRange.push(coord);\n          } else if (range[index] !== range[index - 1] + 1) {\n            newRange.push(range[index - 1]);\n            newRanges.push(newRange);\n            newRange = [];\n            newRange.push(coord);\n          }\n          if (index === range.length - 1) {\n            newRange.push(coord);\n            newRanges.push(newRange);\n          }\n        });\n      });\n      endpoint.ranges = newRanges;\n    }\n\n    /**\n     * Shifts the endpoint coordinates by the defined offset.\n     *\n     * @private\n     * @param {object} endpoint Endpoint object.\n     * @param {number} offsetStartIndex Index of the performed change (if the change is located after the endpoint, nothing about the endpoint has to be changed.\n     */\n  }, {\n    key: \"shiftEndpointCoordinates\",\n    value: function shiftEndpointCoordinates(endpoint, offsetStartIndex) {\n      if (endpoint.alterRowOffset && endpoint.alterRowOffset !== 0) {\n        endpoint.destinationRow += endpoint.alterRowOffset || 0;\n        arrayEach(endpoint.ranges, function (element) {\n          arrayEach(element, function (subElement, j) {\n            if (subElement >= offsetStartIndex) {\n              element[j] += endpoint.alterRowOffset || 0;\n            }\n          });\n        });\n      } else if (endpoint.alterColumnOffset && endpoint.alterColumnOffset !== 0) {\n        endpoint.destinationColumn += endpoint.alterColumnOffset || 0;\n        endpoint.sourceColumn += endpoint.alterColumnOffset || 0;\n      }\n    }\n\n    /**\n     * Resets (removes) the endpoints from the table.\n     *\n     * @param {Array} [endpoints] Array containing the endpoints.\n     * @param {boolean} [useOffset=true] Use the cell offset value.\n     */\n  }, {\n    key: \"resetAllEndpoints\",\n    value: function resetAllEndpoints() {\n      var _this4 = this;\n      var endpoints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAllEndpoints();\n      var useOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var anyEndpointOutOfRange = endpoints.some(function (endpoint) {\n        var alterRowOffset = endpoint.alterRowOffset || 0;\n        var alterColOffset = endpoint.alterColumnOffset || 0;\n        if (endpoint.destinationRow + alterRowOffset >= _this4.hot.countRows() || endpoint.destinationColumn + alterColOffset >= _this4.hot.countCols()) {\n          return true;\n        }\n        return false;\n      });\n      if (anyEndpointOutOfRange) {\n        return;\n      }\n      this.cellsToSetCache = [];\n      arrayEach(endpoints, function (endpoint) {\n        _this4.resetEndpointValue(endpoint, useOffset);\n      });\n      this.hot.setDataAtCell(this.cellsToSetCache, 'ColumnSummary.reset');\n      this.cellsToSetCache = [];\n    }\n\n    /**\n     * Calculate and refresh all defined endpoints.\n     */\n  }, {\n    key: \"refreshAllEndpoints\",\n    value: function refreshAllEndpoints() {\n      var _this5 = this;\n      this.cellsToSetCache = [];\n      arrayEach(this.getAllEndpoints(), function (value) {\n        _this5.currentEndpoint = value;\n        _this5.plugin.calculate(value);\n        _this5.setEndpointValue(value, 'init');\n      });\n      this.currentEndpoint = null;\n      this.hot.setDataAtCell(this.cellsToSetCache, 'ColumnSummary.reset');\n      this.cellsToSetCache = [];\n    }\n\n    /**\n     * Calculate and refresh endpoints only in the changed columns.\n     *\n     * @param {Array} changes Array of changes from the `afterChange` hook.\n     */\n  }, {\n    key: \"refreshChangedEndpoints\",\n    value: function refreshChangedEndpoints(changes) {\n      var _this6 = this;\n      var needToRefresh = [];\n      this.cellsToSetCache = [];\n      arrayEach(changes, function (value, key, changesObj) {\n        // if nothing changed, dont update anything\n        if (\"\".concat(value[2] || '') === \"\".concat(value[3])) {\n          return;\n        }\n        arrayEach(_this6.getAllEndpoints(), function (endpoint, j) {\n          if (_this6.hot.propToCol(changesObj[key][1]) === endpoint.sourceColumn && needToRefresh.indexOf(j) === -1) {\n            needToRefresh.push(j);\n          }\n        });\n      });\n      arrayEach(needToRefresh, function (value) {\n        _this6.refreshEndpoint(_this6.getEndpoint(value));\n      });\n      this.hot.setDataAtCell(this.cellsToSetCache, 'ColumnSummary.reset');\n      this.cellsToSetCache = [];\n    }\n\n    /**\n     * Calculate and refresh a single endpoint.\n     *\n     * @param {object} endpoint Contains the endpoint information.\n     */\n  }, {\n    key: \"refreshEndpoint\",\n    value: function refreshEndpoint(endpoint) {\n      this.currentEndpoint = endpoint;\n      this.plugin.calculate(endpoint);\n      this.setEndpointValue(endpoint);\n      this.currentEndpoint = null;\n    }\n\n    /**\n     * Reset the endpoint value.\n     *\n     * @param {object} endpoint Contains the endpoint information.\n     * @param {boolean} [useOffset=true] Use the cell offset value.\n     */\n  }, {\n    key: \"resetEndpointValue\",\n    value: function resetEndpointValue(endpoint) {\n      var useOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var alterRowOffset = endpoint.alterRowOffset || 0;\n      var alterColOffset = endpoint.alterColumnOffset || 0;\n      this.cellsToSetCache.push([this.hot.toVisualRow(endpoint.destinationRow + (useOffset ? alterRowOffset : 0)), this.hot.toVisualColumn(endpoint.destinationColumn + (useOffset ? alterColOffset : 0)), '']);\n    }\n\n    /**\n     * Set the endpoint value.\n     *\n     * @param {object} endpoint Contains the endpoint information.\n     * @param {string} [source] Source of the call information.\n     * @param {boolean} [render=false] `true` if it needs to render the table afterwards.\n     */\n  }, {\n    key: \"setEndpointValue\",\n    value: function setEndpointValue(endpoint, source) {\n      var render = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var visualEndpointRowIndex = this.hot.toVisualRow(endpoint.destinationRow);\n      if (endpoint.destinationRow >= this.hot.countRows() || endpoint.destinationColumn >= this.hot.countCols()) {\n        this.throwOutOfBoundsWarning();\n        return;\n      }\n      var destinationVisualRow = this.hot.toVisualRow(endpoint.destinationRow);\n      if (destinationVisualRow !== null) {\n        var cellMeta = this.hot.getCellMeta(destinationVisualRow, endpoint.destinationColumn);\n        if (source === 'init' || cellMeta.readOnly !== endpoint.readOnly) {\n          cellMeta.readOnly = endpoint.readOnly;\n          cellMeta.className = 'columnSummaryResult';\n        }\n      }\n      if (endpoint.roundFloat && !isNaN(endpoint.result)) {\n        endpoint.result = endpoint.result.toFixed(endpoint.roundFloat);\n      }\n      if (render) {\n        this.hot.setDataAtCell(visualEndpointRowIndex, endpoint.destinationColumn, endpoint.result, 'ColumnSummary.set');\n      } else {\n        this.cellsToSetCache.push([visualEndpointRowIndex, endpoint.destinationColumn, endpoint.result]);\n      }\n      endpoint.alterRowOffset = void 0;\n      endpoint.alterColumnOffset = void 0;\n    }\n\n    /**\n     * Throw an error for the calculation range being out of boundaries.\n     *\n     * @private\n     */\n  }, {\n    key: \"throwOutOfBoundsWarning\",\n    value: function throwOutOfBoundsWarning() {\n      warn('One of the Column Summary plugins\\' destination points you provided is beyond the table boundaries!');\n    }\n  }]);\n  return Endpoints;\n}();\nexport default Endpoints;"],"mappings":"AAAA,SAASA,OAAOA,CAACC,GAAG,EAAE;EAAE,yBAAyB;;EAAE,OAAOD,OAAO,GAAG,UAAU,IAAI,OAAOE,MAAM,IAAI,QAAQ,IAAI,OAAOA,MAAM,CAACC,QAAQ,GAAG,UAAUF,GAAG,EAAE;IAAE,OAAO,OAAOA,GAAG;EAAE,CAAC,GAAG,UAAUA,GAAG,EAAE;IAAE,OAAOA,GAAG,IAAI,UAAU,IAAI,OAAOC,MAAM,IAAID,GAAG,CAACG,WAAW,KAAKF,MAAM,IAAID,GAAG,KAAKC,MAAM,CAACG,SAAS,GAAG,QAAQ,GAAG,OAAOJ,GAAG;EAAE,CAAC,EAAED,OAAO,CAACC,GAAG,CAAC;AAAE;AAa/U,SAASK,eAAeA,CAACC,QAAQ,EAAEC,WAAW,EAAE;EAAE,IAAI,EAAED,QAAQ,YAAYC,WAAW,CAAC,EAAE;IAAE,MAAM,IAAIC,SAAS,CAAC,mCAAmC,CAAC;EAAE;AAAE;AACxJ,SAASC,iBAAiBA,CAACC,MAAM,EAAEC,KAAK,EAAE;EAAE,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,KAAK,CAACE,MAAM,EAAED,CAAC,EAAE,EAAE;IAAE,IAAIE,UAAU,GAAGH,KAAK,CAACC,CAAC,CAAC;IAAEE,UAAU,CAACC,UAAU,GAAGD,UAAU,CAACC,UAAU,IAAI,KAAK;IAAED,UAAU,CAACE,YAAY,GAAG,IAAI;IAAE,IAAI,OAAO,IAAIF,UAAU,EAAEA,UAAU,CAACG,QAAQ,GAAG,IAAI;IAAEC,MAAM,CAACC,cAAc,CAACT,MAAM,EAAEU,cAAc,CAACN,UAAU,CAACO,GAAG,CAAC,EAAEP,UAAU,CAAC;EAAE;AAAE;AAC5U,SAASQ,YAAYA,CAACf,WAAW,EAAEgB,UAAU,EAAEC,WAAW,EAAE;EAAE,IAAID,UAAU,EAAEd,iBAAiB,CAACF,WAAW,CAACH,SAAS,EAAEmB,UAAU,CAAC;EAAE,IAAIC,WAAW,EAAEf,iBAAiB,CAACF,WAAW,EAAEiB,WAAW,CAAC;EAAEN,MAAM,CAACC,cAAc,CAACZ,WAAW,EAAE,WAAW,EAAE;IAAEU,QAAQ,EAAE;EAAM,CAAC,CAAC;EAAE,OAAOV,WAAW;AAAE;AAC5R,SAASa,cAAcA,CAACK,GAAG,EAAE;EAAE,IAAIJ,GAAG,GAAGK,YAAY,CAACD,GAAG,EAAE,QAAQ,CAAC;EAAE,OAAO1B,OAAO,CAACsB,GAAG,CAAC,KAAK,QAAQ,GAAGA,GAAG,GAAGM,MAAM,CAACN,GAAG,CAAC;AAAE;AAC5H,SAASK,YAAYA,CAACE,KAAK,EAAEC,IAAI,EAAE;EAAE,IAAI9B,OAAO,CAAC6B,KAAK,CAAC,KAAK,QAAQ,IAAIA,KAAK,KAAK,IAAI,EAAE,OAAOA,KAAK;EAAE,IAAIE,IAAI,GAAGF,KAAK,CAAC3B,MAAM,CAAC8B,WAAW,CAAC;EAAE,IAAID,IAAI,KAAKE,SAAS,EAAE;IAAE,IAAIC,GAAG,GAAGH,IAAI,CAACI,IAAI,CAACN,KAAK,EAAEC,IAAI,IAAI,SAAS,CAAC;IAAE,IAAI9B,OAAO,CAACkC,GAAG,CAAC,KAAK,QAAQ,EAAE,OAAOA,GAAG;IAAE,MAAM,IAAIzB,SAAS,CAAC,8CAA8C,CAAC;EAAE;EAAE,OAAO,CAACqB,IAAI,KAAK,QAAQ,GAAGF,MAAM,GAAGQ,MAAM,EAAEP,KAAK,CAAC;AAAE;AAC5X,SAASQ,SAAS,QAAQ,yBAAyB;AACnD,SAASC,IAAI,QAAQ,2BAA2B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,IAAIC,SAAS,GAAG,aAAa,YAAY;EACvC,SAASA,SAASA,CAACC,MAAM,EAAEC,QAAQ,EAAE;IACnCnC,eAAe,CAAC,IAAI,EAAEiC,SAAS,CAAC;IAChC;AACJ;AACA;IACI,IAAI,CAACC,MAAM,GAAGA,MAAM;IACpB;AACJ;AACA;AACA;AACA;IACI,IAAI,CAACE,GAAG,GAAG,IAAI,CAACF,MAAM,CAACE,GAAG;IAC1B;AACJ;AACA;AACA;AACA;AACA;IACI,IAAI,CAACC,SAAS,GAAG,EAAE;IACnB;AACJ;AACA;AACA;AACA;AACA;IACI,IAAI,CAACF,QAAQ,GAAGA,QAAQ;IACxB;AACJ;AACA;AACA;AACA;AACA;IACI,IAAI,CAACG,YAAY,GAAG,OAAO;IAC3B;AACJ;AACA;AACA;AACA;AACA;IACI,IAAI,CAACC,eAAe,GAAG,IAAI;IAC3B;AACJ;AACA;AACA;AACA;AACA;AACA;IACI,IAAI,CAACC,eAAe,GAAG,EAAE;EAC3B;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEvB,YAAY,CAACgB,SAAS,EAAE,CAAC;IACvBjB,GAAG,EAAE,aAAa;IAClByB,KAAK,EAAE,SAASC,WAAWA,CAACC,KAAK,EAAE;MACjC,IAAI,IAAI,CAACL,YAAY,KAAK,UAAU,EAAE;QACpC,OAAO,IAAI,CAACM,uBAAuB,CAAC,IAAI,CAACT,QAAQ,CAAC,CAACQ,KAAK,CAAC;MAC3D;MACA,OAAO,IAAI,CAACN,SAAS,CAACM,KAAK,CAAC;IAC9B;;IAEA;AACJ;AACA;AACA;AACA;EACE,CAAC,EAAE;IACD3B,GAAG,EAAE,iBAAiB;IACtByB,KAAK,EAAE,SAASI,eAAeA,CAAA,EAAG;MAChC,IAAI,IAAI,CAACP,YAAY,KAAK,UAAU,EAAE;QACpC,OAAO,IAAI,CAACM,uBAAuB,CAAC,IAAI,CAACT,QAAQ,CAAC;MACpD;MACA,OAAO,IAAI,CAACE,SAAS;IACvB;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;EACE,CAAC,EAAE;IACDrB,GAAG,EAAE,yBAAyB;IAC9ByB,KAAK,EAAE,SAASG,uBAAuBA,CAACE,IAAI,EAAE;MAC5C,OAAO,IAAI,CAACC,aAAa,CAACD,IAAI,CAACjB,IAAI,CAAC,IAAI,CAAC,CAAC;IAC5C;;IAEA;AACJ;AACA;AACA;AACA;AACA;EACE,CAAC,EAAE;IACDb,GAAG,EAAE,eAAe;IACpByB,KAAK,EAAE,SAASM,aAAaA,CAACZ,QAAQ,EAAE;MACtC,IAAIa,KAAK,GAAG,IAAI;MAChB,IAAIC,cAAc,GAAG,EAAE;MACvB,IAAIC,aAAa,GAAGf,QAAQ;MAC5B,IAAI,CAACe,aAAa,IAAI,OAAO,IAAI,CAACf,QAAQ,KAAK,UAAU,EAAE;QACzD,IAAI,CAACG,YAAY,GAAG,UAAU;QAC9B;MACF;MACA,IAAI,CAACY,aAAa,EAAE;QAClBA,aAAa,GAAG,IAAI,CAACf,QAAQ;MAC/B;MACAJ,SAAS,CAACmB,aAAa,EAAE,UAAUC,GAAG,EAAE;QACtC,IAAIC,WAAW,GAAG,CAAC,CAAC;QACpBJ,KAAK,CAACK,aAAa,CAACF,GAAG,EAAEC,WAAW,EAAE,QAAQ,EAAE,CAAC,CAAC,CAAC,EAAEJ,KAAK,CAACZ,GAAG,CAACkB,SAAS,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC;QACjFN,KAAK,CAACK,aAAa,CAACF,GAAG,EAAEC,WAAW,EAAE,mBAAmB,EAAE,KAAK,CAAC;QACjEJ,KAAK,CAACK,aAAa,CAACF,GAAG,EAAEC,WAAW,EAAE,gBAAgB,EAAE,IAAIG,KAAK,CAAC,+GAA+G,CAAC,CAAC;QACnLP,KAAK,CAACK,aAAa,CAACF,GAAG,EAAEC,WAAW,EAAE,mBAAmB,EAAE,IAAIG,KAAK,CAAC,kHAAkH,CAAC,CAAC;QACzLP,KAAK,CAACK,aAAa,CAACF,GAAG,EAAEC,WAAW,EAAE,cAAc,EAAED,GAAG,CAACK,iBAAiB,CAAC;QAC5ER,KAAK,CAACK,aAAa,CAACF,GAAG,EAAEC,WAAW,EAAE,MAAM,EAAE,KAAK,CAAC;QACpDJ,KAAK,CAACK,aAAa,CAACF,GAAG,EAAEC,WAAW,EAAE,cAAc,EAAE,KAAK,CAAC;QAC5DJ,KAAK,CAACK,aAAa,CAACF,GAAG,EAAEC,WAAW,EAAE,wBAAwB,EAAE,IAAI,CAAC;QACrEJ,KAAK,CAACK,aAAa,CAACF,GAAG,EAAEC,WAAW,EAAE,wBAAwB,EAAE,IAAI,CAAC;QACrEJ,KAAK,CAACK,aAAa,CAACF,GAAG,EAAEC,WAAW,EAAE,gBAAgB,EAAE,IAAI,CAAC;QAC7DJ,KAAK,CAACK,aAAa,CAACF,GAAG,EAAEC,WAAW,EAAE,UAAU,EAAE,IAAI,CAAC;QACvDJ,KAAK,CAACK,aAAa,CAACF,GAAG,EAAEC,WAAW,EAAE,YAAY,EAAE,KAAK,CAAC;QAC1DH,cAAc,CAACQ,IAAI,CAACL,WAAW,CAAC;MAClC,CAAC,CAAC;MACF,OAAOH,cAAc;IACvB;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACE,CAAC,EAAE;IACDjC,GAAG,EAAE,eAAe;IACpByB,KAAK,EAAE,SAASY,aAAaA,CAAClB,QAAQ,EAAEuB,QAAQ,EAAEC,IAAI,EAAEC,YAAY,EAAE;MACpE,IAAID,IAAI,KAAK,QAAQ,IAAIxB,QAAQ,CAACwB,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;QAClDD,QAAQ,CAACC,IAAI,CAAC,GAAGC,YAAY;QAC7B;MACF,CAAC,MAAM,IAAID,IAAI,KAAK,QAAQ,IAAIxB,QAAQ,CAACwB,IAAI,CAAC,CAACnD,MAAM,KAAK,CAAC,EAAE;QAC3D;MACF;MACA,IAAI2B,QAAQ,CAACwB,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;QAC7B,IAAIC,YAAY,YAAYL,KAAK,EAAE;UACjC,MAAMK,YAAY;QACpB;QACAF,QAAQ,CAACC,IAAI,CAAC,GAAGC,YAAY;MAC/B,CAAC,MAAM;QACL;QACA,IAAID,IAAI,KAAK,gBAAgB,IAAID,QAAQ,CAACG,iBAAiB,EAAE;UAC3DH,QAAQ,CAACC,IAAI,CAAC,GAAG,IAAI,CAACvB,GAAG,CAACkB,SAAS,EAAE,GAAGnB,QAAQ,CAACwB,IAAI,CAAC,GAAG,CAAC;QAC5D,CAAC,MAAM;UACLD,QAAQ,CAACC,IAAI,CAAC,GAAGxB,QAAQ,CAACwB,IAAI,CAAC;QACjC;MACF;IACF;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACE,CAAC,EAAE;IACD3C,GAAG,EAAE,qCAAqC;IAC1CyB,KAAK,EAAE,SAASqB,mCAAmCA,CAACC,MAAM,EAAEpB,KAAK,EAAEqB,MAAM,EAAE;MACzE,IAAI,IAAI,CAAC1B,YAAY,KAAK,UAAU,EAAE;QACpC;MACF;MACA,IAAI2B,IAAI,GAAGF,MAAM,CAACG,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,KAAK,GAAG,KAAK;MACrD,IAAI7B,SAAS,GAAG,IAAI,CAACQ,eAAe,EAAE;MACtCd,SAAS,CAACM,SAAS,EAAE,UAAUc,GAAG,EAAE;QAClC,IAAIc,IAAI,KAAK,KAAK,IAAId,GAAG,CAACgB,cAAc,IAAIxB,KAAK,EAAE;UACjD,IAAIoB,MAAM,KAAK,YAAY,EAAE;YAC3BZ,GAAG,CAACiB,cAAc,GAAGJ,MAAM;UAC7B,CAAC,MAAM,IAAID,MAAM,KAAK,YAAY,EAAE;YAClCZ,GAAG,CAACiB,cAAc,GAAG,CAAC,CAAC,GAAGJ,MAAM;UAClC;QACF;QACA,IAAIC,IAAI,KAAK,KAAK,IAAId,GAAG,CAACK,iBAAiB,IAAIb,KAAK,EAAE;UACpD,IAAIoB,MAAM,KAAK,YAAY,EAAE;YAC3BZ,GAAG,CAACkB,iBAAiB,GAAGL,MAAM;UAChC,CAAC,MAAM,IAAID,MAAM,KAAK,YAAY,EAAE;YAClCZ,GAAG,CAACkB,iBAAiB,GAAG,CAAC,CAAC,GAAGL,MAAM;UACrC;QACF;MACF,CAAC,CAAC;MACF,IAAI,CAACM,iBAAiB,CAACjC,SAAS,EAAE,KAAK,CAAC;IAC1C;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,CAAC,EAAE;IACDrB,GAAG,EAAE,oCAAoC;IACzCyB,KAAK,EAAE,SAAS8B,kCAAkCA,CAACR,MAAM,EAAEpB,KAAK,EAAEqB,MAAM,EAAEQ,SAAS,EAAEC,MAAM,EAAE;MAC3F,IAAIC,MAAM,GAAG,IAAI;MACjB,IAAIC,YAAY,GAAGC,SAAS,CAACpE,MAAM,GAAG,CAAC,IAAIoE,SAAS,CAAC,CAAC,CAAC,KAAKjD,SAAS,GAAGiD,SAAS,CAAC,CAAC,CAAC,GAAG,IAAI;MAC3F,IAAI,IAAI,CAACtC,YAAY,KAAK,UAAU,EAAE;QACpC;QACA;QACA,IAAIuC,wBAAwB,GAAG,SAASA,wBAAwBA,CAAA,EAAG;UACjEH,MAAM,CAACtC,GAAG,CAAC0C,UAAU,CAAC,kBAAkB,EAAED,wBAAwB,CAAC;UACnE,OAAOH,MAAM,CAACK,mBAAmB,EAAE;QACrC,CAAC;QACD,IAAI,CAAC3C,GAAG,CAAC4C,WAAW,CAAC,kBAAkB,EAAEH,wBAAwB,CAAC;QAClE;MACF;MACA,IAAIZ,IAAI,GAAGF,MAAM,CAACG,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,KAAK,GAAG,KAAK;MACrD,IAAIe,UAAU,GAAGlB,MAAM,CAACG,OAAO,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;MACvD,IAAI7B,SAAS,GAAG,IAAI,CAACQ,eAAe,EAAE;MACtC,IAAIqC,SAAS,GAAGnB,MAAM,CAACG,OAAO,CAAC,UAAU,CAAC,KAAK,CAAC;MAChD,IAAIiB,iBAAiB,GAAGxC,KAAK;MAC7BZ,SAAS,CAACM,SAAS,EAAE,UAAUc,GAAG,EAAE;QAClC,IAAIc,IAAI,KAAK,KAAK,IAAId,GAAG,CAACgB,cAAc,IAAIgB,iBAAiB,EAAE;UAC7DhC,GAAG,CAACiB,cAAc,GAAGa,UAAU,GAAGjB,MAAM;QAC1C;QACA,IAAIC,IAAI,KAAK,KAAK,IAAId,GAAG,CAACK,iBAAiB,IAAI2B,iBAAiB,EAAE;UAChEhC,GAAG,CAACkB,iBAAiB,GAAGY,UAAU,GAAGjB,MAAM;QAC7C;MACF,CAAC,CAAC;MACF,IAAI,CAACM,iBAAiB,CAACjC,SAAS,EAAE,CAAC6C,SAAS,CAAC;MAC7C,IAAIA,SAAS,EAAE;QACbnD,SAAS,CAACM,SAAS,EAAE,UAAUqB,QAAQ,EAAE;UACvCgB,MAAM,CAACU,oBAAoB,CAAC1B,QAAQ,EAAEyB,iBAAiB,EAAEX,SAAS,CAAC,CAAC,CAAC,EAAEA,SAAS,CAAChE,MAAM,CAAC;UACxFkE,MAAM,CAACW,sBAAsB,CAAC3B,QAAQ,CAAC;UACvCgB,MAAM,CAACY,sBAAsB,CAAC5B,QAAQ,CAAC;QACzC,CAAC,CAAC;MACJ,CAAC,MAAM;QACL3B,SAAS,CAACM,SAAS,EAAE,UAAUqB,QAAQ,EAAE;UACvCgB,MAAM,CAACa,wBAAwB,CAAC7B,QAAQ,EAAEyB,iBAAiB,CAAC;QAC9D,CAAC,CAAC;MACJ;MACA,IAAIR,YAAY,EAAE;QAChB,IAAI,CAACI,mBAAmB,EAAE;MAC5B;IACF;;IAEA;AACJ;AACA;AACA;AACA;AACA;EACE,CAAC,EAAE;IACD/D,GAAG,EAAE,wBAAwB;IAC7ByB,KAAK,EAAE,SAAS6C,sBAAsBA,CAAC5B,QAAQ,EAAE;MAC/CA,QAAQ,CAACU,cAAc,GAAG,KAAK,CAAC;MAChCV,QAAQ,CAACW,iBAAiB,GAAG,KAAK,CAAC;IACrC;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,CAAC,EAAE;IACDrD,GAAG,EAAE,sBAAsB;IAC3ByB,KAAK,EAAE,SAAS2C,oBAAoBA,CAAC1B,QAAQ,EAAEyB,iBAAiB,EAAEK,gBAAgB,EAAEC,MAAM,EAAE;MAC1F1D,SAAS,CAAC2B,QAAQ,CAACgC,MAAM,EAAE,UAAUC,KAAK,EAAE;QAC1C;QACA,IAAIA,KAAK,CAAC,CAAC,CAAC,EAAE;UACZ,IAAIR,iBAAiB,IAAIQ,KAAK,CAAC,CAAC,CAAC,IAAIR,iBAAiB,IAAIQ,KAAK,CAAC,CAAC,CAAC,EAAE;YAClE,IAAIH,gBAAgB,GAAGG,KAAK,CAAC,CAAC,CAAC,EAAE;cAC/BA,KAAK,CAAC,CAAC,CAAC,IAAIF,MAAM;YACpB,CAAC,MAAM,IAAID,gBAAgB,GAAGG,KAAK,CAAC,CAAC,CAAC,EAAE;cACtCA,KAAK,CAAC,CAAC,CAAC,IAAIF,MAAM;YACpB;UACF,CAAC,MAAM,IAAID,gBAAgB,IAAIG,KAAK,CAAC,CAAC,CAAC,IAAIH,gBAAgB,IAAIG,KAAK,CAAC,CAAC,CAAC,EAAE;YACvEA,KAAK,CAAC,CAAC,CAAC,IAAIF,MAAM;YAClB,IAAIN,iBAAiB,IAAIQ,KAAK,CAAC,CAAC,CAAC,EAAE;cACjCA,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC;cACbA,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC;YACf;UACF;QACF;MACF,CAAC,CAAC;IACJ;;IAEA;AACJ;AACA;AACA;AACA;AACA;EACE,CAAC,EAAE;IACD3E,GAAG,EAAE,wBAAwB;IAC7ByB,KAAK,EAAE,SAAS4C,sBAAsBA,CAAC3B,QAAQ,EAAE;MAC/C,IAAIkC,MAAM,GAAG,IAAI;MACjB,IAAIF,MAAM,GAAGhC,QAAQ,CAACgC,MAAM;MAC5B,IAAIG,SAAS,GAAG,EAAE;MAClB,IAAIC,UAAU,GAAG,EAAE;MACnB/D,SAAS,CAAC2D,MAAM,EAAE,UAAUC,KAAK,EAAE;QACjC,IAAII,QAAQ,GAAG,EAAE;QACjB,IAAIJ,KAAK,CAAC,CAAC,CAAC,EAAE;UACZ,KAAK,IAAIpF,CAAC,GAAGoF,KAAK,CAAC,CAAC,CAAC,EAAEpF,CAAC,IAAIoF,KAAK,CAAC,CAAC,CAAC,EAAEpF,CAAC,EAAE,EAAE;YACzCwF,QAAQ,CAACtC,IAAI,CAACmC,MAAM,CAACxD,GAAG,CAAC4D,aAAa,CAACzF,CAAC,CAAC,CAAC;UAC5C;QACF,CAAC,MAAM;UACLwF,QAAQ,CAACtC,IAAI,CAACmC,MAAM,CAACxD,GAAG,CAAC4D,aAAa,CAACL,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;QACnD;QACAG,UAAU,CAACrC,IAAI,CAACsC,QAAQ,CAAC;MAC3B,CAAC,CAAC;MACFhE,SAAS,CAAC+D,UAAU,EAAE,UAAUH,KAAK,EAAE;QACrC,IAAII,QAAQ,GAAG,EAAE;QACjBhE,SAAS,CAAC4D,KAAK,EAAE,UAAUM,KAAK,EAAEtD,KAAK,EAAE;UACvC,IAAIA,KAAK,KAAK,CAAC,EAAE;YACfoD,QAAQ,CAACtC,IAAI,CAACwC,KAAK,CAAC;UACtB,CAAC,MAAM,IAAIN,KAAK,CAAChD,KAAK,CAAC,KAAKgD,KAAK,CAAChD,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,EAAE;YAChDoD,QAAQ,CAACtC,IAAI,CAACkC,KAAK,CAAChD,KAAK,GAAG,CAAC,CAAC,CAAC;YAC/BkD,SAAS,CAACpC,IAAI,CAACsC,QAAQ,CAAC;YACxBA,QAAQ,GAAG,EAAE;YACbA,QAAQ,CAACtC,IAAI,CAACwC,KAAK,CAAC;UACtB;UACA,IAAItD,KAAK,KAAKgD,KAAK,CAACnF,MAAM,GAAG,CAAC,EAAE;YAC9BuF,QAAQ,CAACtC,IAAI,CAACwC,KAAK,CAAC;YACpBJ,SAAS,CAACpC,IAAI,CAACsC,QAAQ,CAAC;UAC1B;QACF,CAAC,CAAC;MACJ,CAAC,CAAC;MACFrC,QAAQ,CAACgC,MAAM,GAAGG,SAAS;IAC7B;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;EACE,CAAC,EAAE;IACD7E,GAAG,EAAE,0BAA0B;IAC/ByB,KAAK,EAAE,SAAS8C,wBAAwBA,CAAC7B,QAAQ,EAAEwC,gBAAgB,EAAE;MACnE,IAAIxC,QAAQ,CAACU,cAAc,IAAIV,QAAQ,CAACU,cAAc,KAAK,CAAC,EAAE;QAC5DV,QAAQ,CAACS,cAAc,IAAIT,QAAQ,CAACU,cAAc,IAAI,CAAC;QACvDrC,SAAS,CAAC2B,QAAQ,CAACgC,MAAM,EAAE,UAAUS,OAAO,EAAE;UAC5CpE,SAAS,CAACoE,OAAO,EAAE,UAAUC,UAAU,EAAEC,CAAC,EAAE;YAC1C,IAAID,UAAU,IAAIF,gBAAgB,EAAE;cAClCC,OAAO,CAACE,CAAC,CAAC,IAAI3C,QAAQ,CAACU,cAAc,IAAI,CAAC;YAC5C;UACF,CAAC,CAAC;QACJ,CAAC,CAAC;MACJ,CAAC,MAAM,IAAIV,QAAQ,CAACW,iBAAiB,IAAIX,QAAQ,CAACW,iBAAiB,KAAK,CAAC,EAAE;QACzEX,QAAQ,CAACF,iBAAiB,IAAIE,QAAQ,CAACW,iBAAiB,IAAI,CAAC;QAC7DX,QAAQ,CAAC4C,YAAY,IAAI5C,QAAQ,CAACW,iBAAiB,IAAI,CAAC;MAC1D;IACF;;IAEA;AACJ;AACA;AACA;AACA;AACA;EACE,CAAC,EAAE;IACDrD,GAAG,EAAE,mBAAmB;IACxByB,KAAK,EAAE,SAAS6B,iBAAiBA,CAAA,EAAG;MAClC,IAAIiC,MAAM,GAAG,IAAI;MACjB,IAAIlE,SAAS,GAAGuC,SAAS,CAACpE,MAAM,GAAG,CAAC,IAAIoE,SAAS,CAAC,CAAC,CAAC,KAAKjD,SAAS,GAAGiD,SAAS,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC/B,eAAe,EAAE;MAC1G,IAAI2D,SAAS,GAAG5B,SAAS,CAACpE,MAAM,GAAG,CAAC,IAAIoE,SAAS,CAAC,CAAC,CAAC,KAAKjD,SAAS,GAAGiD,SAAS,CAAC,CAAC,CAAC,GAAG,IAAI;MACxF,IAAI6B,qBAAqB,GAAGpE,SAAS,CAACqE,IAAI,CAAC,UAAUhD,QAAQ,EAAE;QAC7D,IAAIU,cAAc,GAAGV,QAAQ,CAACU,cAAc,IAAI,CAAC;QACjD,IAAIuC,cAAc,GAAGjD,QAAQ,CAACW,iBAAiB,IAAI,CAAC;QACpD,IAAIX,QAAQ,CAACS,cAAc,GAAGC,cAAc,IAAImC,MAAM,CAACnE,GAAG,CAACkB,SAAS,EAAE,IAAII,QAAQ,CAACF,iBAAiB,GAAGmD,cAAc,IAAIJ,MAAM,CAACnE,GAAG,CAACwE,SAAS,EAAE,EAAE;UAC/I,OAAO,IAAI;QACb;QACA,OAAO,KAAK;MACd,CAAC,CAAC;MACF,IAAIH,qBAAqB,EAAE;QACzB;MACF;MACA,IAAI,CAACjE,eAAe,GAAG,EAAE;MACzBT,SAAS,CAACM,SAAS,EAAE,UAAUqB,QAAQ,EAAE;QACvC6C,MAAM,CAACM,kBAAkB,CAACnD,QAAQ,EAAE8C,SAAS,CAAC;MAChD,CAAC,CAAC;MACF,IAAI,CAACpE,GAAG,CAAC0E,aAAa,CAAC,IAAI,CAACtE,eAAe,EAAE,qBAAqB,CAAC;MACnE,IAAI,CAACA,eAAe,GAAG,EAAE;IAC3B;;IAEA;AACJ;AACA;EACE,CAAC,EAAE;IACDxB,GAAG,EAAE,qBAAqB;IAC1ByB,KAAK,EAAE,SAASsC,mBAAmBA,CAAA,EAAG;MACpC,IAAIgC,MAAM,GAAG,IAAI;MACjB,IAAI,CAACvE,eAAe,GAAG,EAAE;MACzBT,SAAS,CAAC,IAAI,CAACc,eAAe,EAAE,EAAE,UAAUJ,KAAK,EAAE;QACjDsE,MAAM,CAACxE,eAAe,GAAGE,KAAK;QAC9BsE,MAAM,CAAC7E,MAAM,CAAC8E,SAAS,CAACvE,KAAK,CAAC;QAC9BsE,MAAM,CAACE,gBAAgB,CAACxE,KAAK,EAAE,MAAM,CAAC;MACxC,CAAC,CAAC;MACF,IAAI,CAACF,eAAe,GAAG,IAAI;MAC3B,IAAI,CAACH,GAAG,CAAC0E,aAAa,CAAC,IAAI,CAACtE,eAAe,EAAE,qBAAqB,CAAC;MACnE,IAAI,CAACA,eAAe,GAAG,EAAE;IAC3B;;IAEA;AACJ;AACA;AACA;AACA;EACE,CAAC,EAAE;IACDxB,GAAG,EAAE,yBAAyB;IAC9ByB,KAAK,EAAE,SAASyE,uBAAuBA,CAACC,OAAO,EAAE;MAC/C,IAAIC,MAAM,GAAG,IAAI;MACjB,IAAIC,aAAa,GAAG,EAAE;MACtB,IAAI,CAAC7E,eAAe,GAAG,EAAE;MACzBT,SAAS,CAACoF,OAAO,EAAE,UAAU1E,KAAK,EAAEzB,GAAG,EAAEsG,UAAU,EAAE;QACnD;QACA,IAAI,EAAE,CAACC,MAAM,CAAC9E,KAAK,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,KAAK,EAAE,CAAC8E,MAAM,CAAC9E,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE;UACrD;QACF;QACAV,SAAS,CAACqF,MAAM,CAACvE,eAAe,EAAE,EAAE,UAAUa,QAAQ,EAAE2C,CAAC,EAAE;UACzD,IAAIe,MAAM,CAAChF,GAAG,CAACoF,SAAS,CAACF,UAAU,CAACtG,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK0C,QAAQ,CAAC4C,YAAY,IAAIe,aAAa,CAACnD,OAAO,CAACmC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE;YACzGgB,aAAa,CAAC5D,IAAI,CAAC4C,CAAC,CAAC;UACvB;QACF,CAAC,CAAC;MACJ,CAAC,CAAC;MACFtE,SAAS,CAACsF,aAAa,EAAE,UAAU5E,KAAK,EAAE;QACxC2E,MAAM,CAACK,eAAe,CAACL,MAAM,CAAC1E,WAAW,CAACD,KAAK,CAAC,CAAC;MACnD,CAAC,CAAC;MACF,IAAI,CAACL,GAAG,CAAC0E,aAAa,CAAC,IAAI,CAACtE,eAAe,EAAE,qBAAqB,CAAC;MACnE,IAAI,CAACA,eAAe,GAAG,EAAE;IAC3B;;IAEA;AACJ;AACA;AACA;AACA;EACE,CAAC,EAAE;IACDxB,GAAG,EAAE,iBAAiB;IACtByB,KAAK,EAAE,SAASgF,eAAeA,CAAC/D,QAAQ,EAAE;MACxC,IAAI,CAACnB,eAAe,GAAGmB,QAAQ;MAC/B,IAAI,CAACxB,MAAM,CAAC8E,SAAS,CAACtD,QAAQ,CAAC;MAC/B,IAAI,CAACuD,gBAAgB,CAACvD,QAAQ,CAAC;MAC/B,IAAI,CAACnB,eAAe,GAAG,IAAI;IAC7B;;IAEA;AACJ;AACA;AACA;AACA;AACA;EACE,CAAC,EAAE;IACDvB,GAAG,EAAE,oBAAoB;IACzByB,KAAK,EAAE,SAASoE,kBAAkBA,CAACnD,QAAQ,EAAE;MAC3C,IAAI8C,SAAS,GAAG5B,SAAS,CAACpE,MAAM,GAAG,CAAC,IAAIoE,SAAS,CAAC,CAAC,CAAC,KAAKjD,SAAS,GAAGiD,SAAS,CAAC,CAAC,CAAC,GAAG,IAAI;MACxF,IAAIR,cAAc,GAAGV,QAAQ,CAACU,cAAc,IAAI,CAAC;MACjD,IAAIuC,cAAc,GAAGjD,QAAQ,CAACW,iBAAiB,IAAI,CAAC;MACpD,IAAI,CAAC7B,eAAe,CAACiB,IAAI,CAAC,CAAC,IAAI,CAACrB,GAAG,CAACsF,WAAW,CAAChE,QAAQ,CAACS,cAAc,IAAIqC,SAAS,GAAGpC,cAAc,GAAG,CAAC,CAAC,CAAC,EAAE,IAAI,CAAChC,GAAG,CAACuF,cAAc,CAACjE,QAAQ,CAACF,iBAAiB,IAAIgD,SAAS,GAAGG,cAAc,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;IAC3M;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;EACE,CAAC,EAAE;IACD3F,GAAG,EAAE,kBAAkB;IACvByB,KAAK,EAAE,SAASwE,gBAAgBA,CAACvD,QAAQ,EAAEe,MAAM,EAAE;MACjD,IAAImD,MAAM,GAAGhD,SAAS,CAACpE,MAAM,GAAG,CAAC,IAAIoE,SAAS,CAAC,CAAC,CAAC,KAAKjD,SAAS,GAAGiD,SAAS,CAAC,CAAC,CAAC,GAAG,KAAK;MACtF,IAAIiD,sBAAsB,GAAG,IAAI,CAACzF,GAAG,CAACsF,WAAW,CAAChE,QAAQ,CAACS,cAAc,CAAC;MAC1E,IAAIT,QAAQ,CAACS,cAAc,IAAI,IAAI,CAAC/B,GAAG,CAACkB,SAAS,EAAE,IAAII,QAAQ,CAACF,iBAAiB,IAAI,IAAI,CAACpB,GAAG,CAACwE,SAAS,EAAE,EAAE;QACzG,IAAI,CAACkB,uBAAuB,EAAE;QAC9B;MACF;MACA,IAAIC,oBAAoB,GAAG,IAAI,CAAC3F,GAAG,CAACsF,WAAW,CAAChE,QAAQ,CAACS,cAAc,CAAC;MACxE,IAAI4D,oBAAoB,KAAK,IAAI,EAAE;QACjC,IAAIC,QAAQ,GAAG,IAAI,CAAC5F,GAAG,CAAC6F,WAAW,CAACF,oBAAoB,EAAErE,QAAQ,CAACF,iBAAiB,CAAC;QACrF,IAAIiB,MAAM,KAAK,MAAM,IAAIuD,QAAQ,CAACE,QAAQ,KAAKxE,QAAQ,CAACwE,QAAQ,EAAE;UAChEF,QAAQ,CAACE,QAAQ,GAAGxE,QAAQ,CAACwE,QAAQ;UACrCF,QAAQ,CAACG,SAAS,GAAG,qBAAqB;QAC5C;MACF;MACA,IAAIzE,QAAQ,CAAC0E,UAAU,IAAI,CAACC,KAAK,CAAC3E,QAAQ,CAAC4E,MAAM,CAAC,EAAE;QAClD5E,QAAQ,CAAC4E,MAAM,GAAG5E,QAAQ,CAAC4E,MAAM,CAACC,OAAO,CAAC7E,QAAQ,CAAC0E,UAAU,CAAC;MAChE;MACA,IAAIR,MAAM,EAAE;QACV,IAAI,CAACxF,GAAG,CAAC0E,aAAa,CAACe,sBAAsB,EAAEnE,QAAQ,CAACF,iBAAiB,EAAEE,QAAQ,CAAC4E,MAAM,EAAE,mBAAmB,CAAC;MAClH,CAAC,MAAM;QACL,IAAI,CAAC9F,eAAe,CAACiB,IAAI,CAAC,CAACoE,sBAAsB,EAAEnE,QAAQ,CAACF,iBAAiB,EAAEE,QAAQ,CAAC4E,MAAM,CAAC,CAAC;MAClG;MACA5E,QAAQ,CAACU,cAAc,GAAG,KAAK,CAAC;MAChCV,QAAQ,CAACW,iBAAiB,GAAG,KAAK,CAAC;IACrC;;IAEA;AACJ;AACA;AACA;AACA;EACE,CAAC,EAAE;IACDrD,GAAG,EAAE,yBAAyB;IAC9ByB,KAAK,EAAE,SAASqF,uBAAuBA,CAAA,EAAG;MACxC9F,IAAI,CAAC,qGAAqG,CAAC;IAC7G;EACF,CAAC,CAAC,CAAC;EACH,OAAOC,SAAS;AAClB,CAAC,EAAE;AACH,eAAeA,SAAS"},"metadata":{},"sourceType":"module","externalDependencies":[]}