{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nimport { fastInnerText } from \"../../../../helpers/dom/element.mjs\";\nimport { randomString } from \"../../../../helpers/string.mjs\";\nimport EventManager from \"../../../../eventManager.mjs\";\nimport Scroll from \"../scroll.mjs\";\nimport CellCoords from \"../cell/coords.mjs\";\nimport CellRange from \"../cell/range.mjs\";\n/**\n * @abstract\n * @class Walkontable\n */\nvar CoreAbstract = /*#__PURE__*/function () {\n  /**\n   * @param {HTMLTableElement} table Main table.\n   * @param {Settings} settings The Walkontable settings.\n   */\n  function CoreAbstract(table, settings) {\n    _classCallCheck(this, CoreAbstract);\n    _defineProperty(this, \"wtTable\", void 0);\n    _defineProperty(this, \"wtScroll\", void 0);\n    _defineProperty(this, \"wtViewport\", void 0);\n    _defineProperty(this, \"wtOverlays\", void 0);\n    _defineProperty(this, \"selections\", void 0);\n    _defineProperty(this, \"wtEvent\", void 0);\n    _defineProperty(this, \"guid\", \"wt_\".concat(randomString()));\n    _defineProperty(this, \"drawInterrupted\", false);\n    _defineProperty(this, \"drawn\", false);\n    _defineProperty(this, \"domBindings\", void 0);\n    _defineProperty(this, \"wtSettings\", void 0);\n    this.domBindings = {\n      rootTable: table,\n      rootDocument: table.ownerDocument,\n      rootWindow: table.ownerDocument.defaultView\n    };\n    this.wtSettings = settings;\n    this.wtScroll = new Scroll(this.createScrollDao());\n  }\n  _createClass(CoreAbstract, [{\n    key: \"eventManager\",\n    get:\n    /**\n     * The walkontable instance id.\n     *\n     * @public\n     * @type {Readonly<string>}\n     */\n\n    /**\n     * The DOM bindings.\n     *\n     * @public\n     * @type {DomBindings}\n     */\n\n    /**\n     * Settings.\n     *\n     * @public\n     * @type {Settings}\n     */\n\n    function get() {\n      return new EventManager(this);\n    }\n  }, {\n    key: \"findOriginalHeaders\",\n    value: function findOriginalHeaders() {\n      var originalHeaders = [];\n\n      // find original headers\n      if (this.wtTable.THEAD.childNodes.length && this.wtTable.THEAD.childNodes[0].childNodes.length) {\n        for (var c = 0, clen = this.wtTable.THEAD.childNodes[0].childNodes.length; c < clen; c++) {\n          originalHeaders.push(this.wtTable.THEAD.childNodes[0].childNodes[c].innerHTML);\n        }\n        if (!this.wtSettings.getSetting('columnHeaders').length) {\n          this.wtSettings.update('columnHeaders', [function (column, TH) {\n            fastInnerText(TH, originalHeaders[column]);\n          }]);\n        }\n      }\n    }\n\n    /**\n     * Creates and returns the CellCoords object.\n     *\n     * @param {*} row The row index.\n     * @param {*} column The column index.\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"createCellCoords\",\n    value: function createCellCoords(row, column) {\n      return new CellCoords(row, column, this.wtSettings.getSetting('rtlMode'));\n    }\n\n    /**\n     * Creates and returns the CellRange object.\n     *\n     * @param {CellCoords} highlight The highlight coordinates.\n     * @param {CellCoords} from The from coordinates.\n     * @param {CellCoords} to The to coordinates.\n     * @returns {CellRange}\n     */\n  }, {\n    key: \"createCellRange\",\n    value: function createCellRange(highlight, from, to) {\n      return new CellRange(highlight, from, to, this.wtSettings.getSetting('rtlMode'));\n    }\n\n    /**\n     * Force rerender of Walkontable.\n     *\n     * @param {boolean} [fastDraw=false] When `true`, try to refresh only the positions of borders without rerendering\n     *                                   the data. It will only work if Table.draw() does not force\n     *                                   rendering anyway.\n     * @returns {Walkontable}\n     */\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      this.drawInterrupted = false;\n      if (!fastDraw && !this.wtTable.isVisible()) {\n        // draw interrupted because TABLE is not visible\n        this.drawInterrupted = true;\n      } else {\n        this.wtTable.draw(fastDraw);\n      }\n      return this;\n    }\n\n    /**\n     * Returns the TD at coords. If topmost is set to true, returns TD from the topmost overlay layer,\n     * if not set or set to false, returns TD from the master table.\n     *\n     * @param {CellCoords} coords The cell coordinates.\n     * @param {boolean} [topmost=false] If set to `true`, it returns the TD element from the topmost overlay. For example,\n     *                                  if the wanted cell is in the range of fixed rows, it will return a TD element\n     *                                  from the top overlay.\n     * @returns {HTMLElement}\n     */\n  }, {\n    key: \"getCell\",\n    value: function getCell(coords) {\n      var topmost = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (!topmost) {\n        return this.wtTable.getCell(coords);\n      }\n      var totalRows = this.wtSettings.getSetting('totalRows');\n      var fixedRowsTop = this.wtSettings.getSetting('fixedRowsTop');\n      var fixedRowsBottom = this.wtSettings.getSetting('fixedRowsBottom');\n      var fixedColumnsStart = this.wtSettings.getSetting('fixedColumnsStart');\n      if (coords.row < fixedRowsTop && coords.col < fixedColumnsStart) {\n        return this.wtOverlays.topInlineStartCornerOverlay.clone.wtTable.getCell(coords);\n      } else if (coords.row < fixedRowsTop) {\n        return this.wtOverlays.topOverlay.clone.wtTable.getCell(coords);\n      } else if (coords.col < fixedColumnsStart && coords.row >= totalRows - fixedRowsBottom) {\n        if (this.wtOverlays.bottomInlineStartCornerOverlay && this.wtOverlays.bottomInlineStartCornerOverlay.clone) {\n          return this.wtOverlays.bottomInlineStartCornerOverlay.clone.wtTable.getCell(coords);\n        }\n      } else if (coords.col < fixedColumnsStart) {\n        return this.wtOverlays.inlineStartOverlay.clone.wtTable.getCell(coords);\n      } else if (coords.row < totalRows && coords.row >= totalRows - fixedRowsBottom) {\n        if (this.wtOverlays.bottomOverlay && this.wtOverlays.bottomOverlay.clone) {\n          return this.wtOverlays.bottomOverlay.clone.wtTable.getCell(coords);\n        }\n      }\n      return this.wtTable.getCell(coords);\n    }\n\n    /**\n     * Scrolls the viewport to a cell (rerenders if needed).\n     *\n     * @param {CellCoords} coords The cell coordinates to scroll to.\n     * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.\n     * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right of the table.\n     * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom of the table.\n     * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left of the table.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"scrollViewport\",\n    value: function scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft) {\n      if (coords.col < 0 || coords.row < 0) {\n        return false;\n      }\n      return this.wtScroll.scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft);\n    }\n\n    /**\n     * Scrolls the viewport to a column (rerenders if needed).\n     *\n     * @param {number} column Visual column index.\n     * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right of the table.\n     * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left of the table.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"scrollViewportHorizontally\",\n    value: function scrollViewportHorizontally(column, snapToRight, snapToLeft) {\n      if (column < 0) {\n        return false;\n      }\n      return this.wtScroll.scrollViewportHorizontally(column, snapToRight, snapToLeft);\n    }\n\n    /**\n     * Scrolls the viewport to a row (rerenders if needed).\n     *\n     * @param {number} row Visual row index.\n     * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.\n     * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom of the table.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"scrollViewportVertically\",\n    value: function scrollViewportVertically(row, snapToTop, snapToBottom) {\n      if (row < 0) {\n        return false;\n      }\n      return this.wtScroll.scrollViewportVertically(row, snapToTop, snapToBottom);\n    }\n\n    /**\n     * @returns {Array}\n     */\n  }, {\n    key: \"getViewport\",\n    value: function getViewport() {\n      return [this.wtTable.getFirstVisibleRow(), this.wtTable.getFirstVisibleColumn(), this.wtTable.getLastVisibleRow(), this.wtTable.getLastVisibleColumn()];\n    }\n\n    /**\n     * Destroy instance.\n     */\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.wtOverlays.destroy();\n      this.wtEvent.destroy();\n    }\n\n    /**\n     * Create data access object for scroll.\n     *\n     * @protected\n     * @returns {ScrollDao}\n     */\n  }, {\n    key: \"createScrollDao\",\n    value: function createScrollDao() {\n      var wot = this;\n      return {\n        get drawn() {\n          return wot.drawn; // TODO refactoring: consider about injecting `isDrawn` function : ()=>return wot.drawn. (it'll enables remove dao layer)\n        },\n\n        get topOverlay() {\n          return wot.wtOverlays.topOverlay; // TODO refactoring: move outside dao, use IOC\n        },\n\n        get inlineStartOverlay() {\n          return wot.wtOverlays.inlineStartOverlay; // TODO refactoring: move outside dao, use IOC\n        },\n\n        get wtTable() {\n          return wot.wtTable; // TODO refactoring: move outside dao, use IOC\n        },\n\n        get wtViewport() {\n          return wot.wtViewport; // TODO refactoring: move outside dao, use IOC\n        },\n\n        get rootWindow() {\n          return wot.domBindings.rootWindow; // TODO refactoring: move outside dao\n        },\n\n        // TODO refactoring, consider about using injecting wtSettings into scroll (it'll enables remove dao layer)\n        get totalRows() {\n          return wot.wtSettings.getSetting('totalRows');\n        },\n        get totalColumns() {\n          return wot.wtSettings.getSetting('totalColumns');\n        },\n        get fixedRowsTop() {\n          return wot.wtSettings.getSetting('fixedRowsTop');\n        },\n        get fixedRowsBottom() {\n          return wot.wtSettings.getSetting('fixedRowsBottom');\n        },\n        get fixedColumnsStart() {\n          return wot.wtSettings.getSetting('fixedColumnsStart');\n        }\n      };\n    }\n    // TODO refactoring: it will be much better to not use DAO objects. They are needed for now to provide\n    // dynamically access to related objects\n    /**\n     * Create data access object for wtTable.\n     *\n     * @protected\n     * @returns {TableDao}\n     */\n  }, {\n    key: \"getTableDao\",\n    value: function getTableDao() {\n      var wot = this;\n      return {\n        get wot() {\n          return wot;\n        },\n        get parentTableOffset() {\n          return wot.cloneSource.wtTable.tableOffset; // TODO rethink: cloneSource exists only in Clone type.\n        },\n\n        get cloneSource() {\n          return wot.cloneSource; // TODO rethink: cloneSource exists only in Clone type.\n        },\n\n        get workspaceWidth() {\n          return wot.wtViewport.getWorkspaceWidth();\n        },\n        get wtViewport() {\n          return wot.wtViewport; // TODO refactoring: move outside dao, use IOC\n        },\n\n        get wtOverlays() {\n          return wot.wtOverlays; // TODO refactoring: move outside dao, use IOC\n        },\n\n        get selections() {\n          return wot.selections; // TODO refactoring: move outside dao, use IOC\n        },\n\n        get drawn() {\n          return wot.drawn;\n        },\n        set drawn(v) {\n          // TODO rethink: this breaks assumes of data access object, however it is required until invent better way to handle WOT state.\n          wot.drawn = v;\n        },\n        get wtTable() {\n          return wot.wtTable; // TODO refactoring: it provides itself\n        },\n\n        get startColumnRendered() {\n          return wot.wtViewport.columnsRenderCalculator.startColumn;\n        },\n        get startColumnVisible() {\n          return wot.wtViewport.columnsVisibleCalculator.startColumn;\n        },\n        get endColumnRendered() {\n          return wot.wtViewport.columnsRenderCalculator.endColumn;\n        },\n        get endColumnVisible() {\n          return wot.wtViewport.columnsVisibleCalculator.endColumn;\n        },\n        get countColumnsRendered() {\n          return wot.wtViewport.columnsRenderCalculator.count;\n        },\n        get countColumnsVisible() {\n          return wot.wtViewport.columnsVisibleCalculator.count;\n        },\n        get startRowRendered() {\n          return wot.wtViewport.rowsRenderCalculator.startRow;\n        },\n        get startRowVisible() {\n          return wot.wtViewport.rowsVisibleCalculator.startRow;\n        },\n        get endRowRendered() {\n          return wot.wtViewport.rowsRenderCalculator.endRow;\n        },\n        get endRowVisible() {\n          return wot.wtViewport.rowsVisibleCalculator.endRow;\n        },\n        get countRowsRendered() {\n          return wot.wtViewport.rowsRenderCalculator.count;\n        },\n        get countRowsVisible() {\n          return wot.wtViewport.rowsVisibleCalculator.count;\n        }\n      };\n    }\n  }]);\n  return CoreAbstract;\n}();\nexport { CoreAbstract as default };","map":{"version":3,"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","_toPropertyKey","key","_createClass","protoProps","staticProps","_defineProperty","value","arg","_toPrimitive","String","input","hint","prim","toPrimitive","undefined","res","call","Number","fastInnerText","randomString","EventManager","Scroll","CellCoords","CellRange","CoreAbstract","table","settings","concat","domBindings","rootTable","rootDocument","ownerDocument","rootWindow","defaultView","wtSettings","wtScroll","createScrollDao","get","findOriginalHeaders","originalHeaders","wtTable","THEAD","childNodes","c","clen","push","innerHTML","getSetting","update","column","TH","createCellCoords","row","createCellRange","highlight","from","to","draw","fastDraw","arguments","drawInterrupted","isVisible","getCell","coords","topmost","totalRows","fixedRowsTop","fixedRowsBottom","fixedColumnsStart","col","wtOverlays","topInlineStartCornerOverlay","clone","topOverlay","bottomInlineStartCornerOverlay","inlineStartOverlay","bottomOverlay","scrollViewport","snapToTop","snapToRight","snapToBottom","snapToLeft","scrollViewportHorizontally","scrollViewportVertically","getViewport","getFirstVisibleRow","getFirstVisibleColumn","getLastVisibleRow","getLastVisibleColumn","destroy","wtEvent","wot","drawn","wtViewport","totalColumns","getTableDao","parentTableOffset","cloneSource","tableOffset","workspaceWidth","getWorkspaceWidth","selections","v","startColumnRendered","columnsRenderCalculator","startColumn","startColumnVisible","columnsVisibleCalculator","endColumnRendered","endColumn","endColumnVisible","countColumnsRendered","count","countColumnsVisible","startRowRendered","rowsRenderCalculator","startRow","startRowVisible","rowsVisibleCalculator","endRowRendered","endRow","endRowVisible","countRowsRendered","countRowsVisible","default"],"sources":["/home/rstorey/wwwdev/Blucktool/node_modules/handsontable/3rdparty/walkontable/src/core/_base.mjs"],"sourcesContent":["import \"core-js/modules/es.symbol.to-primitive.js\";\nimport \"core-js/modules/es.date.to-primitive.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { fastInnerText } from \"../../../../helpers/dom/element.mjs\";\nimport { randomString } from \"../../../../helpers/string.mjs\";\nimport EventManager from \"../../../../eventManager.mjs\";\nimport Scroll from \"../scroll.mjs\";\nimport CellCoords from \"../cell/coords.mjs\";\nimport CellRange from \"../cell/range.mjs\";\n/**\n * @abstract\n * @class Walkontable\n */\nvar CoreAbstract = /*#__PURE__*/function () {\n  /**\n   * @param {HTMLTableElement} table Main table.\n   * @param {Settings} settings The Walkontable settings.\n   */\n  function CoreAbstract(table, settings) {\n    _classCallCheck(this, CoreAbstract);\n    _defineProperty(this, \"wtTable\", void 0);\n    _defineProperty(this, \"wtScroll\", void 0);\n    _defineProperty(this, \"wtViewport\", void 0);\n    _defineProperty(this, \"wtOverlays\", void 0);\n    _defineProperty(this, \"selections\", void 0);\n    _defineProperty(this, \"wtEvent\", void 0);\n    _defineProperty(this, \"guid\", \"wt_\".concat(randomString()));\n    _defineProperty(this, \"drawInterrupted\", false);\n    _defineProperty(this, \"drawn\", false);\n    _defineProperty(this, \"domBindings\", void 0);\n    _defineProperty(this, \"wtSettings\", void 0);\n    this.domBindings = {\n      rootTable: table,\n      rootDocument: table.ownerDocument,\n      rootWindow: table.ownerDocument.defaultView\n    };\n    this.wtSettings = settings;\n    this.wtScroll = new Scroll(this.createScrollDao());\n  }\n  _createClass(CoreAbstract, [{\n    key: \"eventManager\",\n    get:\n    /**\n     * The walkontable instance id.\n     *\n     * @public\n     * @type {Readonly<string>}\n     */\n\n    /**\n     * The DOM bindings.\n     *\n     * @public\n     * @type {DomBindings}\n     */\n\n    /**\n     * Settings.\n     *\n     * @public\n     * @type {Settings}\n     */\n\n    function get() {\n      return new EventManager(this);\n    }\n  }, {\n    key: \"findOriginalHeaders\",\n    value: function findOriginalHeaders() {\n      var originalHeaders = [];\n\n      // find original headers\n      if (this.wtTable.THEAD.childNodes.length && this.wtTable.THEAD.childNodes[0].childNodes.length) {\n        for (var c = 0, clen = this.wtTable.THEAD.childNodes[0].childNodes.length; c < clen; c++) {\n          originalHeaders.push(this.wtTable.THEAD.childNodes[0].childNodes[c].innerHTML);\n        }\n        if (!this.wtSettings.getSetting('columnHeaders').length) {\n          this.wtSettings.update('columnHeaders', [function (column, TH) {\n            fastInnerText(TH, originalHeaders[column]);\n          }]);\n        }\n      }\n    }\n\n    /**\n     * Creates and returns the CellCoords object.\n     *\n     * @param {*} row The row index.\n     * @param {*} column The column index.\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"createCellCoords\",\n    value: function createCellCoords(row, column) {\n      return new CellCoords(row, column, this.wtSettings.getSetting('rtlMode'));\n    }\n\n    /**\n     * Creates and returns the CellRange object.\n     *\n     * @param {CellCoords} highlight The highlight coordinates.\n     * @param {CellCoords} from The from coordinates.\n     * @param {CellCoords} to The to coordinates.\n     * @returns {CellRange}\n     */\n  }, {\n    key: \"createCellRange\",\n    value: function createCellRange(highlight, from, to) {\n      return new CellRange(highlight, from, to, this.wtSettings.getSetting('rtlMode'));\n    }\n\n    /**\n     * Force rerender of Walkontable.\n     *\n     * @param {boolean} [fastDraw=false] When `true`, try to refresh only the positions of borders without rerendering\n     *                                   the data. It will only work if Table.draw() does not force\n     *                                   rendering anyway.\n     * @returns {Walkontable}\n     */\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      this.drawInterrupted = false;\n      if (!fastDraw && !this.wtTable.isVisible()) {\n        // draw interrupted because TABLE is not visible\n        this.drawInterrupted = true;\n      } else {\n        this.wtTable.draw(fastDraw);\n      }\n      return this;\n    }\n\n    /**\n     * Returns the TD at coords. If topmost is set to true, returns TD from the topmost overlay layer,\n     * if not set or set to false, returns TD from the master table.\n     *\n     * @param {CellCoords} coords The cell coordinates.\n     * @param {boolean} [topmost=false] If set to `true`, it returns the TD element from the topmost overlay. For example,\n     *                                  if the wanted cell is in the range of fixed rows, it will return a TD element\n     *                                  from the top overlay.\n     * @returns {HTMLElement}\n     */\n  }, {\n    key: \"getCell\",\n    value: function getCell(coords) {\n      var topmost = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (!topmost) {\n        return this.wtTable.getCell(coords);\n      }\n      var totalRows = this.wtSettings.getSetting('totalRows');\n      var fixedRowsTop = this.wtSettings.getSetting('fixedRowsTop');\n      var fixedRowsBottom = this.wtSettings.getSetting('fixedRowsBottom');\n      var fixedColumnsStart = this.wtSettings.getSetting('fixedColumnsStart');\n      if (coords.row < fixedRowsTop && coords.col < fixedColumnsStart) {\n        return this.wtOverlays.topInlineStartCornerOverlay.clone.wtTable.getCell(coords);\n      } else if (coords.row < fixedRowsTop) {\n        return this.wtOverlays.topOverlay.clone.wtTable.getCell(coords);\n      } else if (coords.col < fixedColumnsStart && coords.row >= totalRows - fixedRowsBottom) {\n        if (this.wtOverlays.bottomInlineStartCornerOverlay && this.wtOverlays.bottomInlineStartCornerOverlay.clone) {\n          return this.wtOverlays.bottomInlineStartCornerOverlay.clone.wtTable.getCell(coords);\n        }\n      } else if (coords.col < fixedColumnsStart) {\n        return this.wtOverlays.inlineStartOverlay.clone.wtTable.getCell(coords);\n      } else if (coords.row < totalRows && coords.row >= totalRows - fixedRowsBottom) {\n        if (this.wtOverlays.bottomOverlay && this.wtOverlays.bottomOverlay.clone) {\n          return this.wtOverlays.bottomOverlay.clone.wtTable.getCell(coords);\n        }\n      }\n      return this.wtTable.getCell(coords);\n    }\n\n    /**\n     * Scrolls the viewport to a cell (rerenders if needed).\n     *\n     * @param {CellCoords} coords The cell coordinates to scroll to.\n     * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.\n     * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right of the table.\n     * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom of the table.\n     * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left of the table.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"scrollViewport\",\n    value: function scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft) {\n      if (coords.col < 0 || coords.row < 0) {\n        return false;\n      }\n      return this.wtScroll.scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft);\n    }\n\n    /**\n     * Scrolls the viewport to a column (rerenders if needed).\n     *\n     * @param {number} column Visual column index.\n     * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right of the table.\n     * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left of the table.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"scrollViewportHorizontally\",\n    value: function scrollViewportHorizontally(column, snapToRight, snapToLeft) {\n      if (column < 0) {\n        return false;\n      }\n      return this.wtScroll.scrollViewportHorizontally(column, snapToRight, snapToLeft);\n    }\n\n    /**\n     * Scrolls the viewport to a row (rerenders if needed).\n     *\n     * @param {number} row Visual row index.\n     * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.\n     * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom of the table.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"scrollViewportVertically\",\n    value: function scrollViewportVertically(row, snapToTop, snapToBottom) {\n      if (row < 0) {\n        return false;\n      }\n      return this.wtScroll.scrollViewportVertically(row, snapToTop, snapToBottom);\n    }\n\n    /**\n     * @returns {Array}\n     */\n  }, {\n    key: \"getViewport\",\n    value: function getViewport() {\n      return [this.wtTable.getFirstVisibleRow(), this.wtTable.getFirstVisibleColumn(), this.wtTable.getLastVisibleRow(), this.wtTable.getLastVisibleColumn()];\n    }\n\n    /**\n     * Destroy instance.\n     */\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.wtOverlays.destroy();\n      this.wtEvent.destroy();\n    }\n\n    /**\n     * Create data access object for scroll.\n     *\n     * @protected\n     * @returns {ScrollDao}\n     */\n  }, {\n    key: \"createScrollDao\",\n    value: function createScrollDao() {\n      var wot = this;\n      return {\n        get drawn() {\n          return wot.drawn; // TODO refactoring: consider about injecting `isDrawn` function : ()=>return wot.drawn. (it'll enables remove dao layer)\n        },\n\n        get topOverlay() {\n          return wot.wtOverlays.topOverlay; // TODO refactoring: move outside dao, use IOC\n        },\n\n        get inlineStartOverlay() {\n          return wot.wtOverlays.inlineStartOverlay; // TODO refactoring: move outside dao, use IOC\n        },\n\n        get wtTable() {\n          return wot.wtTable; // TODO refactoring: move outside dao, use IOC\n        },\n\n        get wtViewport() {\n          return wot.wtViewport; // TODO refactoring: move outside dao, use IOC\n        },\n\n        get rootWindow() {\n          return wot.domBindings.rootWindow; // TODO refactoring: move outside dao\n        },\n\n        // TODO refactoring, consider about using injecting wtSettings into scroll (it'll enables remove dao layer)\n        get totalRows() {\n          return wot.wtSettings.getSetting('totalRows');\n        },\n        get totalColumns() {\n          return wot.wtSettings.getSetting('totalColumns');\n        },\n        get fixedRowsTop() {\n          return wot.wtSettings.getSetting('fixedRowsTop');\n        },\n        get fixedRowsBottom() {\n          return wot.wtSettings.getSetting('fixedRowsBottom');\n        },\n        get fixedColumnsStart() {\n          return wot.wtSettings.getSetting('fixedColumnsStart');\n        }\n      };\n    }\n    // TODO refactoring: it will be much better to not use DAO objects. They are needed for now to provide\n    // dynamically access to related objects\n    /**\n     * Create data access object for wtTable.\n     *\n     * @protected\n     * @returns {TableDao}\n     */\n  }, {\n    key: \"getTableDao\",\n    value: function getTableDao() {\n      var wot = this;\n      return {\n        get wot() {\n          return wot;\n        },\n        get parentTableOffset() {\n          return wot.cloneSource.wtTable.tableOffset; // TODO rethink: cloneSource exists only in Clone type.\n        },\n\n        get cloneSource() {\n          return wot.cloneSource; // TODO rethink: cloneSource exists only in Clone type.\n        },\n\n        get workspaceWidth() {\n          return wot.wtViewport.getWorkspaceWidth();\n        },\n        get wtViewport() {\n          return wot.wtViewport; // TODO refactoring: move outside dao, use IOC\n        },\n\n        get wtOverlays() {\n          return wot.wtOverlays; // TODO refactoring: move outside dao, use IOC\n        },\n\n        get selections() {\n          return wot.selections; // TODO refactoring: move outside dao, use IOC\n        },\n\n        get drawn() {\n          return wot.drawn;\n        },\n        set drawn(v) {\n          // TODO rethink: this breaks assumes of data access object, however it is required until invent better way to handle WOT state.\n          wot.drawn = v;\n        },\n        get wtTable() {\n          return wot.wtTable; // TODO refactoring: it provides itself\n        },\n\n        get startColumnRendered() {\n          return wot.wtViewport.columnsRenderCalculator.startColumn;\n        },\n        get startColumnVisible() {\n          return wot.wtViewport.columnsVisibleCalculator.startColumn;\n        },\n        get endColumnRendered() {\n          return wot.wtViewport.columnsRenderCalculator.endColumn;\n        },\n        get endColumnVisible() {\n          return wot.wtViewport.columnsVisibleCalculator.endColumn;\n        },\n        get countColumnsRendered() {\n          return wot.wtViewport.columnsRenderCalculator.count;\n        },\n        get countColumnsVisible() {\n          return wot.wtViewport.columnsVisibleCalculator.count;\n        },\n        get startRowRendered() {\n          return wot.wtViewport.rowsRenderCalculator.startRow;\n        },\n        get startRowVisible() {\n          return wot.wtViewport.rowsVisibleCalculator.startRow;\n        },\n        get endRowRendered() {\n          return wot.wtViewport.rowsRenderCalculator.endRow;\n        },\n        get endRowVisible() {\n          return wot.wtViewport.rowsVisibleCalculator.endRow;\n        },\n        get countRowsRendered() {\n          return wot.wtViewport.rowsRenderCalculator.count;\n        },\n        get countRowsVisible() {\n          return wot.wtViewport.rowsVisibleCalculator.count;\n        }\n      };\n    }\n  }]);\n  return CoreAbstract;\n}();\nexport { CoreAbstract as default };"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}