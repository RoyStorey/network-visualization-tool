{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nimport { getScrollbarWidth, getStyle, offset, outerHeight, outerWidth } from \"../../../helpers/dom/element.mjs\";\nimport { objectEach } from \"../../../helpers/object.mjs\";\nimport { RENDER_TYPE, FULLY_VISIBLE_TYPE, ViewportColumnsCalculator, ViewportRowsCalculator } from \"./calculator/index.mjs\";\n/**\n * @class Viewport\n */\nvar Viewport = /*#__PURE__*/function () {\n  /**\n   * @param {ViewportDao} dataAccessObject The Walkontable instance.\n   * @param {DomBindings} domBindings Bindings into DOM.\n   * @param {Settings} wtSettings The Walkontable settings.\n   * @param {EventManager} eventManager The instance event manager.\n   * @param {Table} wtTable The table.\n   */\n  function Viewport(dataAccessObject, domBindings, wtSettings, eventManager, wtTable) {\n    var _this = this;\n    _classCallCheck(this, Viewport);\n    this.dataAccessObject = dataAccessObject;\n    // legacy support\n    this.wot = dataAccessObject.wot;\n    this.instance = this.wot;\n    this.domBindings = domBindings;\n    this.wtSettings = wtSettings;\n    this.wtTable = wtTable;\n    this.oversizedRows = [];\n    this.oversizedColumnHeaders = [];\n    this.hasOversizedColumnHeadersMarked = {};\n    this.clientHeight = 0;\n    this.containerWidth = NaN;\n    this.rowHeaderWidth = NaN;\n    this.rowsVisibleCalculator = null;\n    this.columnsVisibleCalculator = null;\n    this.eventManager = eventManager;\n    this.eventManager.addEventListener(this.domBindings.rootWindow, 'resize', function () {\n      _this.clientHeight = _this.getWorkspaceHeight();\n    });\n  }\n\n  /**\n   * @returns {number}\n   */\n  _createClass(Viewport, [{\n    key: \"getWorkspaceHeight\",\n    value: function getWorkspaceHeight() {\n      var currentDocument = this.domBindings.rootDocument;\n      var trimmingContainer = this.dataAccessObject.topOverlayTrimmingContainer;\n      var height = 0;\n      if (trimmingContainer === this.domBindings.rootWindow) {\n        height = currentDocument.documentElement.clientHeight;\n      } else {\n        var elemHeight = outerHeight(trimmingContainer);\n\n        // returns height without DIV scrollbar\n        height = elemHeight > 0 && trimmingContainer.clientHeight > 0 ? trimmingContainer.clientHeight : Infinity;\n      }\n      return height;\n    }\n  }, {\n    key: \"getWorkspaceWidth\",\n    value: function getWorkspaceWidth() {\n      var wtSettings = this.wtSettings;\n      var _this$domBindings = this.domBindings,\n        rootDocument = _this$domBindings.rootDocument,\n        rootWindow = _this$domBindings.rootWindow;\n      var trimmingContainer = this.dataAccessObject.inlineStartOverlayTrimmingContainer;\n      var docOffsetWidth = rootDocument.documentElement.offsetWidth;\n      var totalColumns = wtSettings.getSetting('totalColumns');\n      var preventOverflow = wtSettings.getSetting('preventOverflow');\n      var isRtl = wtSettings.getSetting('rtlMode');\n      var tableRect = this.wtTable.TABLE.getBoundingClientRect();\n      var inlineStart = isRtl ? tableRect.right - docOffsetWidth : tableRect.left;\n      var tableOffset = docOffsetWidth - inlineStart;\n      var width;\n      var overflow;\n      if (preventOverflow) {\n        return outerWidth(this.wtTable.wtRootElement);\n      }\n      if (wtSettings.getSetting('freezeOverlays')) {\n        width = Math.min(tableOffset, docOffsetWidth);\n      } else {\n        width = Math.min(this.getContainerFillWidth(), tableOffset, docOffsetWidth);\n      }\n      if (trimmingContainer === rootWindow && totalColumns > 0 && this.sumColumnWidths(0, totalColumns - 1) > width) {\n        // in case sum of column widths is higher than available stylesheet width, let's assume using the whole window\n        // otherwise continue below, which will allow stretching\n        // this is used in `scroll_window.html`\n        // TODO test me\n        return rootDocument.documentElement.clientWidth;\n      }\n      if (trimmingContainer !== rootWindow) {\n        overflow = getStyle(this.dataAccessObject.inlineStartOverlayTrimmingContainer, 'overflow', rootWindow);\n        if (overflow === 'scroll' || overflow === 'hidden' || overflow === 'auto') {\n          // this is used in `scroll.html`\n          // TODO test me\n          return Math.max(width, trimmingContainer.clientWidth);\n        }\n      }\n      var stretchSetting = wtSettings.getSetting('stretchH');\n      if (stretchSetting === 'none' || !stretchSetting) {\n        // if no stretching is used, return the maximum used workspace width\n        return Math.max(width, outerWidth(this.wtTable.TABLE));\n      }\n\n      // if stretching is used, return the actual container width, so the columns can fit inside it\n      return width;\n    }\n\n    /**\n     * Checks if viewport has vertical scroll.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"hasVerticalScroll\",\n    value: function hasVerticalScroll() {\n      return this.wtTable.hider.offsetHeight > this.getWorkspaceHeight();\n    }\n\n    /**\n     * Checks if viewport has horizontal scroll.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"hasHorizontalScroll\",\n    value: function hasHorizontalScroll() {\n      return this.wtTable.hider.offsetWidth > this.getWorkspaceWidth();\n    }\n\n    /**\n     * @param {number} from The visual column index from the width sum is start calculated.\n     * @param {number} length The length of the column to traverse.\n     * @returns {number}\n     */\n  }, {\n    key: \"sumColumnWidths\",\n    value: function sumColumnWidths(from, length) {\n      var sum = 0;\n      var column = from;\n      while (column < length) {\n        sum += this.wtTable.getColumnWidth(column);\n        column += 1;\n      }\n      return sum;\n    }\n\n    /**\n     * @returns {number}\n     */\n  }, {\n    key: \"getContainerFillWidth\",\n    value: function getContainerFillWidth() {\n      if (this.containerWidth) {\n        return this.containerWidth;\n      }\n      var mainContainer = this.wtTable.holder;\n      var dummyElement = this.domBindings.rootDocument.createElement('div');\n      dummyElement.style.width = '100%';\n      dummyElement.style.height = '1px';\n      mainContainer.appendChild(dummyElement);\n      var fillWidth = dummyElement.offsetWidth;\n      this.containerWidth = fillWidth;\n      mainContainer.removeChild(dummyElement);\n      return fillWidth;\n    }\n\n    /**\n     * @returns {number}\n     */\n  }, {\n    key: \"getWorkspaceOffset\",\n    value: function getWorkspaceOffset() {\n      return offset(this.wtTable.TABLE);\n    }\n\n    /**\n     * @returns {number}\n     */\n  }, {\n    key: \"getColumnHeaderHeight\",\n    value: function getColumnHeaderHeight() {\n      var columnHeaders = this.wtSettings.getSetting('columnHeaders');\n      if (!columnHeaders.length) {\n        this.columnHeaderHeight = 0;\n      } else if (isNaN(this.columnHeaderHeight)) {\n        this.columnHeaderHeight = outerHeight(this.wtTable.THEAD);\n      }\n      return this.columnHeaderHeight;\n    }\n\n    /**\n     * @returns {number}\n     */\n  }, {\n    key: \"getViewportHeight\",\n    value: function getViewportHeight() {\n      var containerHeight = this.getWorkspaceHeight();\n      if (containerHeight === Infinity) {\n        return containerHeight;\n      }\n      var columnHeaderHeight = this.getColumnHeaderHeight();\n      if (columnHeaderHeight > 0) {\n        containerHeight -= columnHeaderHeight;\n      }\n      return containerHeight;\n    }\n\n    /**\n     * @returns {number}\n     */\n  }, {\n    key: \"getRowHeaderWidth\",\n    value: function getRowHeaderWidth() {\n      var rowHeadersWidthSetting = this.wtSettings.getSetting('rowHeaderWidth');\n      var rowHeaders = this.wtSettings.getSetting('rowHeaders');\n      if (rowHeadersWidthSetting) {\n        this.rowHeaderWidth = 0;\n        for (var i = 0, len = rowHeaders.length; i < len; i++) {\n          this.rowHeaderWidth += rowHeadersWidthSetting[i] || rowHeadersWidthSetting;\n        }\n      }\n      if (isNaN(this.rowHeaderWidth)) {\n        if (rowHeaders.length) {\n          var TH = this.wtTable.TABLE.querySelector('TH');\n          this.rowHeaderWidth = 0;\n          for (var _i = 0, _len = rowHeaders.length; _i < _len; _i++) {\n            if (TH) {\n              this.rowHeaderWidth += outerWidth(TH);\n              TH = TH.nextSibling;\n            } else {\n              // yes this is a cheat but it worked like that before, just taking assumption from CSS instead of measuring.\n              // TODO: proper fix\n              this.rowHeaderWidth += 50;\n            }\n          }\n        } else {\n          this.rowHeaderWidth = 0;\n        }\n      }\n      this.rowHeaderWidth = this.wtSettings.getSetting('onModifyRowHeaderWidth', this.rowHeaderWidth) || this.rowHeaderWidth;\n      return this.rowHeaderWidth;\n    }\n\n    /**\n     * @returns {number}\n     */\n  }, {\n    key: \"getViewportWidth\",\n    value: function getViewportWidth() {\n      var containerWidth = this.getWorkspaceWidth();\n      if (containerWidth === Infinity) {\n        return containerWidth;\n      }\n      var rowHeaderWidth = this.getRowHeaderWidth();\n      if (rowHeaderWidth > 0) {\n        return containerWidth - rowHeaderWidth;\n      }\n      return containerWidth;\n    }\n\n    /**\n     * Creates:\n     * - rowsRenderCalculator (before draw, to qualify rows for rendering)\n     * - rowsVisibleCalculator (after draw, to measure which rows are actually visible).\n     *\n     * @param {number} calculationType The render type ID, which determines for what type of\n     *                                 calculation calculator is created.\n     * @returns {ViewportRowsCalculator}\n     */\n  }, {\n    key: \"createRowsCalculator\",\n    value: function createRowsCalculator() {\n      var calculationType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : RENDER_TYPE;\n      var wtSettings = this.wtSettings,\n        wtTable = this.wtTable;\n      var height;\n      var scrollbarHeight;\n      var fixedRowsHeight;\n      this.rowHeaderWidth = NaN;\n      if (wtSettings.getSetting('renderAllRows') && calculationType === RENDER_TYPE) {\n        height = Infinity;\n      } else {\n        height = this.getViewportHeight();\n      }\n      var pos = this.dataAccessObject.topScrollPosition - this.dataAccessObject.topParentOffset;\n      if (pos < 0) {\n        pos = 0;\n      }\n      var fixedRowsTop = wtSettings.getSetting('fixedRowsTop');\n      var fixedRowsBottom = wtSettings.getSetting('fixedRowsBottom');\n      var totalRows = wtSettings.getSetting('totalRows');\n      if (fixedRowsTop) {\n        fixedRowsHeight = this.dataAccessObject.topOverlay.sumCellSizes(0, fixedRowsTop);\n        pos += fixedRowsHeight;\n        height -= fixedRowsHeight;\n      }\n      if (fixedRowsBottom && this.dataAccessObject.bottomOverlay.clone) {\n        fixedRowsHeight = this.dataAccessObject.bottomOverlay.sumCellSizes(totalRows - fixedRowsBottom, totalRows);\n        height -= fixedRowsHeight;\n      }\n      if (wtTable.holder.clientHeight === wtTable.holder.offsetHeight) {\n        scrollbarHeight = 0;\n      } else {\n        scrollbarHeight = getScrollbarWidth(this.domBindings.rootDocument);\n      }\n      return new ViewportRowsCalculator({\n        viewportSize: height,\n        scrollOffset: pos,\n        totalItems: wtSettings.getSetting('totalRows'),\n        itemSizeFn: function itemSizeFn(sourceRow) {\n          return wtTable.getRowHeight(sourceRow);\n        },\n        overrideFn: wtSettings.getSettingPure('viewportRowCalculatorOverride'),\n        calculationType: calculationType,\n        scrollbarHeight: scrollbarHeight\n      });\n    }\n\n    /**\n     * Creates:\n     * - columnsRenderCalculator (before draw, to qualify columns for rendering)\n     * - columnsVisibleCalculator (after draw, to measure which columns are actually visible).\n     *\n     * @param {number} calculationType The render type ID, which determines for what type of\n     *                                 calculation calculator is created.\n     * @returns {ViewportColumnsCalculator}\n     */\n  }, {\n    key: \"createColumnsCalculator\",\n    value: function createColumnsCalculator() {\n      var calculationType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : RENDER_TYPE;\n      var wtSettings = this.wtSettings,\n        wtTable = this.wtTable;\n      var width = this.getViewportWidth();\n      var pos = Math.abs(this.dataAccessObject.inlineStartScrollPosition) - this.dataAccessObject.inlineStartParentOffset;\n      this.columnHeaderHeight = NaN;\n      if (pos < 0) {\n        pos = 0;\n      }\n      var fixedColumnsStart = wtSettings.getSetting('fixedColumnsStart');\n      if (fixedColumnsStart) {\n        var fixedColumnsWidth = this.dataAccessObject.inlineStartOverlay.sumCellSizes(0, fixedColumnsStart);\n        pos += fixedColumnsWidth;\n        width -= fixedColumnsWidth;\n      }\n      if (wtTable.holder.clientWidth !== wtTable.holder.offsetWidth) {\n        width -= getScrollbarWidth(this.domBindings.rootDocument);\n      }\n      return new ViewportColumnsCalculator({\n        viewportSize: width,\n        scrollOffset: Math.abs(pos),\n        totalItems: wtSettings.getSetting('totalColumns'),\n        itemSizeFn: function itemSizeFn(sourceCol) {\n          return wtTable.getColumnWidth(sourceCol);\n        },\n        overrideFn: wtSettings.getSettingPure('viewportColumnCalculatorOverride'),\n        calculationType: calculationType,\n        stretchMode: wtSettings.getSetting('stretchH'),\n        stretchingItemWidthFn: function stretchingItemWidthFn(stretchedWidth, column) {\n          return wtSettings.getSetting('onBeforeStretchingColumnWidth', stretchedWidth, column);\n        }\n      });\n    }\n\n    /**\n     * Creates rowsRenderCalculator and columnsRenderCalculator (before draw, to determine what rows and\n     * cols should be rendered).\n     *\n     * @param {boolean} fastDraw If `true`, will try to avoid full redraw and only update the border positions.\n     *                           If `false` or `undefined`, will perform a full redraw.\n     * @returns {boolean} The fastDraw value, possibly modified.\n     */\n  }, {\n    key: \"createRenderCalculators\",\n    value: function createRenderCalculators() {\n      var fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var runFastDraw = fastDraw;\n      if (runFastDraw) {\n        var proposedRowsVisibleCalculator = this.createRowsCalculator(FULLY_VISIBLE_TYPE);\n        var proposedColumnsVisibleCalculator = this.createColumnsCalculator(FULLY_VISIBLE_TYPE);\n        if (!(this.areAllProposedVisibleRowsAlreadyRendered(proposedRowsVisibleCalculator) && this.areAllProposedVisibleColumnsAlreadyRendered(proposedColumnsVisibleCalculator))) {\n          runFastDraw = false;\n        }\n      }\n      if (!runFastDraw) {\n        this.rowsRenderCalculator = this.createRowsCalculator(RENDER_TYPE);\n        this.columnsRenderCalculator = this.createColumnsCalculator(RENDER_TYPE);\n      }\n      // delete temporarily to make sure that renderers always use rowsRenderCalculator, not rowsVisibleCalculator\n      this.rowsVisibleCalculator = null;\n      this.columnsVisibleCalculator = null;\n      return runFastDraw;\n    }\n\n    /**\n     * Creates rowsVisibleCalculator and columnsVisibleCalculator (after draw, to determine what are\n     * the actually fully visible rows and columns).\n     */\n  }, {\n    key: \"createVisibleCalculators\",\n    value: function createVisibleCalculators() {\n      this.rowsVisibleCalculator = this.createRowsCalculator(FULLY_VISIBLE_TYPE);\n      this.columnsVisibleCalculator = this.createColumnsCalculator(FULLY_VISIBLE_TYPE);\n    }\n\n    /**\n     * Returns information whether proposedRowsVisibleCalculator viewport\n     * is contained inside rows rendered in previous draw (cached in rowsRenderCalculator).\n     *\n     * @param {ViewportRowsCalculator} proposedRowsVisibleCalculator The instance of the viewport calculator to compare with.\n     * @returns {boolean} Returns `true` if all proposed visible rows are already rendered (meaning: redraw is not needed).\n     *                    Returns `false` if at least one proposed visible row is not already rendered (meaning: redraw is needed).\n     */\n  }, {\n    key: \"areAllProposedVisibleRowsAlreadyRendered\",\n    value: function areAllProposedVisibleRowsAlreadyRendered(proposedRowsVisibleCalculator) {\n      if (!this.rowsVisibleCalculator) {\n        return false;\n      }\n      var startRow = proposedRowsVisibleCalculator.startRow,\n        endRow = proposedRowsVisibleCalculator.endRow;\n\n      // if there are no fully visible rows at all, return false\n      if (startRow === null && endRow === null) {\n        return false;\n      }\n      var _this$rowsRenderCalcu = this.rowsRenderCalculator,\n        renderedStartRow = _this$rowsRenderCalcu.startRow,\n        renderedEndRow = _this$rowsRenderCalcu.endRow;\n      if (startRow < renderedStartRow || startRow === renderedStartRow && startRow > 0) {\n        return false;\n      } else if (endRow > renderedEndRow || endRow === renderedEndRow && endRow < this.wtSettings.getSetting('totalRows') - 1) {\n        return false;\n      }\n      return true;\n    }\n\n    /**\n     * Returns information whether proposedColumnsVisibleCalculator viewport\n     * is contained inside column rendered in previous draw (cached in columnsRenderCalculator).\n     *\n     * @param {ViewportRowsCalculator} proposedColumnsVisibleCalculator The instance of the viewport calculator to compare with.\n     * @returns {boolean} Returns `true` if all proposed visible columns are already rendered (meaning: redraw is not needed).\n     *                    Returns `false` if at least one proposed visible column is not already rendered (meaning: redraw is needed).\n     */\n  }, {\n    key: \"areAllProposedVisibleColumnsAlreadyRendered\",\n    value: function areAllProposedVisibleColumnsAlreadyRendered(proposedColumnsVisibleCalculator) {\n      if (!this.columnsVisibleCalculator) {\n        return false;\n      }\n      var startColumn = proposedColumnsVisibleCalculator.startColumn,\n        endColumn = proposedColumnsVisibleCalculator.endColumn;\n\n      // if there are no fully visible columns at all, return false\n      if (startColumn === null && endColumn === null) {\n        return false;\n      }\n      var _this$columnsRenderCa = this.columnsRenderCalculator,\n        renderedStartColumn = _this$columnsRenderCa.startColumn,\n        renderedEndColumn = _this$columnsRenderCa.endColumn;\n      if (startColumn < renderedStartColumn || startColumn === renderedStartColumn && startColumn > 0) {\n        return false;\n      } else if (endColumn > renderedEndColumn || endColumn === renderedEndColumn && endColumn < this.wtSettings.getSetting('totalColumns') - 1) {\n        return false;\n      }\n      return true;\n    }\n\n    /**\n     * Resets values in keys of the hasOversizedColumnHeadersMarked object after updateSettings.\n     */\n  }, {\n    key: \"resetHasOversizedColumnHeadersMarked\",\n    value: function resetHasOversizedColumnHeadersMarked() {\n      objectEach(this.hasOversizedColumnHeadersMarked, function (value, key, object) {\n        object[key] = void 0;\n      });\n    }\n  }]);\n  return Viewport;\n}();\nexport default Viewport;","map":{"version":3,"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","_toPropertyKey","key","_createClass","protoProps","staticProps","arg","_toPrimitive","String","input","hint","prim","toPrimitive","undefined","res","call","Number","getScrollbarWidth","getStyle","offset","outerHeight","outerWidth","objectEach","RENDER_TYPE","FULLY_VISIBLE_TYPE","ViewportColumnsCalculator","ViewportRowsCalculator","Viewport","dataAccessObject","domBindings","wtSettings","eventManager","wtTable","_this","wot","oversizedRows","oversizedColumnHeaders","hasOversizedColumnHeadersMarked","clientHeight","containerWidth","NaN","rowHeaderWidth","rowsVisibleCalculator","columnsVisibleCalculator","addEventListener","rootWindow","getWorkspaceHeight","value","currentDocument","rootDocument","trimmingContainer","topOverlayTrimmingContainer","height","documentElement","elemHeight","Infinity","getWorkspaceWidth","_this$domBindings","inlineStartOverlayTrimmingContainer","docOffsetWidth","offsetWidth","totalColumns","getSetting","preventOverflow","isRtl","tableRect","TABLE","getBoundingClientRect","inlineStart","right","left","tableOffset","width","overflow","wtRootElement","Math","min","getContainerFillWidth","sumColumnWidths","clientWidth","max","stretchSetting","hasVerticalScroll","hider","offsetHeight","hasHorizontalScroll","from","sum","column","getColumnWidth","mainContainer","holder","dummyElement","createElement","style","appendChild","fillWidth","removeChild","getWorkspaceOffset","getColumnHeaderHeight","columnHeaders","columnHeaderHeight","isNaN","THEAD","getViewportHeight","containerHeight","getRowHeaderWidth","rowHeadersWidthSetting","rowHeaders","len","TH","querySelector","_i","_len","nextSibling","getViewportWidth","createRowsCalculator","calculationType","arguments","scrollbarHeight","fixedRowsHeight","pos","topScrollPosition","topParentOffset","fixedRowsTop","fixedRowsBottom","totalRows","topOverlay","sumCellSizes","bottomOverlay","clone","viewportSize","scrollOffset","totalItems","itemSizeFn","sourceRow","getRowHeight","overrideFn","getSettingPure","createColumnsCalculator","abs","inlineStartScrollPosition","inlineStartParentOffset","fixedColumnsStart","fixedColumnsWidth","inlineStartOverlay","sourceCol","stretchMode","stretchingItemWidthFn","stretchedWidth","createRenderCalculators","fastDraw","runFastDraw","proposedRowsVisibleCalculator","proposedColumnsVisibleCalculator","areAllProposedVisibleRowsAlreadyRendered","areAllProposedVisibleColumnsAlreadyRendered","rowsRenderCalculator","columnsRenderCalculator","createVisibleCalculators","startRow","endRow","_this$rowsRenderCalcu","renderedStartRow","renderedEndRow","startColumn","endColumn","_this$columnsRenderCa","renderedStartColumn","renderedEndColumn","resetHasOversizedColumnHeadersMarked","object"],"sources":["/home/rstorey/wwwdev/Blucktool/node_modules/handsontable/3rdparty/walkontable/src/viewport.mjs"],"sourcesContent":["import \"core-js/modules/es.symbol.to-primitive.js\";\nimport \"core-js/modules/es.date.to-primitive.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { getScrollbarWidth, getStyle, offset, outerHeight, outerWidth } from \"../../../helpers/dom/element.mjs\";\nimport { objectEach } from \"../../../helpers/object.mjs\";\nimport { RENDER_TYPE, FULLY_VISIBLE_TYPE, ViewportColumnsCalculator, ViewportRowsCalculator } from \"./calculator/index.mjs\";\n/**\n * @class Viewport\n */\nvar Viewport = /*#__PURE__*/function () {\n  /**\n   * @param {ViewportDao} dataAccessObject The Walkontable instance.\n   * @param {DomBindings} domBindings Bindings into DOM.\n   * @param {Settings} wtSettings The Walkontable settings.\n   * @param {EventManager} eventManager The instance event manager.\n   * @param {Table} wtTable The table.\n   */\n  function Viewport(dataAccessObject, domBindings, wtSettings, eventManager, wtTable) {\n    var _this = this;\n    _classCallCheck(this, Viewport);\n    this.dataAccessObject = dataAccessObject;\n    // legacy support\n    this.wot = dataAccessObject.wot;\n    this.instance = this.wot;\n    this.domBindings = domBindings;\n    this.wtSettings = wtSettings;\n    this.wtTable = wtTable;\n    this.oversizedRows = [];\n    this.oversizedColumnHeaders = [];\n    this.hasOversizedColumnHeadersMarked = {};\n    this.clientHeight = 0;\n    this.containerWidth = NaN;\n    this.rowHeaderWidth = NaN;\n    this.rowsVisibleCalculator = null;\n    this.columnsVisibleCalculator = null;\n    this.eventManager = eventManager;\n    this.eventManager.addEventListener(this.domBindings.rootWindow, 'resize', function () {\n      _this.clientHeight = _this.getWorkspaceHeight();\n    });\n  }\n\n  /**\n   * @returns {number}\n   */\n  _createClass(Viewport, [{\n    key: \"getWorkspaceHeight\",\n    value: function getWorkspaceHeight() {\n      var currentDocument = this.domBindings.rootDocument;\n      var trimmingContainer = this.dataAccessObject.topOverlayTrimmingContainer;\n      var height = 0;\n      if (trimmingContainer === this.domBindings.rootWindow) {\n        height = currentDocument.documentElement.clientHeight;\n      } else {\n        var elemHeight = outerHeight(trimmingContainer);\n\n        // returns height without DIV scrollbar\n        height = elemHeight > 0 && trimmingContainer.clientHeight > 0 ? trimmingContainer.clientHeight : Infinity;\n      }\n      return height;\n    }\n  }, {\n    key: \"getWorkspaceWidth\",\n    value: function getWorkspaceWidth() {\n      var wtSettings = this.wtSettings;\n      var _this$domBindings = this.domBindings,\n        rootDocument = _this$domBindings.rootDocument,\n        rootWindow = _this$domBindings.rootWindow;\n      var trimmingContainer = this.dataAccessObject.inlineStartOverlayTrimmingContainer;\n      var docOffsetWidth = rootDocument.documentElement.offsetWidth;\n      var totalColumns = wtSettings.getSetting('totalColumns');\n      var preventOverflow = wtSettings.getSetting('preventOverflow');\n      var isRtl = wtSettings.getSetting('rtlMode');\n      var tableRect = this.wtTable.TABLE.getBoundingClientRect();\n      var inlineStart = isRtl ? tableRect.right - docOffsetWidth : tableRect.left;\n      var tableOffset = docOffsetWidth - inlineStart;\n      var width;\n      var overflow;\n      if (preventOverflow) {\n        return outerWidth(this.wtTable.wtRootElement);\n      }\n      if (wtSettings.getSetting('freezeOverlays')) {\n        width = Math.min(tableOffset, docOffsetWidth);\n      } else {\n        width = Math.min(this.getContainerFillWidth(), tableOffset, docOffsetWidth);\n      }\n      if (trimmingContainer === rootWindow && totalColumns > 0 && this.sumColumnWidths(0, totalColumns - 1) > width) {\n        // in case sum of column widths is higher than available stylesheet width, let's assume using the whole window\n        // otherwise continue below, which will allow stretching\n        // this is used in `scroll_window.html`\n        // TODO test me\n        return rootDocument.documentElement.clientWidth;\n      }\n      if (trimmingContainer !== rootWindow) {\n        overflow = getStyle(this.dataAccessObject.inlineStartOverlayTrimmingContainer, 'overflow', rootWindow);\n        if (overflow === 'scroll' || overflow === 'hidden' || overflow === 'auto') {\n          // this is used in `scroll.html`\n          // TODO test me\n          return Math.max(width, trimmingContainer.clientWidth);\n        }\n      }\n      var stretchSetting = wtSettings.getSetting('stretchH');\n      if (stretchSetting === 'none' || !stretchSetting) {\n        // if no stretching is used, return the maximum used workspace width\n        return Math.max(width, outerWidth(this.wtTable.TABLE));\n      }\n\n      // if stretching is used, return the actual container width, so the columns can fit inside it\n      return width;\n    }\n\n    /**\n     * Checks if viewport has vertical scroll.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"hasVerticalScroll\",\n    value: function hasVerticalScroll() {\n      return this.wtTable.hider.offsetHeight > this.getWorkspaceHeight();\n    }\n\n    /**\n     * Checks if viewport has horizontal scroll.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"hasHorizontalScroll\",\n    value: function hasHorizontalScroll() {\n      return this.wtTable.hider.offsetWidth > this.getWorkspaceWidth();\n    }\n\n    /**\n     * @param {number} from The visual column index from the width sum is start calculated.\n     * @param {number} length The length of the column to traverse.\n     * @returns {number}\n     */\n  }, {\n    key: \"sumColumnWidths\",\n    value: function sumColumnWidths(from, length) {\n      var sum = 0;\n      var column = from;\n      while (column < length) {\n        sum += this.wtTable.getColumnWidth(column);\n        column += 1;\n      }\n      return sum;\n    }\n\n    /**\n     * @returns {number}\n     */\n  }, {\n    key: \"getContainerFillWidth\",\n    value: function getContainerFillWidth() {\n      if (this.containerWidth) {\n        return this.containerWidth;\n      }\n      var mainContainer = this.wtTable.holder;\n      var dummyElement = this.domBindings.rootDocument.createElement('div');\n      dummyElement.style.width = '100%';\n      dummyElement.style.height = '1px';\n      mainContainer.appendChild(dummyElement);\n      var fillWidth = dummyElement.offsetWidth;\n      this.containerWidth = fillWidth;\n      mainContainer.removeChild(dummyElement);\n      return fillWidth;\n    }\n\n    /**\n     * @returns {number}\n     */\n  }, {\n    key: \"getWorkspaceOffset\",\n    value: function getWorkspaceOffset() {\n      return offset(this.wtTable.TABLE);\n    }\n\n    /**\n     * @returns {number}\n     */\n  }, {\n    key: \"getColumnHeaderHeight\",\n    value: function getColumnHeaderHeight() {\n      var columnHeaders = this.wtSettings.getSetting('columnHeaders');\n      if (!columnHeaders.length) {\n        this.columnHeaderHeight = 0;\n      } else if (isNaN(this.columnHeaderHeight)) {\n        this.columnHeaderHeight = outerHeight(this.wtTable.THEAD);\n      }\n      return this.columnHeaderHeight;\n    }\n\n    /**\n     * @returns {number}\n     */\n  }, {\n    key: \"getViewportHeight\",\n    value: function getViewportHeight() {\n      var containerHeight = this.getWorkspaceHeight();\n      if (containerHeight === Infinity) {\n        return containerHeight;\n      }\n      var columnHeaderHeight = this.getColumnHeaderHeight();\n      if (columnHeaderHeight > 0) {\n        containerHeight -= columnHeaderHeight;\n      }\n      return containerHeight;\n    }\n\n    /**\n     * @returns {number}\n     */\n  }, {\n    key: \"getRowHeaderWidth\",\n    value: function getRowHeaderWidth() {\n      var rowHeadersWidthSetting = this.wtSettings.getSetting('rowHeaderWidth');\n      var rowHeaders = this.wtSettings.getSetting('rowHeaders');\n      if (rowHeadersWidthSetting) {\n        this.rowHeaderWidth = 0;\n        for (var i = 0, len = rowHeaders.length; i < len; i++) {\n          this.rowHeaderWidth += rowHeadersWidthSetting[i] || rowHeadersWidthSetting;\n        }\n      }\n      if (isNaN(this.rowHeaderWidth)) {\n        if (rowHeaders.length) {\n          var TH = this.wtTable.TABLE.querySelector('TH');\n          this.rowHeaderWidth = 0;\n          for (var _i = 0, _len = rowHeaders.length; _i < _len; _i++) {\n            if (TH) {\n              this.rowHeaderWidth += outerWidth(TH);\n              TH = TH.nextSibling;\n            } else {\n              // yes this is a cheat but it worked like that before, just taking assumption from CSS instead of measuring.\n              // TODO: proper fix\n              this.rowHeaderWidth += 50;\n            }\n          }\n        } else {\n          this.rowHeaderWidth = 0;\n        }\n      }\n      this.rowHeaderWidth = this.wtSettings.getSetting('onModifyRowHeaderWidth', this.rowHeaderWidth) || this.rowHeaderWidth;\n      return this.rowHeaderWidth;\n    }\n\n    /**\n     * @returns {number}\n     */\n  }, {\n    key: \"getViewportWidth\",\n    value: function getViewportWidth() {\n      var containerWidth = this.getWorkspaceWidth();\n      if (containerWidth === Infinity) {\n        return containerWidth;\n      }\n      var rowHeaderWidth = this.getRowHeaderWidth();\n      if (rowHeaderWidth > 0) {\n        return containerWidth - rowHeaderWidth;\n      }\n      return containerWidth;\n    }\n\n    /**\n     * Creates:\n     * - rowsRenderCalculator (before draw, to qualify rows for rendering)\n     * - rowsVisibleCalculator (after draw, to measure which rows are actually visible).\n     *\n     * @param {number} calculationType The render type ID, which determines for what type of\n     *                                 calculation calculator is created.\n     * @returns {ViewportRowsCalculator}\n     */\n  }, {\n    key: \"createRowsCalculator\",\n    value: function createRowsCalculator() {\n      var calculationType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : RENDER_TYPE;\n      var wtSettings = this.wtSettings,\n        wtTable = this.wtTable;\n      var height;\n      var scrollbarHeight;\n      var fixedRowsHeight;\n      this.rowHeaderWidth = NaN;\n      if (wtSettings.getSetting('renderAllRows') && calculationType === RENDER_TYPE) {\n        height = Infinity;\n      } else {\n        height = this.getViewportHeight();\n      }\n      var pos = this.dataAccessObject.topScrollPosition - this.dataAccessObject.topParentOffset;\n      if (pos < 0) {\n        pos = 0;\n      }\n      var fixedRowsTop = wtSettings.getSetting('fixedRowsTop');\n      var fixedRowsBottom = wtSettings.getSetting('fixedRowsBottom');\n      var totalRows = wtSettings.getSetting('totalRows');\n      if (fixedRowsTop) {\n        fixedRowsHeight = this.dataAccessObject.topOverlay.sumCellSizes(0, fixedRowsTop);\n        pos += fixedRowsHeight;\n        height -= fixedRowsHeight;\n      }\n      if (fixedRowsBottom && this.dataAccessObject.bottomOverlay.clone) {\n        fixedRowsHeight = this.dataAccessObject.bottomOverlay.sumCellSizes(totalRows - fixedRowsBottom, totalRows);\n        height -= fixedRowsHeight;\n      }\n      if (wtTable.holder.clientHeight === wtTable.holder.offsetHeight) {\n        scrollbarHeight = 0;\n      } else {\n        scrollbarHeight = getScrollbarWidth(this.domBindings.rootDocument);\n      }\n      return new ViewportRowsCalculator({\n        viewportSize: height,\n        scrollOffset: pos,\n        totalItems: wtSettings.getSetting('totalRows'),\n        itemSizeFn: function itemSizeFn(sourceRow) {\n          return wtTable.getRowHeight(sourceRow);\n        },\n        overrideFn: wtSettings.getSettingPure('viewportRowCalculatorOverride'),\n        calculationType: calculationType,\n        scrollbarHeight: scrollbarHeight\n      });\n    }\n\n    /**\n     * Creates:\n     * - columnsRenderCalculator (before draw, to qualify columns for rendering)\n     * - columnsVisibleCalculator (after draw, to measure which columns are actually visible).\n     *\n     * @param {number} calculationType The render type ID, which determines for what type of\n     *                                 calculation calculator is created.\n     * @returns {ViewportColumnsCalculator}\n     */\n  }, {\n    key: \"createColumnsCalculator\",\n    value: function createColumnsCalculator() {\n      var calculationType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : RENDER_TYPE;\n      var wtSettings = this.wtSettings,\n        wtTable = this.wtTable;\n      var width = this.getViewportWidth();\n      var pos = Math.abs(this.dataAccessObject.inlineStartScrollPosition) - this.dataAccessObject.inlineStartParentOffset;\n      this.columnHeaderHeight = NaN;\n      if (pos < 0) {\n        pos = 0;\n      }\n      var fixedColumnsStart = wtSettings.getSetting('fixedColumnsStart');\n      if (fixedColumnsStart) {\n        var fixedColumnsWidth = this.dataAccessObject.inlineStartOverlay.sumCellSizes(0, fixedColumnsStart);\n        pos += fixedColumnsWidth;\n        width -= fixedColumnsWidth;\n      }\n      if (wtTable.holder.clientWidth !== wtTable.holder.offsetWidth) {\n        width -= getScrollbarWidth(this.domBindings.rootDocument);\n      }\n      return new ViewportColumnsCalculator({\n        viewportSize: width,\n        scrollOffset: Math.abs(pos),\n        totalItems: wtSettings.getSetting('totalColumns'),\n        itemSizeFn: function itemSizeFn(sourceCol) {\n          return wtTable.getColumnWidth(sourceCol);\n        },\n        overrideFn: wtSettings.getSettingPure('viewportColumnCalculatorOverride'),\n        calculationType: calculationType,\n        stretchMode: wtSettings.getSetting('stretchH'),\n        stretchingItemWidthFn: function stretchingItemWidthFn(stretchedWidth, column) {\n          return wtSettings.getSetting('onBeforeStretchingColumnWidth', stretchedWidth, column);\n        }\n      });\n    }\n\n    /**\n     * Creates rowsRenderCalculator and columnsRenderCalculator (before draw, to determine what rows and\n     * cols should be rendered).\n     *\n     * @param {boolean} fastDraw If `true`, will try to avoid full redraw and only update the border positions.\n     *                           If `false` or `undefined`, will perform a full redraw.\n     * @returns {boolean} The fastDraw value, possibly modified.\n     */\n  }, {\n    key: \"createRenderCalculators\",\n    value: function createRenderCalculators() {\n      var fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var runFastDraw = fastDraw;\n      if (runFastDraw) {\n        var proposedRowsVisibleCalculator = this.createRowsCalculator(FULLY_VISIBLE_TYPE);\n        var proposedColumnsVisibleCalculator = this.createColumnsCalculator(FULLY_VISIBLE_TYPE);\n        if (!(this.areAllProposedVisibleRowsAlreadyRendered(proposedRowsVisibleCalculator) && this.areAllProposedVisibleColumnsAlreadyRendered(proposedColumnsVisibleCalculator))) {\n          runFastDraw = false;\n        }\n      }\n      if (!runFastDraw) {\n        this.rowsRenderCalculator = this.createRowsCalculator(RENDER_TYPE);\n        this.columnsRenderCalculator = this.createColumnsCalculator(RENDER_TYPE);\n      }\n      // delete temporarily to make sure that renderers always use rowsRenderCalculator, not rowsVisibleCalculator\n      this.rowsVisibleCalculator = null;\n      this.columnsVisibleCalculator = null;\n      return runFastDraw;\n    }\n\n    /**\n     * Creates rowsVisibleCalculator and columnsVisibleCalculator (after draw, to determine what are\n     * the actually fully visible rows and columns).\n     */\n  }, {\n    key: \"createVisibleCalculators\",\n    value: function createVisibleCalculators() {\n      this.rowsVisibleCalculator = this.createRowsCalculator(FULLY_VISIBLE_TYPE);\n      this.columnsVisibleCalculator = this.createColumnsCalculator(FULLY_VISIBLE_TYPE);\n    }\n\n    /**\n     * Returns information whether proposedRowsVisibleCalculator viewport\n     * is contained inside rows rendered in previous draw (cached in rowsRenderCalculator).\n     *\n     * @param {ViewportRowsCalculator} proposedRowsVisibleCalculator The instance of the viewport calculator to compare with.\n     * @returns {boolean} Returns `true` if all proposed visible rows are already rendered (meaning: redraw is not needed).\n     *                    Returns `false` if at least one proposed visible row is not already rendered (meaning: redraw is needed).\n     */\n  }, {\n    key: \"areAllProposedVisibleRowsAlreadyRendered\",\n    value: function areAllProposedVisibleRowsAlreadyRendered(proposedRowsVisibleCalculator) {\n      if (!this.rowsVisibleCalculator) {\n        return false;\n      }\n      var startRow = proposedRowsVisibleCalculator.startRow,\n        endRow = proposedRowsVisibleCalculator.endRow;\n\n      // if there are no fully visible rows at all, return false\n      if (startRow === null && endRow === null) {\n        return false;\n      }\n      var _this$rowsRenderCalcu = this.rowsRenderCalculator,\n        renderedStartRow = _this$rowsRenderCalcu.startRow,\n        renderedEndRow = _this$rowsRenderCalcu.endRow;\n      if (startRow < renderedStartRow || startRow === renderedStartRow && startRow > 0) {\n        return false;\n      } else if (endRow > renderedEndRow || endRow === renderedEndRow && endRow < this.wtSettings.getSetting('totalRows') - 1) {\n        return false;\n      }\n      return true;\n    }\n\n    /**\n     * Returns information whether proposedColumnsVisibleCalculator viewport\n     * is contained inside column rendered in previous draw (cached in columnsRenderCalculator).\n     *\n     * @param {ViewportRowsCalculator} proposedColumnsVisibleCalculator The instance of the viewport calculator to compare with.\n     * @returns {boolean} Returns `true` if all proposed visible columns are already rendered (meaning: redraw is not needed).\n     *                    Returns `false` if at least one proposed visible column is not already rendered (meaning: redraw is needed).\n     */\n  }, {\n    key: \"areAllProposedVisibleColumnsAlreadyRendered\",\n    value: function areAllProposedVisibleColumnsAlreadyRendered(proposedColumnsVisibleCalculator) {\n      if (!this.columnsVisibleCalculator) {\n        return false;\n      }\n      var startColumn = proposedColumnsVisibleCalculator.startColumn,\n        endColumn = proposedColumnsVisibleCalculator.endColumn;\n\n      // if there are no fully visible columns at all, return false\n      if (startColumn === null && endColumn === null) {\n        return false;\n      }\n      var _this$columnsRenderCa = this.columnsRenderCalculator,\n        renderedStartColumn = _this$columnsRenderCa.startColumn,\n        renderedEndColumn = _this$columnsRenderCa.endColumn;\n      if (startColumn < renderedStartColumn || startColumn === renderedStartColumn && startColumn > 0) {\n        return false;\n      } else if (endColumn > renderedEndColumn || endColumn === renderedEndColumn && endColumn < this.wtSettings.getSetting('totalColumns') - 1) {\n        return false;\n      }\n      return true;\n    }\n\n    /**\n     * Resets values in keys of the hasOversizedColumnHeadersMarked object after updateSettings.\n     */\n  }, {\n    key: \"resetHasOversizedColumnHeadersMarked\",\n    value: function resetHasOversizedColumnHeadersMarked() {\n      objectEach(this.hasOversizedColumnHeadersMarked, function (value, key, object) {\n        object[key] = void 0;\n      });\n    }\n  }]);\n  return Viewport;\n}();\nexport default Viewport;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}