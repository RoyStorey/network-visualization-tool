{"ast":null,"code":"function _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (_x = (_i = _i.call(arr)).next, 0 === i) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n    } catch (err) {\n      _d = !0, _e = err;\n    } finally {\n      try {\n        if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _get() {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get.bind();\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n      if (desc.get) {\n        return desc.get.call(arguments.length < 3 ? target : receiver);\n      }\n      return desc.value;\n    };\n  }\n  return _get.apply(this, arguments);\n}\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n  return object;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n  return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) {\n  _checkPrivateRedeclaration(obj, privateMap);\n  privateMap.set(obj, value);\n}\nfunction _checkPrivateRedeclaration(obj, privateCollection) {\n  if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n  }\n}\nfunction _classPrivateFieldSet(receiver, privateMap, value) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\");\n  _classApplyDescriptorSet(receiver, descriptor, value);\n  return value;\n}\nfunction _classApplyDescriptorSet(receiver, descriptor, value) {\n  if (descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } else {\n    if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set read only private field\");\n    }\n    descriptor.value = value;\n  }\n}\nfunction _classPrivateFieldGet(receiver, privateMap) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\");\n  return _classApplyDescriptorGet(receiver, descriptor);\n}\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to \" + action + \" private field on non-instance\");\n  }\n  return privateMap.get(receiver);\n}\nfunction _classApplyDescriptorGet(receiver, descriptor) {\n  if (descriptor.get) {\n    return descriptor.get.call(receiver);\n  }\n  return descriptor.value;\n}\nimport { BasePlugin } from \"../base/index.mjs\";\nimport staticRegister from \"../../utils/staticRegister.mjs\";\nimport { error, warn } from \"../../helpers/console.mjs\";\nimport { isNumeric } from \"../../helpers/number.mjs\";\nimport { isDefined, isUndefined } from \"../../helpers/mixed.mjs\";\nimport { setupEngine, setupSheet, unregisterEngine, getRegisteredHotInstances } from \"./engine/register.mjs\";\nimport { isEscapedFormulaExpression, unescapeFormulaExpression } from \"./utils.mjs\";\nimport { getEngineSettingsWithOverrides } from \"./engine/settings.mjs\";\nimport { isArrayOfArrays } from \"../../helpers/data.mjs\";\nimport { toUpperCaseFirst } from \"../../helpers/string.mjs\";\nimport Hooks from \"../../pluginHooks.mjs\";\nexport var PLUGIN_KEY = 'formulas';\nexport var PLUGIN_PRIORITY = 260;\nvar ROW_MOVE_UNDO_REDO_NAME = 'row_move';\nHooks.getSingleton().register('afterNamedExpressionAdded');\nHooks.getSingleton().register('afterNamedExpressionRemoved');\nHooks.getSingleton().register('afterSheetAdded');\nHooks.getSingleton().register('afterSheetRemoved');\nHooks.getSingleton().register('afterSheetRenamed');\nHooks.getSingleton().register('afterFormulasValuesUpdate');\n\n// This function will be used for detecting changes coming from the `UndoRedo` plugin. This kind of change won't be\n// handled by whole body of listeners and therefore won't change undo/redo stack inside engine provided by HyperFormula.\n// HyperFormula's `undo` and `redo` methods will do it instead. Please keep in mind that undo/redo stacks inside\n// instances of Handsontable and HyperFormula should be synced (number of actions should be the same).\nvar isBlockedSource = function isBlockedSource(source) {\n  return source === 'UndoRedo.undo' || source === 'UndoRedo.redo' || source === 'auto';\n};\n\n/**\n * This plugin allows you to perform Excel-like calculations in your business applications. It does it by an\n * integration with our other product, [HyperFormula](https://github.com/handsontable/hyperformula/), which is a\n * powerful calculation engine with an extensive number of features.\n *\n * To test out HyperFormula, see [this guide](@/guides/formulas/formula-calculation.md#available-functions).\n *\n * @plugin Formulas\n * @class Formulas\n */\nvar _internalOperationPending = /*#__PURE__*/new WeakMap();\nvar _hotWasInitializedWithEmptyData = /*#__PURE__*/new WeakMap();\nvar _engineListeners = /*#__PURE__*/new WeakMap();\nexport var Formulas = /*#__PURE__*/function (_BasePlugin) {\n  _inherits(Formulas, _BasePlugin);\n  var _super = _createSuper(Formulas);\n  function Formulas() {\n    var _this;\n    _classCallCheck(this, Formulas);\n    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {\n      _args[_key] = arguments[_key];\n    }\n    _this = _super.call.apply(_super, [this].concat(_args));\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _internalOperationPending, {\n      writable: true,\n      value: false\n    });\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _hotWasInitializedWithEmptyData, {\n      writable: true,\n      value: false\n    });\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _engineListeners, {\n      writable: true,\n      value: [['valuesUpdated', function () {\n        var _this2;\n        return (_this2 = _this).onEngineValuesUpdated.apply(_this2, arguments);\n      }], ['namedExpressionAdded', function () {\n        var _this3;\n        return (_this3 = _this).onEngineNamedExpressionsAdded.apply(_this3, arguments);\n      }], ['namedExpressionRemoved', function () {\n        var _this4;\n        return (_this4 = _this).onEngineNamedExpressionsRemoved.apply(_this4, arguments);\n      }], ['sheetAdded', function () {\n        var _this5;\n        return (_this5 = _this).onEngineSheetAdded.apply(_this5, arguments);\n      }], ['sheetRenamed', function () {\n        var _this6;\n        return (_this6 = _this).onEngineSheetRenamed.apply(_this6, arguments);\n      }], ['sheetRemoved', function () {\n        var _this7;\n        return (_this7 = _this).onEngineSheetRemoved.apply(_this7, arguments);\n      }]]\n    });\n    _defineProperty(_assertThisInitialized(_this), \"staticRegister\", staticRegister('formulas'));\n    _defineProperty(_assertThisInitialized(_this), \"engine\", null);\n    _defineProperty(_assertThisInitialized(_this), \"sheetName\", null);\n    return _this;\n  }\n  _createClass(Formulas, [{\n    key: \"sheetId\",\n    get:\n    /**\n     * HyperFormula's sheet id.\n     *\n     * @type {number|null}\n     */\n    function get() {\n      return this.sheetName === null ? null : this.engine.getSheetId(this.sheetName);\n    }\n\n    /**\n     * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n     * hook and if it returns `true` then the {@link Formulas#enablePlugin} method is called.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isEnabled\",\n    value: function isEnabled() {\n      /* eslint-disable no-unneeded-ternary */\n      return this.hot.getSettings()[PLUGIN_KEY] ? true : false;\n    }\n\n    /**\n     * Enables the plugin functionality for this Handsontable instance.\n     */\n  }, {\n    key: \"enablePlugin\",\n    value: function enablePlugin() {\n      var _setupEngine,\n        _this8 = this;\n      if (this.enabled) {\n        return;\n      }\n      this.engine = (_setupEngine = setupEngine(this.hot)) !== null && _setupEngine !== void 0 ? _setupEngine : this.engine;\n      if (!this.engine) {\n        warn('Missing the required `engine` key in the Formulas settings. Please fill it with either an' + ' engine class or an engine instance.');\n        return;\n      }\n\n      // Useful for disabling -> enabling the plugin using `updateSettings` or the API.\n      if (this.sheetName !== null && !this.engine.doesSheetExist(this.sheetName)) {\n        var newSheetName = this.addSheet(this.sheetName, this.hot.getSourceDataArray());\n        if (newSheetName !== false) {\n          this.sheetName = newSheetName;\n        }\n      }\n      this.addHook('beforeLoadData', function () {\n        return _this8.onBeforeLoadData.apply(_this8, arguments);\n      });\n      this.addHook('afterLoadData', function () {\n        return _this8.onAfterLoadData.apply(_this8, arguments);\n      });\n\n      // The `updateData` hooks utilize the same logic as the `loadData` hooks.\n      this.addHook('beforeUpdateData', function () {\n        return _this8.onBeforeLoadData.apply(_this8, arguments);\n      });\n      this.addHook('afterUpdateData', function () {\n        return _this8.onAfterLoadData.apply(_this8, arguments);\n      });\n      this.addHook('modifyData', function () {\n        return _this8.onModifyData.apply(_this8, arguments);\n      });\n      this.addHook('modifySourceData', function () {\n        return _this8.onModifySourceData.apply(_this8, arguments);\n      });\n      this.addHook('beforeValidate', function () {\n        return _this8.onBeforeValidate.apply(_this8, arguments);\n      });\n      this.addHook('afterSetSourceDataAtCell', function () {\n        return _this8.onAfterSetSourceDataAtCell.apply(_this8, arguments);\n      });\n      this.addHook('afterSetDataAtCell', function () {\n        return _this8.onAfterSetDataAtCell.apply(_this8, arguments);\n      });\n      this.addHook('afterSetDataAtRowProp', function () {\n        return _this8.onAfterSetDataAtCell.apply(_this8, arguments);\n      });\n      this.addHook('beforeCreateRow', function () {\n        return _this8.onBeforeCreateRow.apply(_this8, arguments);\n      });\n      this.addHook('beforeCreateCol', function () {\n        return _this8.onBeforeCreateCol.apply(_this8, arguments);\n      });\n      this.addHook('afterCreateRow', function () {\n        return _this8.onAfterCreateRow.apply(_this8, arguments);\n      });\n      this.addHook('afterCreateCol', function () {\n        return _this8.onAfterCreateCol.apply(_this8, arguments);\n      });\n      this.addHook('beforeRemoveRow', function () {\n        return _this8.onBeforeRemoveRow.apply(_this8, arguments);\n      });\n      this.addHook('beforeRemoveCol', function () {\n        return _this8.onBeforeRemoveCol.apply(_this8, arguments);\n      });\n      this.addHook('afterRemoveRow', function () {\n        return _this8.onAfterRemoveRow.apply(_this8, arguments);\n      });\n      this.addHook('afterRemoveCol', function () {\n        return _this8.onAfterRemoveCol.apply(_this8, arguments);\n      });\n\n      // Handling undo actions on data just using HyperFormula's UndoRedo mechanism\n      this.addHook('beforeUndo', function (action) {\n        // TODO: Move action isn't handled by HyperFormula.\n        if ((action === null || action === void 0 ? void 0 : action.actionType) === ROW_MOVE_UNDO_REDO_NAME) {\n          return;\n        }\n        _this8.engine.undo();\n      });\n\n      // Handling redo actions on data just using HyperFormula's UndoRedo mechanism\n      this.addHook('beforeRedo', function (action) {\n        // TODO: Move action isn't handled by HyperFormula.\n        if ((action === null || action === void 0 ? void 0 : action.actionType) === ROW_MOVE_UNDO_REDO_NAME) {\n          return;\n        }\n        _this8.engine.redo();\n      });\n      this.addHook('afterDetachChild', function () {\n        return _this8.onAfterDetachChild.apply(_this8, arguments);\n      });\n      this.addHook('beforeAutofill', function () {\n        return _this8.onBeforeAutofill.apply(_this8, arguments);\n      });\n      _classPrivateFieldGet(this, _engineListeners).forEach(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n          eventName = _ref2[0],\n          listener = _ref2[1];\n        return _this8.engine.on(eventName, listener);\n      });\n      _get(_getPrototypeOf(Formulas.prototype), \"enablePlugin\", this).call(this);\n    }\n\n    /**\n     * Disables the plugin functionality for this Handsontable instance.\n     */\n  }, {\n    key: \"disablePlugin\",\n    value: function disablePlugin() {\n      var _this9 = this;\n      _classPrivateFieldGet(this, _engineListeners).forEach(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n          eventName = _ref4[0],\n          listener = _ref4[1];\n        return _this9.engine.off(eventName, listener);\n      });\n      unregisterEngine(this.engine, this.hot);\n      this.engine = null;\n      _get(_getPrototypeOf(Formulas.prototype), \"disablePlugin\", this).call(this);\n    }\n\n    /**\n     * Triggered on `updateSettings`.\n     *\n     * @private\n     * @param {object} newSettings New set of settings passed to the `updateSettings` method.\n     */\n  }, {\n    key: \"updatePlugin\",\n    value: function updatePlugin(newSettings) {\n      this.engine.updateConfig(getEngineSettingsWithOverrides(this.hot.getSettings()));\n      var pluginSettings = this.hot.getSettings()[PLUGIN_KEY];\n      if (isDefined(pluginSettings) && isDefined(pluginSettings.sheetName) && pluginSettings.sheetName !== this.sheetName) {\n        this.switchSheet(pluginSettings.sheetName);\n      }\n\n      // If no data was passed to the `updateSettings` method and no sheet is connected to the instance -> create a\n      // new sheet using the currently used data. Otherwise, it will be handled by the `afterLoadData` call.\n      if (!newSettings.data && this.sheetName === null) {\n        var sheetName = this.hot.getSettings()[PLUGIN_KEY].sheetName;\n        if (sheetName && this.engine.doesSheetExist(sheetName)) {\n          this.switchSheet(this.sheetName);\n        } else {\n          this.sheetName = this.addSheet(sheetName !== null && sheetName !== void 0 ? sheetName : void 0, this.hot.getSourceDataArray());\n        }\n      }\n      _get(_getPrototypeOf(Formulas.prototype), \"updatePlugin\", this).call(this, newSettings);\n    }\n\n    /**\n     * Destroys the plugin instance.\n     */\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _this10 = this;\n      _classPrivateFieldGet(this, _engineListeners).forEach(function (_ref5) {\n        var _this10$engine;\n        var _ref6 = _slicedToArray(_ref5, 2),\n          eventName = _ref6[0],\n          listener = _ref6[1];\n        return (_this10$engine = _this10.engine) === null || _this10$engine === void 0 ? void 0 : _this10$engine.off(eventName, listener);\n      });\n      _classPrivateFieldSet(this, _engineListeners, null);\n      unregisterEngine(this.engine, this.hot);\n      this.engine = null;\n      _get(_getPrototypeOf(Formulas.prototype), \"destroy\", this).call(this);\n    }\n\n    /**\n     * Helper function for `toPhysicalRowPosition` and `toPhysicalColumnPosition`.\n     *\n     * @private\n     * @param {number} visualIndex Visual entry index.\n     * @param {number} physicalIndex Physical entry index.\n     * @param {number} entriesCount Visual entries count.\n     * @param {number} sourceEntriesCount Source entries count.\n     * @param {boolean} contained `true` if it should return only indexes within boundaries of the table (basically\n     * `toPhysical` alias.\n     * @returns {*}\n     */\n  }, {\n    key: \"getPhysicalIndexPosition\",\n    value: function getPhysicalIndexPosition(visualIndex, physicalIndex, entriesCount, sourceEntriesCount, contained) {\n      if (!contained) {\n        if (visualIndex >= entriesCount) {\n          return sourceEntriesCount + (visualIndex - entriesCount);\n        }\n      }\n      return physicalIndex;\n    }\n\n    /**\n     * Returns the physical row index. The difference between this and Core's `toPhysical` is that it doesn't return\n     * `null` on rows with indexes higher than the number of rows.\n     *\n     * @private\n     * @param {number} row Visual row index.\n     * @param {boolean} [contained] `true` if it should return only indexes within boundaries of the table (basically\n     * `toPhysical` alias.\n     * @returns {number} The physical row index.\n     */\n  }, {\n    key: \"toPhysicalRowPosition\",\n    value: function toPhysicalRowPosition(row) {\n      var contained = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return this.getPhysicalIndexPosition(row, this.hot.toPhysicalRow(row), this.hot.countRows(), this.hot.countSourceRows(), contained);\n    }\n\n    /**\n     * Returns the physical column index. The difference between this and Core's `toPhysical` is that it doesn't return\n     * `null` on columns with indexes higher than the number of columns.\n     *\n     * @private\n     * @param {number} column Visual column index.\n     * @param {boolean} [contained] `true` if it should return only indexes within boundaries of the table (basically\n     * `toPhysical` alias.\n     * @returns {number} The physical column index.\n     */\n  }, {\n    key: \"toPhysicalColumnPosition\",\n    value: function toPhysicalColumnPosition(column) {\n      var contained = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return this.getPhysicalIndexPosition(column, this.hot.toPhysicalColumn(column), this.hot.countCols(), this.hot.countSourceCols(), contained);\n    }\n\n    /**\n     * Add a sheet to the shared HyperFormula instance.\n     *\n     * @param {string|null} [sheetName] The new sheet name. If not provided (or a null is passed), will be\n     * auto-generated by HyperFormula.\n     * @param {Array} [sheetData] Data passed to the shared HyperFormula instance. Has to be declared as an array of\n     * arrays - array of objects is not supported in this scenario.\n     * @returns {boolean|string} `false` if the data format is unusable or it is impossible to add a new sheet to the\n     * engine, the created sheet name otherwise.\n     */\n  }, {\n    key: \"addSheet\",\n    value: function addSheet(sheetName, sheetData) {\n      if (isDefined(sheetData) && !isArrayOfArrays(sheetData)) {\n        warn('The provided data should be an array of arrays.');\n        return false;\n      }\n      if (sheetName !== void 0 && sheetName !== null && this.engine.doesSheetExist(sheetName)) {\n        warn('Sheet with the provided name already exists.');\n        return false;\n      }\n      try {\n        var actualSheetName = this.engine.addSheet(sheetName !== null && sheetName !== void 0 ? sheetName : void 0);\n        if (sheetData) {\n          this.engine.setSheetContent(this.engine.getSheetId(actualSheetName), sheetData);\n        }\n        return actualSheetName;\n      } catch (e) {\n        warn(e.message);\n        return false;\n      }\n    }\n\n    /**\n     * Switch the sheet used as data in the Handsontable instance (it loads the data from the shared HyperFormula\n     * instance).\n     *\n     * @param {string} sheetName Sheet name used in the shared HyperFormula instance.\n     */\n  }, {\n    key: \"switchSheet\",\n    value: function switchSheet(sheetName) {\n      if (!this.engine.doesSheetExist(sheetName)) {\n        error(\"The sheet named `\".concat(sheetName, \"` does not exist, switch aborted.\"));\n        return;\n      }\n      this.sheetName = sheetName;\n      var serialized = this.engine.getSheetSerialized(this.sheetId);\n      if (serialized.length > 0) {\n        this.hot.loadData(serialized, \"\".concat(toUpperCaseFirst(PLUGIN_KEY), \".switchSheet\"));\n      }\n    }\n\n    /**\n     * Get the cell type under specified visual coordinates.\n     *\n     * @param {number} row Visual row index.\n     * @param {number} column Visual column index.\n     * @param {number} [sheet] The target sheet id, defaults to the current sheet.\n     * @returns {string} Possible values: 'FORMULA' | 'VALUE' | 'ARRAYFORMULA' | 'EMPTY'.\n     */\n  }, {\n    key: \"getCellType\",\n    value: function getCellType(row, column) {\n      var sheet = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.sheetId;\n      var physicalRow = this.hot.toPhysicalRow(row);\n      var physicalColumn = this.hot.toPhysicalColumn(column);\n      if (physicalRow !== null && physicalColumn !== null) {\n        return this.engine.getCellType({\n          sheet: sheet,\n          row: physicalRow,\n          col: physicalColumn\n        });\n      } else {\n        // Should return `EMPTY` when out of bounds (according to the test cases).\n        return 'EMPTY';\n      }\n    }\n\n    /**\n     * Returns `true` if under specified visual coordinates is formula.\n     *\n     * @param {number} row Visual row index.\n     * @param {number} column Visual column index.\n     * @param {number} [sheet] The target sheet id, defaults to the current sheet.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isFormulaCellType\",\n    value: function isFormulaCellType(row, column) {\n      var sheet = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.sheetId;\n      var physicalRow = this.hot.toPhysicalRow(row);\n      var physicalColumn = this.hot.toPhysicalColumn(column);\n      if (physicalRow === null || physicalColumn === null) {\n        return false;\n      }\n      return this.engine.doesCellHaveFormula({\n        sheet: sheet,\n        row: physicalRow,\n        col: physicalColumn\n      });\n    }\n\n    /**\n     * Renders dependent sheets (handsontable instances) based on the changes - list of the\n     * recalculated dependent cells.\n     *\n     * @private\n     * @param {object[]} dependentCells The values and location of applied changes within HF engine.\n     * @param {boolean} [renderSelf] `true` if it's supposed to render itself, `false` otherwise.\n     */\n  }, {\n    key: \"renderDependentSheets\",\n    value: function renderDependentSheets(dependentCells) {\n      var _this11 = this;\n      var renderSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var affectedSheetIds = new Set();\n      dependentCells.forEach(function (change) {\n        var _change$address;\n        // For the Named expression the address is empty, hence the `sheetId` is undefined.\n        var sheetId = change === null || change === void 0 ? void 0 : (_change$address = change.address) === null || _change$address === void 0 ? void 0 : _change$address.sheet;\n        if (sheetId !== void 0) {\n          if (!affectedSheetIds.has(sheetId)) {\n            affectedSheetIds.add(sheetId);\n          }\n        }\n      });\n      getRegisteredHotInstances(this.engine).forEach(function (relatedHot, sheetId) {\n        if ((renderSelf || sheetId !== _this11.sheetId) && affectedSheetIds.has(sheetId)) {\n          var _relatedHot$view;\n          relatedHot.render();\n          (_relatedHot$view = relatedHot.view) === null || _relatedHot$view === void 0 ? void 0 : _relatedHot$view.adjustElementsSize();\n        }\n      });\n    }\n\n    /**\n     * Validates dependent cells based on the cells that are modified by the change.\n     *\n     * @private\n     * @param {object[]} dependentCells The values and location of applied changes within HF engine.\n     * @param {object[]} [changedCells] The values and location of applied changes by developer (through API or UI).\n     */\n  }, {\n    key: \"validateDependentCells\",\n    value: function validateDependentCells(dependentCells) {\n      var _this12 = this;\n      var changedCells = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var stringifyAddress = function stringifyAddress(change) {\n        var _change$address2;\n        var _ref7 = (_change$address2 = change === null || change === void 0 ? void 0 : change.address) !== null && _change$address2 !== void 0 ? _change$address2 : {},\n          row = _ref7.row,\n          col = _ref7.col,\n          sheet = _ref7.sheet;\n        return isDefined(sheet) ? \"\".concat(sheet, \":\").concat(row, \"x\").concat(col) : '';\n      };\n      var changedCellsSet = new Set(changedCells.map(function (change) {\n        return stringifyAddress(change);\n      }));\n      dependentCells.forEach(function (change) {\n        var _change$address3, _change$address4;\n        var _ref8 = (_change$address3 = change.address) !== null && _change$address3 !== void 0 ? _change$address3 : {},\n          row = _ref8.row,\n          col = _ref8.col;\n        var visualRow = isDefined(row) ? _this12.hot.toVisualRow(row) : null;\n        var visualColumn = isDefined(col) ? _this12.hot.toVisualColumn(col) : null;\n\n        // Don't try to validate cells outside of the visual part of the table.\n        if (visualRow === null || visualColumn === null) {\n          return;\n        }\n\n        // For the Named expression the address is empty, hence the `sheetId` is undefined.\n        var sheetId = change === null || change === void 0 ? void 0 : (_change$address4 = change.address) === null || _change$address4 === void 0 ? void 0 : _change$address4.sheet;\n        var addressId = stringifyAddress(change);\n\n        // Validate the cells that depend on the calculated formulas. Skip that cells\n        // where the user directly changes the values - the Core triggers those validators.\n        if (sheetId !== void 0 && !changedCellsSet.has(addressId)) {\n          var boundHot = getRegisteredHotInstances(_this12.engine).get(sheetId);\n\n          // if `sheetId` is not bound to any Handsontable instance, skip the validation process\n          if (!boundHot) {\n            return;\n          }\n\n          // It will just re-render certain cell when necessary.\n          boundHot.validateCell(boundHot.getDataAtCell(visualRow, visualColumn), boundHot.getCellMeta(visualRow, visualColumn), function () {});\n        }\n      });\n    }\n\n    /**\n     * Sync a change from the change-related hooks with the engine.\n     *\n     * @private\n     * @param {number} row Visual row index.\n     * @param {number} column Visual column index.\n     * @param {Handsontable.CellValue} newValue New value.\n     * @returns {Array} Array of changes exported from the engine.\n     */\n  }, {\n    key: \"syncChangeWithEngine\",\n    value: function syncChangeWithEngine(row, column, newValue) {\n      var address = {\n        row: this.toPhysicalRowPosition(row),\n        col: this.toPhysicalColumnPosition(column),\n        sheet: this.sheetId\n      };\n      if (!this.engine.isItPossibleToSetCellContents(address)) {\n        warn(\"Not possible to set cell data at \".concat(JSON.stringify(address)));\n        return;\n      }\n      return this.engine.setCellContents(address, newValue);\n    }\n\n    /**\n     * The hook allows to translate the formula value to calculated value before it goes to the\n     * validator function.\n     *\n     * @private\n     * @param {*} value The cell value to validate.\n     * @param {number} visualRow The visual row index.\n     * @param {number|string} prop The visual column index or property name of the column.\n     * @returns {*} Returns value to validate.\n     */\n  }, {\n    key: \"onBeforeValidate\",\n    value: function onBeforeValidate(value, visualRow, prop) {\n      var visualColumn = this.hot.propToCol(prop);\n      if (this.isFormulaCellType(visualRow, visualColumn)) {\n        var address = {\n          row: this.hot.toPhysicalRow(visualRow),\n          col: this.hot.toPhysicalColumn(visualColumn),\n          sheet: this.sheetId\n        };\n        var cellValue = this.engine.getCellValue(address);\n\n        // If `cellValue` is an object it is expected to be an error\n        return _typeof(cellValue) === 'object' && cellValue !== null ? cellValue.value : cellValue;\n      }\n      return value;\n    }\n\n    /**\n     * `onBeforeAutofill` hook callback.\n     *\n     * @private\n     * @param {Array[]} fillData The data that was used to fill the `targetRange`. If `beforeAutofill` was used\n     * and returned `[[]]`, this will be the same object that was returned from `beforeAutofill`.\n     * @param {CellRange} sourceRange The range values will be filled from.\n     * @param {CellRange} targetRange The range new values will be filled into.\n     * @returns {boolean|*}\n     */\n  }, {\n    key: \"onBeforeAutofill\",\n    value: function onBeforeAutofill(fillData, sourceRange, targetRange) {\n      var _this13 = this;\n      var withSheetId = function withSheetId(range) {\n        return _objectSpread(_objectSpread({}, range), {}, {\n          sheet: _this13.sheetId\n        });\n      };\n      var engineSourceRange = {\n        start: withSheetId(sourceRange.getTopStartCorner()),\n        end: withSheetId(sourceRange.getBottomEndCorner())\n      };\n      var engineTargetRange = {\n        start: withSheetId(targetRange.getTopStartCorner()),\n        end: withSheetId(targetRange.getBottomEndCorner())\n      };\n\n      // Blocks the autofill operation if HyperFormula says that at least one of\n      // the underlying cell's contents cannot be set.\n      if (this.engine.isItPossibleToSetCellContents(engineTargetRange) === false) {\n        return false;\n      }\n      return this.engine.getFillRangeData(engineSourceRange, engineTargetRange);\n    }\n\n    /**\n     * `beforeLoadData` hook callback.\n     *\n     * @param {Array} sourceData Array of arrays or array of objects containing data.\n     * @param {boolean} initialLoad Flag that determines whether the data has been loaded during the initialization.\n     * @param {string} [source] Source of the call.\n     * @private\n     */\n  }, {\n    key: \"onBeforeLoadData\",\n    value: function onBeforeLoadData(sourceData, initialLoad) {\n      var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      if (source.includes(toUpperCaseFirst(PLUGIN_KEY))) {\n        return;\n      }\n\n      // This flag needs to be defined, because not passing data to HOT results in HOT auto-generating a `null`-filled\n      // initial dataset.\n      _classPrivateFieldSet(this, _hotWasInitializedWithEmptyData, isUndefined(this.hot.getSettings().data));\n    }\n\n    /**\n     * `afterLoadData` hook callback.\n     *\n     * @param {Array} sourceData Array of arrays or array of objects containing data.\n     * @param {boolean} initialLoad Flag that determines whether the data has been loaded during the initialization.\n     * @param {string} [source] Source of the call.\n     * @private\n     */\n  }, {\n    key: \"onAfterLoadData\",\n    value: function onAfterLoadData(sourceData, initialLoad) {\n      var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      if (source.includes(toUpperCaseFirst(PLUGIN_KEY))) {\n        return;\n      }\n      this.sheetName = setupSheet(this.engine, this.hot.getSettings()[PLUGIN_KEY].sheetName);\n      if (!_classPrivateFieldGet(this, _hotWasInitializedWithEmptyData)) {\n        var sourceDataArray = this.hot.getSourceDataArray();\n        if (this.engine.isItPossibleToReplaceSheetContent(this.sheetId, sourceDataArray)) {\n          _classPrivateFieldSet(this, _internalOperationPending, true);\n          var dependentCells = this.engine.setSheetContent(this.sheetId, this.hot.getSourceDataArray());\n          this.renderDependentSheets(dependentCells);\n          _classPrivateFieldSet(this, _internalOperationPending, false);\n        }\n      } else {\n        this.switchSheet(this.sheetName);\n      }\n    }\n\n    /**\n     * `modifyData` hook callback.\n     *\n     * @private\n     * @param {number} row Physical row height.\n     * @param {number} column Physical column index.\n     * @param {object} valueHolder Object which contains original value which can be modified by overwriting `.value`\n     *   property.\n     * @param {string} ioMode String which indicates for what operation hook is fired (`get` or `set`).\n     */\n  }, {\n    key: \"onModifyData\",\n    value: function onModifyData(row, column, valueHolder, ioMode) {\n      if (ioMode !== 'get' || _classPrivateFieldGet(this, _internalOperationPending) || this.sheetName === null || !this.engine.doesSheetExist(this.sheetName)) {\n        return;\n      }\n      var visualRow = this.hot.toVisualRow(row);\n\n      // `column` is here as visual index because of inconsistencies related to hook execution in `src/dataMap`.\n      var isFormulaCellType = this.isFormulaCellType(visualRow, column);\n      if (!isFormulaCellType) {\n        var cellType = this.getCellType(visualRow, column);\n        if (cellType !== 'ARRAY') {\n          if (isEscapedFormulaExpression(valueHolder.value)) {\n            valueHolder.value = unescapeFormulaExpression(valueHolder.value);\n          }\n          return;\n        }\n      }\n\n      // `toPhysicalColumn` is here because of inconsistencies related to hook execution in `DataMap`.\n      var address = {\n        row: row,\n        col: this.toPhysicalColumnPosition(column),\n        sheet: this.sheetId\n      };\n      var cellValue = this.engine.getCellValue(address);\n\n      // If `cellValue` is an object it is expected to be an error\n      var value = _typeof(cellValue) === 'object' && cellValue !== null ? cellValue.value : cellValue;\n      valueHolder.value = value;\n    }\n\n    /**\n     * `modifySourceData` hook callback.\n     *\n     * @private\n     * @param {number} row Physical row index.\n     * @param {number|string} columnOrProp Physical column index or prop.\n     * @param {object} valueHolder Object which contains original value which can be modified by overwriting `.value`\n     *   property.\n     * @param {string} ioMode String which indicates for what operation hook is fired (`get` or `set`).\n     */\n  }, {\n    key: \"onModifySourceData\",\n    value: function onModifySourceData(row, columnOrProp, valueHolder, ioMode) {\n      if (ioMode !== 'get' || _classPrivateFieldGet(this, _internalOperationPending) || this.sheetName === null || !this.engine.doesSheetExist(this.sheetName)) {\n        return;\n      }\n      var visualRow = this.hot.toVisualRow(row);\n      var visualColumn = this.hot.propToCol(columnOrProp);\n\n      // `column` is here as visual index because of inconsistencies related to hook execution in `src/dataMap`.\n      var isFormulaCellType = this.isFormulaCellType(visualRow, visualColumn);\n      if (!isFormulaCellType) {\n        var cellType = this.getCellType(visualRow, visualColumn);\n        if (cellType !== 'ARRAY') {\n          return;\n        }\n      }\n      var dimensions = this.engine.getSheetDimensions(this.engine.getSheetId(this.sheetName));\n\n      // Don't actually change the source data if HyperFormula is not\n      // initialized yet. This is done to allow the `afterLoadData` hook to\n      // load the existing source data with `Handsontable#getSourceDataArray`\n      // properly.\n      if (dimensions.width === 0 && dimensions.height === 0) {\n        return;\n      }\n      var address = {\n        row: row,\n        // Workaround for inconsistencies in `src/dataSource.js`\n        col: this.toPhysicalColumnPosition(visualColumn),\n        sheet: this.sheetId\n      };\n      valueHolder.value = this.engine.getCellSerialized(address);\n    }\n\n    /**\n     * `onAfterSetDataAtCell` hook callback.\n     *\n     * @private\n     * @param {Array[]} changes An array of changes in format [[row, prop, oldValue, value], ...].\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsontable-hooks}).\n     */\n  }, {\n    key: \"onAfterSetDataAtCell\",\n    value: function onAfterSetDataAtCell(changes, source) {\n      var _this14 = this;\n      if (isBlockedSource(source)) {\n        return;\n      }\n      var outOfBoundsChanges = [];\n      var changedCells = [];\n      var dependentCells = this.engine.batch(function () {\n        changes.forEach(function (_ref9) {\n          var _ref10 = _slicedToArray(_ref9, 4),\n            row = _ref10[0],\n            prop = _ref10[1],\n            newValue = _ref10[3];\n          var column = _this14.hot.propToCol(prop);\n          var physicalRow = _this14.hot.toPhysicalRow(row);\n          var physicalColumn = _this14.hot.toPhysicalColumn(column);\n          var address = {\n            row: physicalRow,\n            col: physicalColumn,\n            sheet: _this14.sheetId\n          };\n          if (physicalRow !== null && physicalColumn !== null) {\n            _this14.syncChangeWithEngine(row, column, newValue);\n          } else {\n            outOfBoundsChanges.push([row, column, newValue]);\n          }\n          changedCells.push({\n            address: address\n          });\n        });\n      });\n      if (outOfBoundsChanges.length) {\n        // Workaround for rows/columns being created two times (by HOT and the engine).\n        // (unfortunately, this requires an extra re-render)\n        this.hot.addHookOnce('afterChange', function () {\n          var outOfBoundsDependentCells = _this14.engine.batch(function () {\n            outOfBoundsChanges.forEach(function (_ref11) {\n              var _ref12 = _slicedToArray(_ref11, 3),\n                row = _ref12[0],\n                column = _ref12[1],\n                newValue = _ref12[2];\n              _this14.syncChangeWithEngine(row, column, newValue);\n            });\n          });\n          _this14.renderDependentSheets(outOfBoundsDependentCells, true);\n        });\n      }\n      this.renderDependentSheets(dependentCells);\n      this.validateDependentCells(dependentCells, changedCells);\n    }\n\n    /**\n     * `onAfterSetSourceDataAtCell` hook callback.\n     *\n     * @private\n     * @param {Array[]} changes An array of changes in format [[row, column, oldValue, value], ...].\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsontable-hooks}).\n     */\n  }, {\n    key: \"onAfterSetSourceDataAtCell\",\n    value: function onAfterSetSourceDataAtCell(changes, source) {\n      var _this15 = this;\n      if (isBlockedSource(source)) {\n        return;\n      }\n      var dependentCells = [];\n      var changedCells = [];\n      changes.forEach(function (_ref13) {\n        var _ref14 = _slicedToArray(_ref13, 4),\n          row = _ref14[0],\n          prop = _ref14[1],\n          newValue = _ref14[3];\n        var column = _this15.hot.propToCol(prop);\n        if (!isNumeric(column)) {\n          return;\n        }\n        var address = {\n          row: row,\n          col: _this15.toPhysicalColumnPosition(column),\n          sheet: _this15.sheetId\n        };\n        if (!_this15.engine.isItPossibleToSetCellContents(address)) {\n          warn(\"Not possible to set source cell data at \".concat(JSON.stringify(address)));\n          return;\n        }\n        changedCells.push({\n          address: address\n        });\n        dependentCells.push.apply(dependentCells, _toConsumableArray(_this15.engine.setCellContents(address, newValue)));\n      });\n      this.renderDependentSheets(dependentCells);\n      this.validateDependentCells(dependentCells, changedCells);\n    }\n\n    /**\n     * `beforeCreateRow` hook callback.\n     *\n     * @private\n     * @param {number} row Represents the visual index of first newly created row in the data source array.\n     * @param {number} amount Number of newly created rows in the data source array.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n  }, {\n    key: \"onBeforeCreateRow\",\n    value: function onBeforeCreateRow(row, amount) {\n      if (this.sheetId === null || !this.engine.doesSheetExist(this.sheetName) || !this.engine.isItPossibleToAddRows(this.sheetId, [this.toPhysicalRowPosition(row), amount])) {\n        return false;\n      }\n    }\n\n    /**\n     * `beforeCreateCol` hook callback.\n     *\n     * @private\n     * @param {number} col Represents the visual index of first newly created column in the data source.\n     * @param {number} amount Number of newly created columns in the data source.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n  }, {\n    key: \"onBeforeCreateCol\",\n    value: function onBeforeCreateCol(col, amount) {\n      if (this.sheetId === null || !this.engine.doesSheetExist(this.sheetName) || !this.engine.isItPossibleToAddColumns(this.sheetId, [this.toPhysicalColumnPosition(col), amount])) {\n        return false;\n      }\n    }\n\n    /**\n     * `beforeRemoveRow` hook callback.\n     *\n     * @private\n     * @param {number} row Visual index of starter row.\n     * @param {number} amount Amount of rows to be removed.\n     * @param {number[]} physicalRows An array of physical rows removed from the data source.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n  }, {\n    key: \"onBeforeRemoveRow\",\n    value: function onBeforeRemoveRow(row, amount, physicalRows) {\n      var _this16 = this;\n      var possible = physicalRows.every(function (physicalRow) {\n        return _this16.engine.isItPossibleToRemoveRows(_this16.sheetId, [physicalRow, 1]);\n      });\n      return possible === false ? false : void 0;\n    }\n\n    /**\n     * `beforeRemoveCol` hook callback.\n     *\n     * @private\n     * @param {number} col Visual index of starter column.\n     * @param {number} amount Amount of columns to be removed.\n     * @param {number[]} physicalColumns An array of physical columns removed from the data source.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n  }, {\n    key: \"onBeforeRemoveCol\",\n    value: function onBeforeRemoveCol(col, amount, physicalColumns) {\n      var _this17 = this;\n      var possible = physicalColumns.every(function (physicalColumn) {\n        return _this17.engine.isItPossibleToRemoveColumns(_this17.sheetId, [physicalColumn, 1]);\n      });\n      return possible === false ? false : void 0;\n    }\n\n    /**\n     * `afterCreateRow` hook callback.\n     *\n     * @private\n     * @param {number} row Represents the visual index of first newly created row in the data source array.\n     * @param {number} amount Number of newly created rows in the data source array.\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsontable-hooks}).\n     */\n  }, {\n    key: \"onAfterCreateRow\",\n    value: function onAfterCreateRow(row, amount, source) {\n      if (isBlockedSource(source)) {\n        return;\n      }\n      var changes = this.engine.addRows(this.sheetId, [this.toPhysicalRowPosition(row), amount]);\n      this.renderDependentSheets(changes);\n    }\n\n    /**\n     * `afterCreateCol` hook callback.\n     *\n     * @private\n     * @param {number} col Represents the visual index of first newly created column in the data source.\n     * @param {number} amount Number of newly created columns in the data source.\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsontable-hooks}).\n     */\n  }, {\n    key: \"onAfterCreateCol\",\n    value: function onAfterCreateCol(col, amount, source) {\n      if (isBlockedSource(source)) {\n        return;\n      }\n      var changes = this.engine.addColumns(this.sheetId, [this.toPhysicalColumnPosition(col), amount]);\n      this.renderDependentSheets(changes);\n    }\n\n    /**\n     * `afterRemoveRow` hook callback.\n     *\n     * @private\n     * @param {number} row Visual index of starter row.\n     * @param {number} amount An amount of removed rows.\n     * @param {number[]} physicalRows An array of physical rows removed from the data source.\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsontable-hooks}).\n     */\n  }, {\n    key: \"onAfterRemoveRow\",\n    value: function onAfterRemoveRow(row, amount, physicalRows, source) {\n      var _this18 = this;\n      if (isBlockedSource(source)) {\n        return;\n      }\n      var descendingPhysicalRows = physicalRows.sort().reverse();\n      var changes = this.engine.batch(function () {\n        descendingPhysicalRows.forEach(function (physicalRow) {\n          _this18.engine.removeRows(_this18.sheetId, [physicalRow, 1]);\n        });\n      });\n      this.renderDependentSheets(changes);\n    }\n\n    /**\n     * `afterRemoveCol` hook callback.\n     *\n     * @private\n     * @param {number} col Visual index of starter column.\n     * @param {number} amount An amount of removed columns.\n     * @param {number[]} physicalColumns An array of physical columns removed from the data source.\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsontable-hooks}).\n     */\n  }, {\n    key: \"onAfterRemoveCol\",\n    value: function onAfterRemoveCol(col, amount, physicalColumns, source) {\n      var _this19 = this;\n      if (isBlockedSource(source)) {\n        return;\n      }\n      var descendingPhysicalColumns = physicalColumns.sort().reverse();\n      var changes = this.engine.batch(function () {\n        descendingPhysicalColumns.forEach(function (physicalColumn) {\n          _this19.engine.removeColumns(_this19.sheetId, [physicalColumn, 1]);\n        });\n      });\n      this.renderDependentSheets(changes);\n    }\n\n    /**\n     * `afterDetachChild` hook callback.\n     * Used to sync the data of the rows detached in the Nested Rows plugin with the engine's dataset.\n     *\n     * @private\n     * @param {object} parent An object representing the parent from which the element was detached.\n     * @param {object} element The detached element.\n     * @param {number} finalElementRowIndex The final row index of the detached element.\n     */\n  }, {\n    key: \"onAfterDetachChild\",\n    value: function onAfterDetachChild(parent, element, finalElementRowIndex) {\n      var _element$__children,\n        _this20 = this;\n      _classPrivateFieldSet(this, _internalOperationPending, true);\n      var rowsData = this.hot.getSourceDataArray(finalElementRowIndex, 0, finalElementRowIndex + (((_element$__children = element.__children) === null || _element$__children === void 0 ? void 0 : _element$__children.length) || 0), this.hot.countSourceCols());\n      _classPrivateFieldSet(this, _internalOperationPending, false);\n      rowsData.forEach(function (row, relativeRowIndex) {\n        row.forEach(function (value, colIndex) {\n          _this20.engine.setCellContents({\n            col: colIndex,\n            row: finalElementRowIndex + relativeRowIndex,\n            sheet: _this20.sheetId\n          }, [[value]]);\n        });\n      });\n    }\n\n    /**\n     * Called when a value is updated in the engine.\n     *\n     * @private\n     * @fires Hooks#afterFormulasValuesUpdate\n     * @param {Array} changes The values and location of applied changes.\n     */\n  }, {\n    key: \"onEngineValuesUpdated\",\n    value: function onEngineValuesUpdated(changes) {\n      this.hot.runHooks('afterFormulasValuesUpdate', changes);\n    }\n\n    /**\n     * Called when a named expression is added to the engine instance.\n     *\n     * @private\n     * @fires Hooks#afterNamedExpressionAdded\n     * @param {string} namedExpressionName The name of the added expression.\n     * @param {Array} changes The values and location of applied changes.\n     */\n  }, {\n    key: \"onEngineNamedExpressionsAdded\",\n    value: function onEngineNamedExpressionsAdded(namedExpressionName, changes) {\n      this.hot.runHooks('afterNamedExpressionAdded', namedExpressionName, changes);\n    }\n\n    /**\n     * Called when a named expression is removed from the engine instance.\n     *\n     * @private\n     * @fires Hooks#afterNamedExpressionRemoved\n     * @param {string} namedExpressionName The name of the removed expression.\n     * @param {Array} changes The values and location of applied changes.\n     */\n  }, {\n    key: \"onEngineNamedExpressionsRemoved\",\n    value: function onEngineNamedExpressionsRemoved(namedExpressionName, changes) {\n      this.hot.runHooks('afterNamedExpressionRemoved', namedExpressionName, changes);\n    }\n\n    /**\n     * Called when a new sheet is added to the engine instance.\n     *\n     * @private\n     * @fires Hooks#afterSheetAdded\n     * @param {string} addedSheetDisplayName The name of the added sheet.\n     */\n  }, {\n    key: \"onEngineSheetAdded\",\n    value: function onEngineSheetAdded(addedSheetDisplayName) {\n      this.hot.runHooks('afterSheetAdded', addedSheetDisplayName);\n    }\n\n    /**\n     * Called when a sheet in the engine instance is renamed.\n     *\n     * @private\n     * @fires Hooks#afterSheetRenamed\n     * @param {string} oldDisplayName The old name of the sheet.\n     * @param {string} newDisplayName The new name of the sheet.\n     */\n  }, {\n    key: \"onEngineSheetRenamed\",\n    value: function onEngineSheetRenamed(oldDisplayName, newDisplayName) {\n      this.hot.runHooks('afterSheetRenamed', oldDisplayName, newDisplayName);\n    }\n\n    /**\n     * Called when a sheet is removed from the engine instance.\n     *\n     * @private\n     * @fires Hooks#afterSheetRemoved\n     * @param {string} removedSheetDisplayName The removed sheet name.\n     * @param {Array} changes The values and location of applied changes.\n     */\n  }, {\n    key: \"onEngineSheetRemoved\",\n    value: function onEngineSheetRemoved(removedSheetDisplayName, changes) {\n      this.hot.runHooks('afterSheetRemoved', removedSheetDisplayName, changes);\n    }\n  }], [{\n    key: \"PLUGIN_KEY\",\n    get: function get() {\n      return PLUGIN_KEY;\n    }\n  }, {\n    key: \"PLUGIN_PRIORITY\",\n    get: function get() {\n      return PLUGIN_PRIORITY;\n    }\n\n    /**\n     * Flag used to bypass hooks in internal operations.\n     *\n     * @private\n     * @type {boolean}\n     */\n  }]);\n\n  return Formulas;\n}(BasePlugin);","map":{"version":3,"names":["_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","Array","from","isArray","_arrayLikeToArray","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","_typeof","obj","constructor","prototype","_slicedToArray","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","o","minLen","n","toString","call","slice","name","test","len","arr2","_i","_s","_e","_x","_r","_arr","_n","_d","next","done","value","err","return","_classCallCheck","instance","Constructor","_defineProperties","props","descriptor","configurable","writable","_toPropertyKey","_createClass","protoProps","staticProps","_get","Reflect","get","bind","property","receiver","base","_superPropBase","desc","hasOwnProperty","_getPrototypeOf","_inherits","subClass","superClass","create","_setPrototypeOf","p","setPrototypeOf","__proto__","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","_createSuperInternal","Super","result","NewTarget","construct","_possibleConstructorReturn","self","_assertThisInitialized","ReferenceError","sham","Proxy","Boolean","valueOf","e","getPrototypeOf","arg","_toPrimitive","String","input","hint","prim","toPrimitive","undefined","res","Number","_classPrivateFieldInitSpec","privateMap","_checkPrivateRedeclaration","set","privateCollection","has","_classPrivateFieldSet","_classExtractFieldDescriptor","_classApplyDescriptorSet","_classPrivateFieldGet","_classApplyDescriptorGet","action","BasePlugin","staticRegister","error","warn","isNumeric","isDefined","isUndefined","setupEngine","setupSheet","unregisterEngine","getRegisteredHotInstances","isEscapedFormulaExpression","unescapeFormulaExpression","getEngineSettingsWithOverrides","isArrayOfArrays","toUpperCaseFirst","Hooks","PLUGIN_KEY","PLUGIN_PRIORITY","ROW_MOVE_UNDO_REDO_NAME","getSingleton","register","isBlockedSource","_internalOperationPending","WeakMap","_hotWasInitializedWithEmptyData","_engineListeners","Formulas","_BasePlugin","_super","_this","_len","_args","_key","concat","_this2","onEngineValuesUpdated","_this3","onEngineNamedExpressionsAdded","_this4","onEngineNamedExpressionsRemoved","_this5","onEngineSheetAdded","_this6","onEngineSheetRenamed","_this7","onEngineSheetRemoved","sheetName","engine","getSheetId","isEnabled","hot","getSettings","enablePlugin","_setupEngine","_this8","enabled","doesSheetExist","newSheetName","addSheet","getSourceDataArray","addHook","onBeforeLoadData","onAfterLoadData","onModifyData","onModifySourceData","onBeforeValidate","onAfterSetSourceDataAtCell","onAfterSetDataAtCell","onBeforeCreateRow","onBeforeCreateCol","onAfterCreateRow","onAfterCreateCol","onBeforeRemoveRow","onBeforeRemoveCol","onAfterRemoveRow","onAfterRemoveCol","actionType","undo","redo","onAfterDetachChild","onBeforeAutofill","_ref","_ref2","eventName","listener","on","disablePlugin","_this9","_ref3","_ref4","off","updatePlugin","newSettings","updateConfig","pluginSettings","switchSheet","data","destroy","_this10","_ref5","_this10$engine","_ref6","getPhysicalIndexPosition","visualIndex","physicalIndex","entriesCount","sourceEntriesCount","contained","toPhysicalRowPosition","row","toPhysicalRow","countRows","countSourceRows","toPhysicalColumnPosition","column","toPhysicalColumn","countCols","countSourceCols","sheetData","actualSheetName","setSheetContent","message","serialized","getSheetSerialized","sheetId","loadData","getCellType","sheet","physicalRow","physicalColumn","col","isFormulaCellType","doesCellHaveFormula","renderDependentSheets","dependentCells","_this11","renderSelf","affectedSheetIds","Set","change","_change$address","address","add","relatedHot","_relatedHot$view","render","view","adjustElementsSize","validateDependentCells","_this12","changedCells","stringifyAddress","_change$address2","_ref7","changedCellsSet","map","_change$address3","_change$address4","_ref8","visualRow","toVisualRow","visualColumn","toVisualColumn","addressId","boundHot","validateCell","getDataAtCell","getCellMeta","syncChangeWithEngine","newValue","isItPossibleToSetCellContents","JSON","stringify","setCellContents","prop","propToCol","cellValue","getCellValue","fillData","sourceRange","targetRange","_this13","withSheetId","range","engineSourceRange","start","getTopStartCorner","end","getBottomEndCorner","engineTargetRange","getFillRangeData","sourceData","initialLoad","includes","sourceDataArray","isItPossibleToReplaceSheetContent","valueHolder","ioMode","cellType","columnOrProp","dimensions","getSheetDimensions","width","height","getCellSerialized","changes","_this14","outOfBoundsChanges","batch","_ref9","_ref10","addHookOnce","outOfBoundsDependentCells","_ref11","_ref12","_this15","_ref13","_ref14","amount","isItPossibleToAddRows","isItPossibleToAddColumns","physicalRows","_this16","possible","every","isItPossibleToRemoveRows","physicalColumns","_this17","isItPossibleToRemoveColumns","addRows","addColumns","_this18","descendingPhysicalRows","sort","reverse","removeRows","_this19","descendingPhysicalColumns","removeColumns","parent","element","finalElementRowIndex","_element$__children","_this20","rowsData","__children","relativeRowIndex","colIndex","runHooks","namedExpressionName","addedSheetDisplayName","oldDisplayName","newDisplayName","removedSheetDisplayName"],"sources":["/home/rstorey/wwwdev/Blucktool/node_modules/handsontable/plugins/formulas/formulas.mjs"],"sourcesContent":["function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.array.reverse.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.weak-map.js\";\nimport \"core-js/modules/es.symbol.to-primitive.js\";\nimport \"core-js/modules/es.date.to-primitive.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.object.set-prototype-of.js\";\nimport \"core-js/modules/es.object.get-prototype-of.js\";\nimport \"core-js/modules/es.reflect.construct.js\";\nimport \"core-js/modules/es.reflect.get.js\";\nimport \"core-js/modules/es.object.get-own-property-descriptor.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.object.get-own-property-descriptors.js\";\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _get() { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); } }\nfunction _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }\nfunction _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } }\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\"); return _classApplyDescriptorGet(receiver, descriptor); }\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to \" + action + \" private field on non-instance\"); } return privateMap.get(receiver); }\nfunction _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\nimport { BasePlugin } from \"../base/index.mjs\";\nimport staticRegister from \"../../utils/staticRegister.mjs\";\nimport { error, warn } from \"../../helpers/console.mjs\";\nimport { isNumeric } from \"../../helpers/number.mjs\";\nimport { isDefined, isUndefined } from \"../../helpers/mixed.mjs\";\nimport { setupEngine, setupSheet, unregisterEngine, getRegisteredHotInstances } from \"./engine/register.mjs\";\nimport { isEscapedFormulaExpression, unescapeFormulaExpression } from \"./utils.mjs\";\nimport { getEngineSettingsWithOverrides } from \"./engine/settings.mjs\";\nimport { isArrayOfArrays } from \"../../helpers/data.mjs\";\nimport { toUpperCaseFirst } from \"../../helpers/string.mjs\";\nimport Hooks from \"../../pluginHooks.mjs\";\nexport var PLUGIN_KEY = 'formulas';\nexport var PLUGIN_PRIORITY = 260;\nvar ROW_MOVE_UNDO_REDO_NAME = 'row_move';\nHooks.getSingleton().register('afterNamedExpressionAdded');\nHooks.getSingleton().register('afterNamedExpressionRemoved');\nHooks.getSingleton().register('afterSheetAdded');\nHooks.getSingleton().register('afterSheetRemoved');\nHooks.getSingleton().register('afterSheetRenamed');\nHooks.getSingleton().register('afterFormulasValuesUpdate');\n\n// This function will be used for detecting changes coming from the `UndoRedo` plugin. This kind of change won't be\n// handled by whole body of listeners and therefore won't change undo/redo stack inside engine provided by HyperFormula.\n// HyperFormula's `undo` and `redo` methods will do it instead. Please keep in mind that undo/redo stacks inside\n// instances of Handsontable and HyperFormula should be synced (number of actions should be the same).\nvar isBlockedSource = function isBlockedSource(source) {\n  return source === 'UndoRedo.undo' || source === 'UndoRedo.redo' || source === 'auto';\n};\n\n/**\n * This plugin allows you to perform Excel-like calculations in your business applications. It does it by an\n * integration with our other product, [HyperFormula](https://github.com/handsontable/hyperformula/), which is a\n * powerful calculation engine with an extensive number of features.\n *\n * To test out HyperFormula, see [this guide](@/guides/formulas/formula-calculation.md#available-functions).\n *\n * @plugin Formulas\n * @class Formulas\n */\nvar _internalOperationPending = /*#__PURE__*/new WeakMap();\nvar _hotWasInitializedWithEmptyData = /*#__PURE__*/new WeakMap();\nvar _engineListeners = /*#__PURE__*/new WeakMap();\nexport var Formulas = /*#__PURE__*/function (_BasePlugin) {\n  _inherits(Formulas, _BasePlugin);\n  var _super = _createSuper(Formulas);\n  function Formulas() {\n    var _this;\n    _classCallCheck(this, Formulas);\n    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {\n      _args[_key] = arguments[_key];\n    }\n    _this = _super.call.apply(_super, [this].concat(_args));\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _internalOperationPending, {\n      writable: true,\n      value: false\n    });\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _hotWasInitializedWithEmptyData, {\n      writable: true,\n      value: false\n    });\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _engineListeners, {\n      writable: true,\n      value: [['valuesUpdated', function () {\n        var _this2;\n        return (_this2 = _this).onEngineValuesUpdated.apply(_this2, arguments);\n      }], ['namedExpressionAdded', function () {\n        var _this3;\n        return (_this3 = _this).onEngineNamedExpressionsAdded.apply(_this3, arguments);\n      }], ['namedExpressionRemoved', function () {\n        var _this4;\n        return (_this4 = _this).onEngineNamedExpressionsRemoved.apply(_this4, arguments);\n      }], ['sheetAdded', function () {\n        var _this5;\n        return (_this5 = _this).onEngineSheetAdded.apply(_this5, arguments);\n      }], ['sheetRenamed', function () {\n        var _this6;\n        return (_this6 = _this).onEngineSheetRenamed.apply(_this6, arguments);\n      }], ['sheetRemoved', function () {\n        var _this7;\n        return (_this7 = _this).onEngineSheetRemoved.apply(_this7, arguments);\n      }]]\n    });\n    _defineProperty(_assertThisInitialized(_this), \"staticRegister\", staticRegister('formulas'));\n    _defineProperty(_assertThisInitialized(_this), \"engine\", null);\n    _defineProperty(_assertThisInitialized(_this), \"sheetName\", null);\n    return _this;\n  }\n  _createClass(Formulas, [{\n    key: \"sheetId\",\n    get:\n    /**\n     * HyperFormula's sheet id.\n     *\n     * @type {number|null}\n     */\n    function get() {\n      return this.sheetName === null ? null : this.engine.getSheetId(this.sheetName);\n    }\n\n    /**\n     * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n     * hook and if it returns `true` then the {@link Formulas#enablePlugin} method is called.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isEnabled\",\n    value: function isEnabled() {\n      /* eslint-disable no-unneeded-ternary */\n      return this.hot.getSettings()[PLUGIN_KEY] ? true : false;\n    }\n\n    /**\n     * Enables the plugin functionality for this Handsontable instance.\n     */\n  }, {\n    key: \"enablePlugin\",\n    value: function enablePlugin() {\n      var _setupEngine,\n        _this8 = this;\n      if (this.enabled) {\n        return;\n      }\n      this.engine = (_setupEngine = setupEngine(this.hot)) !== null && _setupEngine !== void 0 ? _setupEngine : this.engine;\n      if (!this.engine) {\n        warn('Missing the required `engine` key in the Formulas settings. Please fill it with either an' + ' engine class or an engine instance.');\n        return;\n      }\n\n      // Useful for disabling -> enabling the plugin using `updateSettings` or the API.\n      if (this.sheetName !== null && !this.engine.doesSheetExist(this.sheetName)) {\n        var newSheetName = this.addSheet(this.sheetName, this.hot.getSourceDataArray());\n        if (newSheetName !== false) {\n          this.sheetName = newSheetName;\n        }\n      }\n      this.addHook('beforeLoadData', function () {\n        return _this8.onBeforeLoadData.apply(_this8, arguments);\n      });\n      this.addHook('afterLoadData', function () {\n        return _this8.onAfterLoadData.apply(_this8, arguments);\n      });\n\n      // The `updateData` hooks utilize the same logic as the `loadData` hooks.\n      this.addHook('beforeUpdateData', function () {\n        return _this8.onBeforeLoadData.apply(_this8, arguments);\n      });\n      this.addHook('afterUpdateData', function () {\n        return _this8.onAfterLoadData.apply(_this8, arguments);\n      });\n      this.addHook('modifyData', function () {\n        return _this8.onModifyData.apply(_this8, arguments);\n      });\n      this.addHook('modifySourceData', function () {\n        return _this8.onModifySourceData.apply(_this8, arguments);\n      });\n      this.addHook('beforeValidate', function () {\n        return _this8.onBeforeValidate.apply(_this8, arguments);\n      });\n      this.addHook('afterSetSourceDataAtCell', function () {\n        return _this8.onAfterSetSourceDataAtCell.apply(_this8, arguments);\n      });\n      this.addHook('afterSetDataAtCell', function () {\n        return _this8.onAfterSetDataAtCell.apply(_this8, arguments);\n      });\n      this.addHook('afterSetDataAtRowProp', function () {\n        return _this8.onAfterSetDataAtCell.apply(_this8, arguments);\n      });\n      this.addHook('beforeCreateRow', function () {\n        return _this8.onBeforeCreateRow.apply(_this8, arguments);\n      });\n      this.addHook('beforeCreateCol', function () {\n        return _this8.onBeforeCreateCol.apply(_this8, arguments);\n      });\n      this.addHook('afterCreateRow', function () {\n        return _this8.onAfterCreateRow.apply(_this8, arguments);\n      });\n      this.addHook('afterCreateCol', function () {\n        return _this8.onAfterCreateCol.apply(_this8, arguments);\n      });\n      this.addHook('beforeRemoveRow', function () {\n        return _this8.onBeforeRemoveRow.apply(_this8, arguments);\n      });\n      this.addHook('beforeRemoveCol', function () {\n        return _this8.onBeforeRemoveCol.apply(_this8, arguments);\n      });\n      this.addHook('afterRemoveRow', function () {\n        return _this8.onAfterRemoveRow.apply(_this8, arguments);\n      });\n      this.addHook('afterRemoveCol', function () {\n        return _this8.onAfterRemoveCol.apply(_this8, arguments);\n      });\n\n      // Handling undo actions on data just using HyperFormula's UndoRedo mechanism\n      this.addHook('beforeUndo', function (action) {\n        // TODO: Move action isn't handled by HyperFormula.\n        if ((action === null || action === void 0 ? void 0 : action.actionType) === ROW_MOVE_UNDO_REDO_NAME) {\n          return;\n        }\n        _this8.engine.undo();\n      });\n\n      // Handling redo actions on data just using HyperFormula's UndoRedo mechanism\n      this.addHook('beforeRedo', function (action) {\n        // TODO: Move action isn't handled by HyperFormula.\n        if ((action === null || action === void 0 ? void 0 : action.actionType) === ROW_MOVE_UNDO_REDO_NAME) {\n          return;\n        }\n        _this8.engine.redo();\n      });\n      this.addHook('afterDetachChild', function () {\n        return _this8.onAfterDetachChild.apply(_this8, arguments);\n      });\n      this.addHook('beforeAutofill', function () {\n        return _this8.onBeforeAutofill.apply(_this8, arguments);\n      });\n      _classPrivateFieldGet(this, _engineListeners).forEach(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n          eventName = _ref2[0],\n          listener = _ref2[1];\n        return _this8.engine.on(eventName, listener);\n      });\n      _get(_getPrototypeOf(Formulas.prototype), \"enablePlugin\", this).call(this);\n    }\n\n    /**\n     * Disables the plugin functionality for this Handsontable instance.\n     */\n  }, {\n    key: \"disablePlugin\",\n    value: function disablePlugin() {\n      var _this9 = this;\n      _classPrivateFieldGet(this, _engineListeners).forEach(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n          eventName = _ref4[0],\n          listener = _ref4[1];\n        return _this9.engine.off(eventName, listener);\n      });\n      unregisterEngine(this.engine, this.hot);\n      this.engine = null;\n      _get(_getPrototypeOf(Formulas.prototype), \"disablePlugin\", this).call(this);\n    }\n\n    /**\n     * Triggered on `updateSettings`.\n     *\n     * @private\n     * @param {object} newSettings New set of settings passed to the `updateSettings` method.\n     */\n  }, {\n    key: \"updatePlugin\",\n    value: function updatePlugin(newSettings) {\n      this.engine.updateConfig(getEngineSettingsWithOverrides(this.hot.getSettings()));\n      var pluginSettings = this.hot.getSettings()[PLUGIN_KEY];\n      if (isDefined(pluginSettings) && isDefined(pluginSettings.sheetName) && pluginSettings.sheetName !== this.sheetName) {\n        this.switchSheet(pluginSettings.sheetName);\n      }\n\n      // If no data was passed to the `updateSettings` method and no sheet is connected to the instance -> create a\n      // new sheet using the currently used data. Otherwise, it will be handled by the `afterLoadData` call.\n      if (!newSettings.data && this.sheetName === null) {\n        var sheetName = this.hot.getSettings()[PLUGIN_KEY].sheetName;\n        if (sheetName && this.engine.doesSheetExist(sheetName)) {\n          this.switchSheet(this.sheetName);\n        } else {\n          this.sheetName = this.addSheet(sheetName !== null && sheetName !== void 0 ? sheetName : void 0, this.hot.getSourceDataArray());\n        }\n      }\n      _get(_getPrototypeOf(Formulas.prototype), \"updatePlugin\", this).call(this, newSettings);\n    }\n\n    /**\n     * Destroys the plugin instance.\n     */\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _this10 = this;\n      _classPrivateFieldGet(this, _engineListeners).forEach(function (_ref5) {\n        var _this10$engine;\n        var _ref6 = _slicedToArray(_ref5, 2),\n          eventName = _ref6[0],\n          listener = _ref6[1];\n        return (_this10$engine = _this10.engine) === null || _this10$engine === void 0 ? void 0 : _this10$engine.off(eventName, listener);\n      });\n      _classPrivateFieldSet(this, _engineListeners, null);\n      unregisterEngine(this.engine, this.hot);\n      this.engine = null;\n      _get(_getPrototypeOf(Formulas.prototype), \"destroy\", this).call(this);\n    }\n\n    /**\n     * Helper function for `toPhysicalRowPosition` and `toPhysicalColumnPosition`.\n     *\n     * @private\n     * @param {number} visualIndex Visual entry index.\n     * @param {number} physicalIndex Physical entry index.\n     * @param {number} entriesCount Visual entries count.\n     * @param {number} sourceEntriesCount Source entries count.\n     * @param {boolean} contained `true` if it should return only indexes within boundaries of the table (basically\n     * `toPhysical` alias.\n     * @returns {*}\n     */\n  }, {\n    key: \"getPhysicalIndexPosition\",\n    value: function getPhysicalIndexPosition(visualIndex, physicalIndex, entriesCount, sourceEntriesCount, contained) {\n      if (!contained) {\n        if (visualIndex >= entriesCount) {\n          return sourceEntriesCount + (visualIndex - entriesCount);\n        }\n      }\n      return physicalIndex;\n    }\n\n    /**\n     * Returns the physical row index. The difference between this and Core's `toPhysical` is that it doesn't return\n     * `null` on rows with indexes higher than the number of rows.\n     *\n     * @private\n     * @param {number} row Visual row index.\n     * @param {boolean} [contained] `true` if it should return only indexes within boundaries of the table (basically\n     * `toPhysical` alias.\n     * @returns {number} The physical row index.\n     */\n  }, {\n    key: \"toPhysicalRowPosition\",\n    value: function toPhysicalRowPosition(row) {\n      var contained = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return this.getPhysicalIndexPosition(row, this.hot.toPhysicalRow(row), this.hot.countRows(), this.hot.countSourceRows(), contained);\n    }\n\n    /**\n     * Returns the physical column index. The difference between this and Core's `toPhysical` is that it doesn't return\n     * `null` on columns with indexes higher than the number of columns.\n     *\n     * @private\n     * @param {number} column Visual column index.\n     * @param {boolean} [contained] `true` if it should return only indexes within boundaries of the table (basically\n     * `toPhysical` alias.\n     * @returns {number} The physical column index.\n     */\n  }, {\n    key: \"toPhysicalColumnPosition\",\n    value: function toPhysicalColumnPosition(column) {\n      var contained = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return this.getPhysicalIndexPosition(column, this.hot.toPhysicalColumn(column), this.hot.countCols(), this.hot.countSourceCols(), contained);\n    }\n\n    /**\n     * Add a sheet to the shared HyperFormula instance.\n     *\n     * @param {string|null} [sheetName] The new sheet name. If not provided (or a null is passed), will be\n     * auto-generated by HyperFormula.\n     * @param {Array} [sheetData] Data passed to the shared HyperFormula instance. Has to be declared as an array of\n     * arrays - array of objects is not supported in this scenario.\n     * @returns {boolean|string} `false` if the data format is unusable or it is impossible to add a new sheet to the\n     * engine, the created sheet name otherwise.\n     */\n  }, {\n    key: \"addSheet\",\n    value: function addSheet(sheetName, sheetData) {\n      if (isDefined(sheetData) && !isArrayOfArrays(sheetData)) {\n        warn('The provided data should be an array of arrays.');\n        return false;\n      }\n      if (sheetName !== void 0 && sheetName !== null && this.engine.doesSheetExist(sheetName)) {\n        warn('Sheet with the provided name already exists.');\n        return false;\n      }\n      try {\n        var actualSheetName = this.engine.addSheet(sheetName !== null && sheetName !== void 0 ? sheetName : void 0);\n        if (sheetData) {\n          this.engine.setSheetContent(this.engine.getSheetId(actualSheetName), sheetData);\n        }\n        return actualSheetName;\n      } catch (e) {\n        warn(e.message);\n        return false;\n      }\n    }\n\n    /**\n     * Switch the sheet used as data in the Handsontable instance (it loads the data from the shared HyperFormula\n     * instance).\n     *\n     * @param {string} sheetName Sheet name used in the shared HyperFormula instance.\n     */\n  }, {\n    key: \"switchSheet\",\n    value: function switchSheet(sheetName) {\n      if (!this.engine.doesSheetExist(sheetName)) {\n        error(\"The sheet named `\".concat(sheetName, \"` does not exist, switch aborted.\"));\n        return;\n      }\n      this.sheetName = sheetName;\n      var serialized = this.engine.getSheetSerialized(this.sheetId);\n      if (serialized.length > 0) {\n        this.hot.loadData(serialized, \"\".concat(toUpperCaseFirst(PLUGIN_KEY), \".switchSheet\"));\n      }\n    }\n\n    /**\n     * Get the cell type under specified visual coordinates.\n     *\n     * @param {number} row Visual row index.\n     * @param {number} column Visual column index.\n     * @param {number} [sheet] The target sheet id, defaults to the current sheet.\n     * @returns {string} Possible values: 'FORMULA' | 'VALUE' | 'ARRAYFORMULA' | 'EMPTY'.\n     */\n  }, {\n    key: \"getCellType\",\n    value: function getCellType(row, column) {\n      var sheet = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.sheetId;\n      var physicalRow = this.hot.toPhysicalRow(row);\n      var physicalColumn = this.hot.toPhysicalColumn(column);\n      if (physicalRow !== null && physicalColumn !== null) {\n        return this.engine.getCellType({\n          sheet: sheet,\n          row: physicalRow,\n          col: physicalColumn\n        });\n      } else {\n        // Should return `EMPTY` when out of bounds (according to the test cases).\n        return 'EMPTY';\n      }\n    }\n\n    /**\n     * Returns `true` if under specified visual coordinates is formula.\n     *\n     * @param {number} row Visual row index.\n     * @param {number} column Visual column index.\n     * @param {number} [sheet] The target sheet id, defaults to the current sheet.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isFormulaCellType\",\n    value: function isFormulaCellType(row, column) {\n      var sheet = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.sheetId;\n      var physicalRow = this.hot.toPhysicalRow(row);\n      var physicalColumn = this.hot.toPhysicalColumn(column);\n      if (physicalRow === null || physicalColumn === null) {\n        return false;\n      }\n      return this.engine.doesCellHaveFormula({\n        sheet: sheet,\n        row: physicalRow,\n        col: physicalColumn\n      });\n    }\n\n    /**\n     * Renders dependent sheets (handsontable instances) based on the changes - list of the\n     * recalculated dependent cells.\n     *\n     * @private\n     * @param {object[]} dependentCells The values and location of applied changes within HF engine.\n     * @param {boolean} [renderSelf] `true` if it's supposed to render itself, `false` otherwise.\n     */\n  }, {\n    key: \"renderDependentSheets\",\n    value: function renderDependentSheets(dependentCells) {\n      var _this11 = this;\n      var renderSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var affectedSheetIds = new Set();\n      dependentCells.forEach(function (change) {\n        var _change$address;\n        // For the Named expression the address is empty, hence the `sheetId` is undefined.\n        var sheetId = change === null || change === void 0 ? void 0 : (_change$address = change.address) === null || _change$address === void 0 ? void 0 : _change$address.sheet;\n        if (sheetId !== void 0) {\n          if (!affectedSheetIds.has(sheetId)) {\n            affectedSheetIds.add(sheetId);\n          }\n        }\n      });\n      getRegisteredHotInstances(this.engine).forEach(function (relatedHot, sheetId) {\n        if ((renderSelf || sheetId !== _this11.sheetId) && affectedSheetIds.has(sheetId)) {\n          var _relatedHot$view;\n          relatedHot.render();\n          (_relatedHot$view = relatedHot.view) === null || _relatedHot$view === void 0 ? void 0 : _relatedHot$view.adjustElementsSize();\n        }\n      });\n    }\n\n    /**\n     * Validates dependent cells based on the cells that are modified by the change.\n     *\n     * @private\n     * @param {object[]} dependentCells The values and location of applied changes within HF engine.\n     * @param {object[]} [changedCells] The values and location of applied changes by developer (through API or UI).\n     */\n  }, {\n    key: \"validateDependentCells\",\n    value: function validateDependentCells(dependentCells) {\n      var _this12 = this;\n      var changedCells = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var stringifyAddress = function stringifyAddress(change) {\n        var _change$address2;\n        var _ref7 = (_change$address2 = change === null || change === void 0 ? void 0 : change.address) !== null && _change$address2 !== void 0 ? _change$address2 : {},\n          row = _ref7.row,\n          col = _ref7.col,\n          sheet = _ref7.sheet;\n        return isDefined(sheet) ? \"\".concat(sheet, \":\").concat(row, \"x\").concat(col) : '';\n      };\n      var changedCellsSet = new Set(changedCells.map(function (change) {\n        return stringifyAddress(change);\n      }));\n      dependentCells.forEach(function (change) {\n        var _change$address3, _change$address4;\n        var _ref8 = (_change$address3 = change.address) !== null && _change$address3 !== void 0 ? _change$address3 : {},\n          row = _ref8.row,\n          col = _ref8.col;\n        var visualRow = isDefined(row) ? _this12.hot.toVisualRow(row) : null;\n        var visualColumn = isDefined(col) ? _this12.hot.toVisualColumn(col) : null;\n\n        // Don't try to validate cells outside of the visual part of the table.\n        if (visualRow === null || visualColumn === null) {\n          return;\n        }\n\n        // For the Named expression the address is empty, hence the `sheetId` is undefined.\n        var sheetId = change === null || change === void 0 ? void 0 : (_change$address4 = change.address) === null || _change$address4 === void 0 ? void 0 : _change$address4.sheet;\n        var addressId = stringifyAddress(change);\n\n        // Validate the cells that depend on the calculated formulas. Skip that cells\n        // where the user directly changes the values - the Core triggers those validators.\n        if (sheetId !== void 0 && !changedCellsSet.has(addressId)) {\n          var boundHot = getRegisteredHotInstances(_this12.engine).get(sheetId);\n\n          // if `sheetId` is not bound to any Handsontable instance, skip the validation process\n          if (!boundHot) {\n            return;\n          }\n\n          // It will just re-render certain cell when necessary.\n          boundHot.validateCell(boundHot.getDataAtCell(visualRow, visualColumn), boundHot.getCellMeta(visualRow, visualColumn), function () {});\n        }\n      });\n    }\n\n    /**\n     * Sync a change from the change-related hooks with the engine.\n     *\n     * @private\n     * @param {number} row Visual row index.\n     * @param {number} column Visual column index.\n     * @param {Handsontable.CellValue} newValue New value.\n     * @returns {Array} Array of changes exported from the engine.\n     */\n  }, {\n    key: \"syncChangeWithEngine\",\n    value: function syncChangeWithEngine(row, column, newValue) {\n      var address = {\n        row: this.toPhysicalRowPosition(row),\n        col: this.toPhysicalColumnPosition(column),\n        sheet: this.sheetId\n      };\n      if (!this.engine.isItPossibleToSetCellContents(address)) {\n        warn(\"Not possible to set cell data at \".concat(JSON.stringify(address)));\n        return;\n      }\n      return this.engine.setCellContents(address, newValue);\n    }\n\n    /**\n     * The hook allows to translate the formula value to calculated value before it goes to the\n     * validator function.\n     *\n     * @private\n     * @param {*} value The cell value to validate.\n     * @param {number} visualRow The visual row index.\n     * @param {number|string} prop The visual column index or property name of the column.\n     * @returns {*} Returns value to validate.\n     */\n  }, {\n    key: \"onBeforeValidate\",\n    value: function onBeforeValidate(value, visualRow, prop) {\n      var visualColumn = this.hot.propToCol(prop);\n      if (this.isFormulaCellType(visualRow, visualColumn)) {\n        var address = {\n          row: this.hot.toPhysicalRow(visualRow),\n          col: this.hot.toPhysicalColumn(visualColumn),\n          sheet: this.sheetId\n        };\n        var cellValue = this.engine.getCellValue(address);\n\n        // If `cellValue` is an object it is expected to be an error\n        return _typeof(cellValue) === 'object' && cellValue !== null ? cellValue.value : cellValue;\n      }\n      return value;\n    }\n\n    /**\n     * `onBeforeAutofill` hook callback.\n     *\n     * @private\n     * @param {Array[]} fillData The data that was used to fill the `targetRange`. If `beforeAutofill` was used\n     * and returned `[[]]`, this will be the same object that was returned from `beforeAutofill`.\n     * @param {CellRange} sourceRange The range values will be filled from.\n     * @param {CellRange} targetRange The range new values will be filled into.\n     * @returns {boolean|*}\n     */\n  }, {\n    key: \"onBeforeAutofill\",\n    value: function onBeforeAutofill(fillData, sourceRange, targetRange) {\n      var _this13 = this;\n      var withSheetId = function withSheetId(range) {\n        return _objectSpread(_objectSpread({}, range), {}, {\n          sheet: _this13.sheetId\n        });\n      };\n      var engineSourceRange = {\n        start: withSheetId(sourceRange.getTopStartCorner()),\n        end: withSheetId(sourceRange.getBottomEndCorner())\n      };\n      var engineTargetRange = {\n        start: withSheetId(targetRange.getTopStartCorner()),\n        end: withSheetId(targetRange.getBottomEndCorner())\n      };\n\n      // Blocks the autofill operation if HyperFormula says that at least one of\n      // the underlying cell's contents cannot be set.\n      if (this.engine.isItPossibleToSetCellContents(engineTargetRange) === false) {\n        return false;\n      }\n      return this.engine.getFillRangeData(engineSourceRange, engineTargetRange);\n    }\n\n    /**\n     * `beforeLoadData` hook callback.\n     *\n     * @param {Array} sourceData Array of arrays or array of objects containing data.\n     * @param {boolean} initialLoad Flag that determines whether the data has been loaded during the initialization.\n     * @param {string} [source] Source of the call.\n     * @private\n     */\n  }, {\n    key: \"onBeforeLoadData\",\n    value: function onBeforeLoadData(sourceData, initialLoad) {\n      var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      if (source.includes(toUpperCaseFirst(PLUGIN_KEY))) {\n        return;\n      }\n\n      // This flag needs to be defined, because not passing data to HOT results in HOT auto-generating a `null`-filled\n      // initial dataset.\n      _classPrivateFieldSet(this, _hotWasInitializedWithEmptyData, isUndefined(this.hot.getSettings().data));\n    }\n\n    /**\n     * `afterLoadData` hook callback.\n     *\n     * @param {Array} sourceData Array of arrays or array of objects containing data.\n     * @param {boolean} initialLoad Flag that determines whether the data has been loaded during the initialization.\n     * @param {string} [source] Source of the call.\n     * @private\n     */\n  }, {\n    key: \"onAfterLoadData\",\n    value: function onAfterLoadData(sourceData, initialLoad) {\n      var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      if (source.includes(toUpperCaseFirst(PLUGIN_KEY))) {\n        return;\n      }\n      this.sheetName = setupSheet(this.engine, this.hot.getSettings()[PLUGIN_KEY].sheetName);\n      if (!_classPrivateFieldGet(this, _hotWasInitializedWithEmptyData)) {\n        var sourceDataArray = this.hot.getSourceDataArray();\n        if (this.engine.isItPossibleToReplaceSheetContent(this.sheetId, sourceDataArray)) {\n          _classPrivateFieldSet(this, _internalOperationPending, true);\n          var dependentCells = this.engine.setSheetContent(this.sheetId, this.hot.getSourceDataArray());\n          this.renderDependentSheets(dependentCells);\n          _classPrivateFieldSet(this, _internalOperationPending, false);\n        }\n      } else {\n        this.switchSheet(this.sheetName);\n      }\n    }\n\n    /**\n     * `modifyData` hook callback.\n     *\n     * @private\n     * @param {number} row Physical row height.\n     * @param {number} column Physical column index.\n     * @param {object} valueHolder Object which contains original value which can be modified by overwriting `.value`\n     *   property.\n     * @param {string} ioMode String which indicates for what operation hook is fired (`get` or `set`).\n     */\n  }, {\n    key: \"onModifyData\",\n    value: function onModifyData(row, column, valueHolder, ioMode) {\n      if (ioMode !== 'get' || _classPrivateFieldGet(this, _internalOperationPending) || this.sheetName === null || !this.engine.doesSheetExist(this.sheetName)) {\n        return;\n      }\n      var visualRow = this.hot.toVisualRow(row);\n\n      // `column` is here as visual index because of inconsistencies related to hook execution in `src/dataMap`.\n      var isFormulaCellType = this.isFormulaCellType(visualRow, column);\n      if (!isFormulaCellType) {\n        var cellType = this.getCellType(visualRow, column);\n        if (cellType !== 'ARRAY') {\n          if (isEscapedFormulaExpression(valueHolder.value)) {\n            valueHolder.value = unescapeFormulaExpression(valueHolder.value);\n          }\n          return;\n        }\n      }\n\n      // `toPhysicalColumn` is here because of inconsistencies related to hook execution in `DataMap`.\n      var address = {\n        row: row,\n        col: this.toPhysicalColumnPosition(column),\n        sheet: this.sheetId\n      };\n      var cellValue = this.engine.getCellValue(address);\n\n      // If `cellValue` is an object it is expected to be an error\n      var value = _typeof(cellValue) === 'object' && cellValue !== null ? cellValue.value : cellValue;\n      valueHolder.value = value;\n    }\n\n    /**\n     * `modifySourceData` hook callback.\n     *\n     * @private\n     * @param {number} row Physical row index.\n     * @param {number|string} columnOrProp Physical column index or prop.\n     * @param {object} valueHolder Object which contains original value which can be modified by overwriting `.value`\n     *   property.\n     * @param {string} ioMode String which indicates for what operation hook is fired (`get` or `set`).\n     */\n  }, {\n    key: \"onModifySourceData\",\n    value: function onModifySourceData(row, columnOrProp, valueHolder, ioMode) {\n      if (ioMode !== 'get' || _classPrivateFieldGet(this, _internalOperationPending) || this.sheetName === null || !this.engine.doesSheetExist(this.sheetName)) {\n        return;\n      }\n      var visualRow = this.hot.toVisualRow(row);\n      var visualColumn = this.hot.propToCol(columnOrProp);\n\n      // `column` is here as visual index because of inconsistencies related to hook execution in `src/dataMap`.\n      var isFormulaCellType = this.isFormulaCellType(visualRow, visualColumn);\n      if (!isFormulaCellType) {\n        var cellType = this.getCellType(visualRow, visualColumn);\n        if (cellType !== 'ARRAY') {\n          return;\n        }\n      }\n      var dimensions = this.engine.getSheetDimensions(this.engine.getSheetId(this.sheetName));\n\n      // Don't actually change the source data if HyperFormula is not\n      // initialized yet. This is done to allow the `afterLoadData` hook to\n      // load the existing source data with `Handsontable#getSourceDataArray`\n      // properly.\n      if (dimensions.width === 0 && dimensions.height === 0) {\n        return;\n      }\n      var address = {\n        row: row,\n        // Workaround for inconsistencies in `src/dataSource.js`\n        col: this.toPhysicalColumnPosition(visualColumn),\n        sheet: this.sheetId\n      };\n      valueHolder.value = this.engine.getCellSerialized(address);\n    }\n\n    /**\n     * `onAfterSetDataAtCell` hook callback.\n     *\n     * @private\n     * @param {Array[]} changes An array of changes in format [[row, prop, oldValue, value], ...].\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsontable-hooks}).\n     */\n  }, {\n    key: \"onAfterSetDataAtCell\",\n    value: function onAfterSetDataAtCell(changes, source) {\n      var _this14 = this;\n      if (isBlockedSource(source)) {\n        return;\n      }\n      var outOfBoundsChanges = [];\n      var changedCells = [];\n      var dependentCells = this.engine.batch(function () {\n        changes.forEach(function (_ref9) {\n          var _ref10 = _slicedToArray(_ref9, 4),\n            row = _ref10[0],\n            prop = _ref10[1],\n            newValue = _ref10[3];\n          var column = _this14.hot.propToCol(prop);\n          var physicalRow = _this14.hot.toPhysicalRow(row);\n          var physicalColumn = _this14.hot.toPhysicalColumn(column);\n          var address = {\n            row: physicalRow,\n            col: physicalColumn,\n            sheet: _this14.sheetId\n          };\n          if (physicalRow !== null && physicalColumn !== null) {\n            _this14.syncChangeWithEngine(row, column, newValue);\n          } else {\n            outOfBoundsChanges.push([row, column, newValue]);\n          }\n          changedCells.push({\n            address: address\n          });\n        });\n      });\n      if (outOfBoundsChanges.length) {\n        // Workaround for rows/columns being created two times (by HOT and the engine).\n        // (unfortunately, this requires an extra re-render)\n        this.hot.addHookOnce('afterChange', function () {\n          var outOfBoundsDependentCells = _this14.engine.batch(function () {\n            outOfBoundsChanges.forEach(function (_ref11) {\n              var _ref12 = _slicedToArray(_ref11, 3),\n                row = _ref12[0],\n                column = _ref12[1],\n                newValue = _ref12[2];\n              _this14.syncChangeWithEngine(row, column, newValue);\n            });\n          });\n          _this14.renderDependentSheets(outOfBoundsDependentCells, true);\n        });\n      }\n      this.renderDependentSheets(dependentCells);\n      this.validateDependentCells(dependentCells, changedCells);\n    }\n\n    /**\n     * `onAfterSetSourceDataAtCell` hook callback.\n     *\n     * @private\n     * @param {Array[]} changes An array of changes in format [[row, column, oldValue, value], ...].\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsontable-hooks}).\n     */\n  }, {\n    key: \"onAfterSetSourceDataAtCell\",\n    value: function onAfterSetSourceDataAtCell(changes, source) {\n      var _this15 = this;\n      if (isBlockedSource(source)) {\n        return;\n      }\n      var dependentCells = [];\n      var changedCells = [];\n      changes.forEach(function (_ref13) {\n        var _ref14 = _slicedToArray(_ref13, 4),\n          row = _ref14[0],\n          prop = _ref14[1],\n          newValue = _ref14[3];\n        var column = _this15.hot.propToCol(prop);\n        if (!isNumeric(column)) {\n          return;\n        }\n        var address = {\n          row: row,\n          col: _this15.toPhysicalColumnPosition(column),\n          sheet: _this15.sheetId\n        };\n        if (!_this15.engine.isItPossibleToSetCellContents(address)) {\n          warn(\"Not possible to set source cell data at \".concat(JSON.stringify(address)));\n          return;\n        }\n        changedCells.push({\n          address: address\n        });\n        dependentCells.push.apply(dependentCells, _toConsumableArray(_this15.engine.setCellContents(address, newValue)));\n      });\n      this.renderDependentSheets(dependentCells);\n      this.validateDependentCells(dependentCells, changedCells);\n    }\n\n    /**\n     * `beforeCreateRow` hook callback.\n     *\n     * @private\n     * @param {number} row Represents the visual index of first newly created row in the data source array.\n     * @param {number} amount Number of newly created rows in the data source array.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n  }, {\n    key: \"onBeforeCreateRow\",\n    value: function onBeforeCreateRow(row, amount) {\n      if (this.sheetId === null || !this.engine.doesSheetExist(this.sheetName) || !this.engine.isItPossibleToAddRows(this.sheetId, [this.toPhysicalRowPosition(row), amount])) {\n        return false;\n      }\n    }\n\n    /**\n     * `beforeCreateCol` hook callback.\n     *\n     * @private\n     * @param {number} col Represents the visual index of first newly created column in the data source.\n     * @param {number} amount Number of newly created columns in the data source.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n  }, {\n    key: \"onBeforeCreateCol\",\n    value: function onBeforeCreateCol(col, amount) {\n      if (this.sheetId === null || !this.engine.doesSheetExist(this.sheetName) || !this.engine.isItPossibleToAddColumns(this.sheetId, [this.toPhysicalColumnPosition(col), amount])) {\n        return false;\n      }\n    }\n\n    /**\n     * `beforeRemoveRow` hook callback.\n     *\n     * @private\n     * @param {number} row Visual index of starter row.\n     * @param {number} amount Amount of rows to be removed.\n     * @param {number[]} physicalRows An array of physical rows removed from the data source.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n  }, {\n    key: \"onBeforeRemoveRow\",\n    value: function onBeforeRemoveRow(row, amount, physicalRows) {\n      var _this16 = this;\n      var possible = physicalRows.every(function (physicalRow) {\n        return _this16.engine.isItPossibleToRemoveRows(_this16.sheetId, [physicalRow, 1]);\n      });\n      return possible === false ? false : void 0;\n    }\n\n    /**\n     * `beforeRemoveCol` hook callback.\n     *\n     * @private\n     * @param {number} col Visual index of starter column.\n     * @param {number} amount Amount of columns to be removed.\n     * @param {number[]} physicalColumns An array of physical columns removed from the data source.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n  }, {\n    key: \"onBeforeRemoveCol\",\n    value: function onBeforeRemoveCol(col, amount, physicalColumns) {\n      var _this17 = this;\n      var possible = physicalColumns.every(function (physicalColumn) {\n        return _this17.engine.isItPossibleToRemoveColumns(_this17.sheetId, [physicalColumn, 1]);\n      });\n      return possible === false ? false : void 0;\n    }\n\n    /**\n     * `afterCreateRow` hook callback.\n     *\n     * @private\n     * @param {number} row Represents the visual index of first newly created row in the data source array.\n     * @param {number} amount Number of newly created rows in the data source array.\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsontable-hooks}).\n     */\n  }, {\n    key: \"onAfterCreateRow\",\n    value: function onAfterCreateRow(row, amount, source) {\n      if (isBlockedSource(source)) {\n        return;\n      }\n      var changes = this.engine.addRows(this.sheetId, [this.toPhysicalRowPosition(row), amount]);\n      this.renderDependentSheets(changes);\n    }\n\n    /**\n     * `afterCreateCol` hook callback.\n     *\n     * @private\n     * @param {number} col Represents the visual index of first newly created column in the data source.\n     * @param {number} amount Number of newly created columns in the data source.\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsontable-hooks}).\n     */\n  }, {\n    key: \"onAfterCreateCol\",\n    value: function onAfterCreateCol(col, amount, source) {\n      if (isBlockedSource(source)) {\n        return;\n      }\n      var changes = this.engine.addColumns(this.sheetId, [this.toPhysicalColumnPosition(col), amount]);\n      this.renderDependentSheets(changes);\n    }\n\n    /**\n     * `afterRemoveRow` hook callback.\n     *\n     * @private\n     * @param {number} row Visual index of starter row.\n     * @param {number} amount An amount of removed rows.\n     * @param {number[]} physicalRows An array of physical rows removed from the data source.\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsontable-hooks}).\n     */\n  }, {\n    key: \"onAfterRemoveRow\",\n    value: function onAfterRemoveRow(row, amount, physicalRows, source) {\n      var _this18 = this;\n      if (isBlockedSource(source)) {\n        return;\n      }\n      var descendingPhysicalRows = physicalRows.sort().reverse();\n      var changes = this.engine.batch(function () {\n        descendingPhysicalRows.forEach(function (physicalRow) {\n          _this18.engine.removeRows(_this18.sheetId, [physicalRow, 1]);\n        });\n      });\n      this.renderDependentSheets(changes);\n    }\n\n    /**\n     * `afterRemoveCol` hook callback.\n     *\n     * @private\n     * @param {number} col Visual index of starter column.\n     * @param {number} amount An amount of removed columns.\n     * @param {number[]} physicalColumns An array of physical columns removed from the data source.\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link https://handsontable.com/docs/javascript-data-grid/events-and-hooks/#handsontable-hooks}).\n     */\n  }, {\n    key: \"onAfterRemoveCol\",\n    value: function onAfterRemoveCol(col, amount, physicalColumns, source) {\n      var _this19 = this;\n      if (isBlockedSource(source)) {\n        return;\n      }\n      var descendingPhysicalColumns = physicalColumns.sort().reverse();\n      var changes = this.engine.batch(function () {\n        descendingPhysicalColumns.forEach(function (physicalColumn) {\n          _this19.engine.removeColumns(_this19.sheetId, [physicalColumn, 1]);\n        });\n      });\n      this.renderDependentSheets(changes);\n    }\n\n    /**\n     * `afterDetachChild` hook callback.\n     * Used to sync the data of the rows detached in the Nested Rows plugin with the engine's dataset.\n     *\n     * @private\n     * @param {object} parent An object representing the parent from which the element was detached.\n     * @param {object} element The detached element.\n     * @param {number} finalElementRowIndex The final row index of the detached element.\n     */\n  }, {\n    key: \"onAfterDetachChild\",\n    value: function onAfterDetachChild(parent, element, finalElementRowIndex) {\n      var _element$__children,\n        _this20 = this;\n      _classPrivateFieldSet(this, _internalOperationPending, true);\n      var rowsData = this.hot.getSourceDataArray(finalElementRowIndex, 0, finalElementRowIndex + (((_element$__children = element.__children) === null || _element$__children === void 0 ? void 0 : _element$__children.length) || 0), this.hot.countSourceCols());\n      _classPrivateFieldSet(this, _internalOperationPending, false);\n      rowsData.forEach(function (row, relativeRowIndex) {\n        row.forEach(function (value, colIndex) {\n          _this20.engine.setCellContents({\n            col: colIndex,\n            row: finalElementRowIndex + relativeRowIndex,\n            sheet: _this20.sheetId\n          }, [[value]]);\n        });\n      });\n    }\n\n    /**\n     * Called when a value is updated in the engine.\n     *\n     * @private\n     * @fires Hooks#afterFormulasValuesUpdate\n     * @param {Array} changes The values and location of applied changes.\n     */\n  }, {\n    key: \"onEngineValuesUpdated\",\n    value: function onEngineValuesUpdated(changes) {\n      this.hot.runHooks('afterFormulasValuesUpdate', changes);\n    }\n\n    /**\n     * Called when a named expression is added to the engine instance.\n     *\n     * @private\n     * @fires Hooks#afterNamedExpressionAdded\n     * @param {string} namedExpressionName The name of the added expression.\n     * @param {Array} changes The values and location of applied changes.\n     */\n  }, {\n    key: \"onEngineNamedExpressionsAdded\",\n    value: function onEngineNamedExpressionsAdded(namedExpressionName, changes) {\n      this.hot.runHooks('afterNamedExpressionAdded', namedExpressionName, changes);\n    }\n\n    /**\n     * Called when a named expression is removed from the engine instance.\n     *\n     * @private\n     * @fires Hooks#afterNamedExpressionRemoved\n     * @param {string} namedExpressionName The name of the removed expression.\n     * @param {Array} changes The values and location of applied changes.\n     */\n  }, {\n    key: \"onEngineNamedExpressionsRemoved\",\n    value: function onEngineNamedExpressionsRemoved(namedExpressionName, changes) {\n      this.hot.runHooks('afterNamedExpressionRemoved', namedExpressionName, changes);\n    }\n\n    /**\n     * Called when a new sheet is added to the engine instance.\n     *\n     * @private\n     * @fires Hooks#afterSheetAdded\n     * @param {string} addedSheetDisplayName The name of the added sheet.\n     */\n  }, {\n    key: \"onEngineSheetAdded\",\n    value: function onEngineSheetAdded(addedSheetDisplayName) {\n      this.hot.runHooks('afterSheetAdded', addedSheetDisplayName);\n    }\n\n    /**\n     * Called when a sheet in the engine instance is renamed.\n     *\n     * @private\n     * @fires Hooks#afterSheetRenamed\n     * @param {string} oldDisplayName The old name of the sheet.\n     * @param {string} newDisplayName The new name of the sheet.\n     */\n  }, {\n    key: \"onEngineSheetRenamed\",\n    value: function onEngineSheetRenamed(oldDisplayName, newDisplayName) {\n      this.hot.runHooks('afterSheetRenamed', oldDisplayName, newDisplayName);\n    }\n\n    /**\n     * Called when a sheet is removed from the engine instance.\n     *\n     * @private\n     * @fires Hooks#afterSheetRemoved\n     * @param {string} removedSheetDisplayName The removed sheet name.\n     * @param {Array} changes The values and location of applied changes.\n     */\n  }, {\n    key: \"onEngineSheetRemoved\",\n    value: function onEngineSheetRemoved(removedSheetDisplayName, changes) {\n      this.hot.runHooks('afterSheetRemoved', removedSheetDisplayName, changes);\n    }\n  }], [{\n    key: \"PLUGIN_KEY\",\n    get: function get() {\n      return PLUGIN_KEY;\n    }\n  }, {\n    key: \"PLUGIN_PRIORITY\",\n    get: function get() {\n      return PLUGIN_PRIORITY;\n    }\n\n    /**\n     * Flag used to bypass hooks in internal operations.\n     *\n     * @private\n     * @type {boolean}\n     */\n  }]);\n  return Formulas;\n}(BasePlugin);"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}