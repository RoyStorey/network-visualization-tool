{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nvar _templateObject;\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _taggedTemplateLiteral(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nimport { isUndefined } from \"../../../helpers/mixed.mjs\";\nimport { warn } from \"../../../helpers/console.mjs\";\nimport { toSingleLine } from \"../../../helpers/templateLiteralTag.mjs\";\n/**\n * Helper class for the row-move-related operations.\n *\n * @private\n * @class RowMoveController\n */\nvar RowMoveController = /*#__PURE__*/function () {\n  function RowMoveController(plugin) {\n    _classCallCheck(this, RowMoveController);\n    /**\n     * Reference to the Nested Rows plugin instance.\n     *\n     * @type {NestedRows}\n     */\n    this.plugin = plugin;\n    /**\n     * Reference to the Handsontable instance.\n     *\n     * @type {Handsontable.Core}\n     */\n    this.hot = plugin.hot;\n    /**\n     * Reference to the Data Manager class instance.\n     *\n     * @type {DataManager}\n     */\n    this.dataManager = plugin.dataManager;\n    /**\n     * Reference to the Collapsing UI class instance.\n     *\n     * @type {CollapsingUI}\n     */\n    this.collapsingUI = plugin.collapsingUI;\n  }\n\n  /**\n   * `beforeRowMove` hook callback.\n   *\n   * @param {Array} rows Array of visual row indexes to be moved.\n   * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements\n   *   will be placed after the moving action. To check the visualization of the final index, please take a look at\n   *   [documentation](@/guides/rows/row-moving.md).\n   * @param {undefined|number} dropIndex Visual row index, being a drop index for the moved rows. Points to where we\n   *   are going to drop the moved elements. To check visualization of drop index please take a look at\n   *   [documentation](@/guides/rows/row-moving.md).\n   * @param {boolean} movePossible Indicates if it's possible to move rows to the desired position.\n   * @fires Hooks#afterRowMove\n   * @returns {boolean}\n   */\n  _createClass(RowMoveController, [{\n    key: \"onBeforeRowMove\",\n    value: function onBeforeRowMove(rows, finalIndex, dropIndex, movePossible) {\n      var _this = this;\n      var improperUsage = this.displayAPICompatibilityWarning({\n        rows: rows,\n        finalIndex: finalIndex,\n        dropIndex: dropIndex,\n        movePossible: movePossible\n      });\n      if (improperUsage) {\n        return false;\n      }\n      this.movedToCollapsed = false;\n      var dropToLastRow = dropIndex === this.hot.countRows();\n      var physicalDropIndex = dropToLastRow ? this.hot.countSourceRows() : this.dataManager.translateTrimmedRow(dropIndex);\n      var allowMove = true;\n      var physicalStartIndexes = rows.map(function (rowIndex) {\n        // Don't do the logic for the rest of the rows, as it's bound to fail anyway.\n        if (!allowMove) {\n          return false;\n        }\n        var physicalRowIndex = _this.dataManager.translateTrimmedRow(rowIndex);\n        allowMove = _this.shouldAllowMoving(physicalRowIndex, physicalDropIndex);\n        return physicalRowIndex;\n      });\n      var willDataChange = physicalStartIndexes.indexOf(physicalDropIndex) === -1;\n      if (!allowMove || !willDataChange) {\n        return false;\n      }\n      var baseParent = this.getBaseParent(physicalStartIndexes);\n      var targetParent = this.getTargetParent(dropToLastRow, physicalDropIndex);\n      var sameParent = baseParent === targetParent;\n      this.movedToCollapsed = this.collapsingUI.areChildrenCollapsed(targetParent);\n\n      // Stash the current state of collapsed rows\n      this.collapsingUI.collapsedRowsStash.stash();\n      this.shiftCollapsibleParentsLocations(physicalStartIndexes, physicalDropIndex, sameParent);\n      this.moveRows(physicalStartIndexes, physicalDropIndex, targetParent);\n      this.dataManager.rewriteCache();\n      this.moveCellsMeta(physicalStartIndexes, physicalDropIndex);\n      this.collapsingUI.collapsedRowsStash.applyStash(false);\n\n      // TODO: Trying to mock real work of the `ManualRowMove` plugin. It was blocked by returning `false` below.\n      this.hot.runHooks('afterRowMove', rows, finalIndex, dropIndex, movePossible, movePossible && this.isRowOrderChanged(rows, finalIndex));\n\n      // Not necessary - added to keep compatibility with other plugins (namely: columnSummary).\n      this.hot.render();\n      this.selectCells(rows, dropIndex);\n      return false;\n    }\n\n    /**\n     * Display a `dragRows`/`moveRows` method compatibility warning if needed.\n     *\n     * @param {object} beforeMoveRowHookArgs A set of arguments from the `beforeMoveRow` hook.\n     * @returns {boolean} `true` if is a result of an improper usage of the moving API.\n     */\n  }, {\n    key: \"displayAPICompatibilityWarning\",\n    value: function displayAPICompatibilityWarning(beforeMoveRowHookArgs) {\n      var rows = beforeMoveRowHookArgs.rows,\n        finalIndex = beforeMoveRowHookArgs.finalIndex,\n        dropIndex = beforeMoveRowHookArgs.dropIndex,\n        movePossible = beforeMoveRowHookArgs.movePossible;\n      var shouldTerminate = false;\n      if (isUndefined(dropIndex)) {\n        warn(toSingleLine(_templateObject || (_templateObject = _taggedTemplateLiteral([\"Since version 8.0.0 of the Handsontable the 'moveRows' method isn't used for moving rows \\n      when the NestedRows plugin is enabled. Please use the 'dragRows' method instead.\"], [\"Since version 8.0.0 of the Handsontable the 'moveRows' method isn't used for moving rows\\\\x20\\n      when the NestedRows plugin is enabled. Please use the 'dragRows' method instead.\"]))));\n\n        // TODO: Trying to mock real work of the `ManualRowMove` plugin. It was blocked by returning `false` below.\n        this.hot.runHooks('afterRowMove', rows, finalIndex, dropIndex, movePossible, false);\n        shouldTerminate = true;\n      }\n      return shouldTerminate;\n    }\n\n    /**\n     * Check if the moving action should be allowed.\n     *\n     * @param {number} physicalRowIndex Physical start row index.\n     * @param {number} physicalDropIndex Physical drop index.\n     * @returns {boolean} `true` if it should continue with the moving action.\n     */\n  }, {\n    key: \"shouldAllowMoving\",\n    value: function shouldAllowMoving(physicalRowIndex, physicalDropIndex) {\n      /*\n         We can't move rows when any of them is:\n         - a parent\n         - a top-level element\n         - is being moved to the top level\n         - is being moved to the position of any of the moved rows (not changing position)\n      */\n\n      return !(this.dataManager.isParent(physicalRowIndex) || this.dataManager.isRowHighestLevel(physicalRowIndex) || physicalRowIndex === physicalDropIndex || physicalDropIndex === 0);\n    }\n\n    /**\n     * Get the base row parent.\n     *\n     * @param {number} physicalStartIndexes Physical start row index.\n     * @returns {object|null} The base row parent.\n     */\n  }, {\n    key: \"getBaseParent\",\n    value: function getBaseParent(physicalStartIndexes) {\n      return this.dataManager.getRowParent(physicalStartIndexes[0]);\n    }\n\n    /**\n     * Get the target row parent.\n     *\n     * @param {boolean} dropToLastRow `true` if the row is moved to the last row of the table.\n     * @param {number} physicalDropIndex Physical drop row index.\n     * @returns {object|null} The target row parent.\n     */\n  }, {\n    key: \"getTargetParent\",\n    value: function getTargetParent(dropToLastRow, physicalDropIndex) {\n      var targetParent = this.dataManager.getRowParent(dropToLastRow ? physicalDropIndex - 1 : physicalDropIndex);\n\n      // If we try to move an element to the place of a top-level parent, snap the element to the previous top-level\n      // parent's children instead\n      if (targetParent === null || targetParent === void 0) {\n        targetParent = this.dataManager.getRowParent(physicalDropIndex - 1);\n      }\n      return targetParent;\n    }\n\n    /**\n     * Shift the cached collapsible rows position according to the move action.\n     *\n     * @param {number[]} physicalStartIndexes Physical start row indexes.\n     * @param {number} physicalDropIndex Physical drop index.\n     * @param {boolean} sameParent `true` if the row's being moved between siblings of the same parent.\n     */\n  }, {\n    key: \"shiftCollapsibleParentsLocations\",\n    value: function shiftCollapsibleParentsLocations(physicalStartIndexes, physicalDropIndex, sameParent) {\n      if (!sameParent) {\n        if (Math.max.apply(Math, _toConsumableArray(physicalStartIndexes)) <= physicalDropIndex) {\n          this.collapsingUI.collapsedRowsStash.shiftStash(physicalStartIndexes[0], physicalDropIndex, -1 * physicalStartIndexes.length);\n        } else {\n          this.collapsingUI.collapsedRowsStash.shiftStash(physicalDropIndex, physicalStartIndexes[0], physicalStartIndexes.length);\n        }\n      }\n    }\n\n    /**\n     * Move the rows at the provided coordinates.\n     *\n     * @param {number[]} physicalStartIndexes Physical indexes of the rows about to be moved.\n     * @param {number} physicalDropIndex Physical drop index.\n     * @param {object} targetParent Parent of the destination row.\n     */\n  }, {\n    key: \"moveRows\",\n    value: function moveRows(physicalStartIndexes, physicalDropIndex, targetParent) {\n      var _this2 = this;\n      var moveToLastChild = physicalDropIndex === this.dataManager.getRowIndex(targetParent) + this.dataManager.countChildren(targetParent) + 1;\n      this.hot.batchRender(function () {\n        physicalStartIndexes.forEach(function (physicalStartIndex) {\n          _this2.dataManager.moveRow(physicalStartIndex, physicalDropIndex, _this2.movedToCollapsed, moveToLastChild);\n        });\n      });\n    }\n\n    /**\n     * Move the cell meta for multiple rows.\n     *\n     * @param {number[]} baseIndexes Array of indexes for the rows being moved.\n     * @param {number} targetIndex Index of the destination of the move.\n     */\n  }, {\n    key: \"moveCellsMeta\",\n    value: function moveCellsMeta(baseIndexes, targetIndex) {\n      var _this3 = this,\n        _this$hot;\n      var rowsOfMeta = [];\n      var movingDown = Math.max.apply(Math, _toConsumableArray(baseIndexes)) < targetIndex;\n      baseIndexes.forEach(function (baseIndex) {\n        rowsOfMeta.push(_this3.hot.getCellMetaAtRow(baseIndex));\n      });\n      this.hot.spliceCellsMeta(baseIndexes[0], baseIndexes.length);\n      (_this$hot = this.hot).spliceCellsMeta.apply(_this$hot, [targetIndex - (movingDown ? rowsOfMeta.length : 0), 0].concat(rowsOfMeta));\n    }\n\n    /**\n     * Select cells after the move.\n     *\n     * @param {Array} rows Array of visual row indexes to be moved.\n     * @param {undefined|number} dropIndex Visual row index, being a drop index for the moved rows. Points to where we\n     *   are going to drop the moved elements. To check visualization of drop index please take a look at\n     *   [documentation](@/guides/rows/row-moving.md).\n     */\n  }, {\n    key: \"selectCells\",\n    value: function selectCells(rows, dropIndex) {\n      var rowsLen = rows.length;\n      var startRow = 0;\n      var endRow = 0;\n      var selection = null;\n      var lastColIndex = null;\n      if (this.movedToCollapsed) {\n        var physicalDropIndex = null;\n        if (rows[rowsLen - 1] < dropIndex) {\n          physicalDropIndex = this.dataManager.translateTrimmedRow(dropIndex - rowsLen);\n        } else {\n          physicalDropIndex = this.dataManager.translateTrimmedRow(dropIndex);\n        }\n        var parentObject = this.dataManager.getRowParent(physicalDropIndex === null ? this.hot.countSourceRows() - 1 : physicalDropIndex - 1);\n        var parentIndex = this.dataManager.getRowIndex(parentObject);\n        startRow = this.dataManager.untranslateTrimmedRow(parentIndex);\n        endRow = startRow;\n      } else if (rows[rowsLen - 1] < dropIndex) {\n        endRow = dropIndex - 1;\n        startRow = endRow - rowsLen + 1;\n      } else {\n        startRow = dropIndex;\n        endRow = startRow + rowsLen - 1;\n      }\n      selection = this.hot.selection;\n      lastColIndex = this.hot.countCols() - 1;\n      selection.setRangeStart(this.hot._createCellCoords(startRow, 0));\n      selection.setRangeEnd(this.hot._createCellCoords(endRow, lastColIndex), true);\n    }\n\n    // TODO: Reimplementation of function which is inside the `ManualRowMove` plugin.\n    /**\n     * Indicates if order of rows was changed.\n     *\n     * @param {Array} movedRows Array of visual row indexes to be moved.\n     * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements\n     *   will be placed after the moving action. To check the visualization of the final index, please take a look at\n     *   [documentation](@/guides/rows/row-moving.md).\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isRowOrderChanged\",\n    value: function isRowOrderChanged(movedRows, finalIndex) {\n      return movedRows.some(function (row, nrOfMovedElement) {\n        return row - nrOfMovedElement !== finalIndex;\n      });\n    }\n  }]);\n  return RowMoveController;\n}();\nexport { RowMoveController as default };","map":{"version":3,"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_templateObject","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","o","minLen","_arrayLikeToArray","n","Object","toString","call","slice","name","Array","from","test","iter","isArray","len","length","i","arr2","_taggedTemplateLiteral","strings","raw","freeze","defineProperties","value","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","_toPropertyKey","key","_createClass","protoProps","staticProps","arg","_toPrimitive","String","input","hint","prim","toPrimitive","undefined","res","Number","isUndefined","warn","toSingleLine","RowMoveController","plugin","hot","dataManager","collapsingUI","onBeforeRowMove","rows","finalIndex","dropIndex","movePossible","_this","improperUsage","displayAPICompatibilityWarning","movedToCollapsed","dropToLastRow","countRows","physicalDropIndex","countSourceRows","translateTrimmedRow","allowMove","physicalStartIndexes","map","rowIndex","physicalRowIndex","shouldAllowMoving","willDataChange","indexOf","baseParent","getBaseParent","targetParent","getTargetParent","sameParent","areChildrenCollapsed","collapsedRowsStash","stash","shiftCollapsibleParentsLocations","moveRows","rewriteCache","moveCellsMeta","applyStash","runHooks","isRowOrderChanged","render","selectCells","beforeMoveRowHookArgs","shouldTerminate","isParent","isRowHighestLevel","getRowParent","Math","max","apply","shiftStash","_this2","moveToLastChild","getRowIndex","countChildren","batchRender","forEach","physicalStartIndex","moveRow","baseIndexes","targetIndex","_this3","_this$hot","rowsOfMeta","movingDown","baseIndex","push","getCellMetaAtRow","spliceCellsMeta","concat","rowsLen","startRow","endRow","selection","lastColIndex","parentObject","parentIndex","untranslateTrimmedRow","countCols","setRangeStart","_createCellCoords","setRangeEnd","movedRows","some","row","nrOfMovedElement","default"],"sources":["/home/rstorey/wwwdev/Blucktool/node_modules/handsontable/plugins/nestedRows/utils/rowMoveController.mjs"],"sourcesContent":["function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nvar _templateObject;\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.symbol.to-primitive.js\";\nimport \"core-js/modules/es.date.to-primitive.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.object.freeze.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { isUndefined } from \"../../../helpers/mixed.mjs\";\nimport { warn } from \"../../../helpers/console.mjs\";\nimport { toSingleLine } from \"../../../helpers/templateLiteralTag.mjs\";\n/**\n * Helper class for the row-move-related operations.\n *\n * @private\n * @class RowMoveController\n */\nvar RowMoveController = /*#__PURE__*/function () {\n  function RowMoveController(plugin) {\n    _classCallCheck(this, RowMoveController);\n    /**\n     * Reference to the Nested Rows plugin instance.\n     *\n     * @type {NestedRows}\n     */\n    this.plugin = plugin;\n    /**\n     * Reference to the Handsontable instance.\n     *\n     * @type {Handsontable.Core}\n     */\n    this.hot = plugin.hot;\n    /**\n     * Reference to the Data Manager class instance.\n     *\n     * @type {DataManager}\n     */\n    this.dataManager = plugin.dataManager;\n    /**\n     * Reference to the Collapsing UI class instance.\n     *\n     * @type {CollapsingUI}\n     */\n    this.collapsingUI = plugin.collapsingUI;\n  }\n\n  /**\n   * `beforeRowMove` hook callback.\n   *\n   * @param {Array} rows Array of visual row indexes to be moved.\n   * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements\n   *   will be placed after the moving action. To check the visualization of the final index, please take a look at\n   *   [documentation](@/guides/rows/row-moving.md).\n   * @param {undefined|number} dropIndex Visual row index, being a drop index for the moved rows. Points to where we\n   *   are going to drop the moved elements. To check visualization of drop index please take a look at\n   *   [documentation](@/guides/rows/row-moving.md).\n   * @param {boolean} movePossible Indicates if it's possible to move rows to the desired position.\n   * @fires Hooks#afterRowMove\n   * @returns {boolean}\n   */\n  _createClass(RowMoveController, [{\n    key: \"onBeforeRowMove\",\n    value: function onBeforeRowMove(rows, finalIndex, dropIndex, movePossible) {\n      var _this = this;\n      var improperUsage = this.displayAPICompatibilityWarning({\n        rows: rows,\n        finalIndex: finalIndex,\n        dropIndex: dropIndex,\n        movePossible: movePossible\n      });\n      if (improperUsage) {\n        return false;\n      }\n      this.movedToCollapsed = false;\n      var dropToLastRow = dropIndex === this.hot.countRows();\n      var physicalDropIndex = dropToLastRow ? this.hot.countSourceRows() : this.dataManager.translateTrimmedRow(dropIndex);\n      var allowMove = true;\n      var physicalStartIndexes = rows.map(function (rowIndex) {\n        // Don't do the logic for the rest of the rows, as it's bound to fail anyway.\n        if (!allowMove) {\n          return false;\n        }\n        var physicalRowIndex = _this.dataManager.translateTrimmedRow(rowIndex);\n        allowMove = _this.shouldAllowMoving(physicalRowIndex, physicalDropIndex);\n        return physicalRowIndex;\n      });\n      var willDataChange = physicalStartIndexes.indexOf(physicalDropIndex) === -1;\n      if (!allowMove || !willDataChange) {\n        return false;\n      }\n      var baseParent = this.getBaseParent(physicalStartIndexes);\n      var targetParent = this.getTargetParent(dropToLastRow, physicalDropIndex);\n      var sameParent = baseParent === targetParent;\n      this.movedToCollapsed = this.collapsingUI.areChildrenCollapsed(targetParent);\n\n      // Stash the current state of collapsed rows\n      this.collapsingUI.collapsedRowsStash.stash();\n      this.shiftCollapsibleParentsLocations(physicalStartIndexes, physicalDropIndex, sameParent);\n      this.moveRows(physicalStartIndexes, physicalDropIndex, targetParent);\n      this.dataManager.rewriteCache();\n      this.moveCellsMeta(physicalStartIndexes, physicalDropIndex);\n      this.collapsingUI.collapsedRowsStash.applyStash(false);\n\n      // TODO: Trying to mock real work of the `ManualRowMove` plugin. It was blocked by returning `false` below.\n      this.hot.runHooks('afterRowMove', rows, finalIndex, dropIndex, movePossible, movePossible && this.isRowOrderChanged(rows, finalIndex));\n\n      // Not necessary - added to keep compatibility with other plugins (namely: columnSummary).\n      this.hot.render();\n      this.selectCells(rows, dropIndex);\n      return false;\n    }\n\n    /**\n     * Display a `dragRows`/`moveRows` method compatibility warning if needed.\n     *\n     * @param {object} beforeMoveRowHookArgs A set of arguments from the `beforeMoveRow` hook.\n     * @returns {boolean} `true` if is a result of an improper usage of the moving API.\n     */\n  }, {\n    key: \"displayAPICompatibilityWarning\",\n    value: function displayAPICompatibilityWarning(beforeMoveRowHookArgs) {\n      var rows = beforeMoveRowHookArgs.rows,\n        finalIndex = beforeMoveRowHookArgs.finalIndex,\n        dropIndex = beforeMoveRowHookArgs.dropIndex,\n        movePossible = beforeMoveRowHookArgs.movePossible;\n      var shouldTerminate = false;\n      if (isUndefined(dropIndex)) {\n        warn(toSingleLine(_templateObject || (_templateObject = _taggedTemplateLiteral([\"Since version 8.0.0 of the Handsontable the 'moveRows' method isn't used for moving rows \\n      when the NestedRows plugin is enabled. Please use the 'dragRows' method instead.\"], [\"Since version 8.0.0 of the Handsontable the 'moveRows' method isn't used for moving rows\\\\x20\\n      when the NestedRows plugin is enabled. Please use the 'dragRows' method instead.\"]))));\n\n        // TODO: Trying to mock real work of the `ManualRowMove` plugin. It was blocked by returning `false` below.\n        this.hot.runHooks('afterRowMove', rows, finalIndex, dropIndex, movePossible, false);\n        shouldTerminate = true;\n      }\n      return shouldTerminate;\n    }\n\n    /**\n     * Check if the moving action should be allowed.\n     *\n     * @param {number} physicalRowIndex Physical start row index.\n     * @param {number} physicalDropIndex Physical drop index.\n     * @returns {boolean} `true` if it should continue with the moving action.\n     */\n  }, {\n    key: \"shouldAllowMoving\",\n    value: function shouldAllowMoving(physicalRowIndex, physicalDropIndex) {\n      /*\n         We can't move rows when any of them is:\n         - a parent\n         - a top-level element\n         - is being moved to the top level\n         - is being moved to the position of any of the moved rows (not changing position)\n      */\n\n      return !(this.dataManager.isParent(physicalRowIndex) || this.dataManager.isRowHighestLevel(physicalRowIndex) || physicalRowIndex === physicalDropIndex || physicalDropIndex === 0);\n    }\n\n    /**\n     * Get the base row parent.\n     *\n     * @param {number} physicalStartIndexes Physical start row index.\n     * @returns {object|null} The base row parent.\n     */\n  }, {\n    key: \"getBaseParent\",\n    value: function getBaseParent(physicalStartIndexes) {\n      return this.dataManager.getRowParent(physicalStartIndexes[0]);\n    }\n\n    /**\n     * Get the target row parent.\n     *\n     * @param {boolean} dropToLastRow `true` if the row is moved to the last row of the table.\n     * @param {number} physicalDropIndex Physical drop row index.\n     * @returns {object|null} The target row parent.\n     */\n  }, {\n    key: \"getTargetParent\",\n    value: function getTargetParent(dropToLastRow, physicalDropIndex) {\n      var targetParent = this.dataManager.getRowParent(dropToLastRow ? physicalDropIndex - 1 : physicalDropIndex);\n\n      // If we try to move an element to the place of a top-level parent, snap the element to the previous top-level\n      // parent's children instead\n      if (targetParent === null || targetParent === void 0) {\n        targetParent = this.dataManager.getRowParent(physicalDropIndex - 1);\n      }\n      return targetParent;\n    }\n\n    /**\n     * Shift the cached collapsible rows position according to the move action.\n     *\n     * @param {number[]} physicalStartIndexes Physical start row indexes.\n     * @param {number} physicalDropIndex Physical drop index.\n     * @param {boolean} sameParent `true` if the row's being moved between siblings of the same parent.\n     */\n  }, {\n    key: \"shiftCollapsibleParentsLocations\",\n    value: function shiftCollapsibleParentsLocations(physicalStartIndexes, physicalDropIndex, sameParent) {\n      if (!sameParent) {\n        if (Math.max.apply(Math, _toConsumableArray(physicalStartIndexes)) <= physicalDropIndex) {\n          this.collapsingUI.collapsedRowsStash.shiftStash(physicalStartIndexes[0], physicalDropIndex, -1 * physicalStartIndexes.length);\n        } else {\n          this.collapsingUI.collapsedRowsStash.shiftStash(physicalDropIndex, physicalStartIndexes[0], physicalStartIndexes.length);\n        }\n      }\n    }\n\n    /**\n     * Move the rows at the provided coordinates.\n     *\n     * @param {number[]} physicalStartIndexes Physical indexes of the rows about to be moved.\n     * @param {number} physicalDropIndex Physical drop index.\n     * @param {object} targetParent Parent of the destination row.\n     */\n  }, {\n    key: \"moveRows\",\n    value: function moveRows(physicalStartIndexes, physicalDropIndex, targetParent) {\n      var _this2 = this;\n      var moveToLastChild = physicalDropIndex === this.dataManager.getRowIndex(targetParent) + this.dataManager.countChildren(targetParent) + 1;\n      this.hot.batchRender(function () {\n        physicalStartIndexes.forEach(function (physicalStartIndex) {\n          _this2.dataManager.moveRow(physicalStartIndex, physicalDropIndex, _this2.movedToCollapsed, moveToLastChild);\n        });\n      });\n    }\n\n    /**\n     * Move the cell meta for multiple rows.\n     *\n     * @param {number[]} baseIndexes Array of indexes for the rows being moved.\n     * @param {number} targetIndex Index of the destination of the move.\n     */\n  }, {\n    key: \"moveCellsMeta\",\n    value: function moveCellsMeta(baseIndexes, targetIndex) {\n      var _this3 = this,\n        _this$hot;\n      var rowsOfMeta = [];\n      var movingDown = Math.max.apply(Math, _toConsumableArray(baseIndexes)) < targetIndex;\n      baseIndexes.forEach(function (baseIndex) {\n        rowsOfMeta.push(_this3.hot.getCellMetaAtRow(baseIndex));\n      });\n      this.hot.spliceCellsMeta(baseIndexes[0], baseIndexes.length);\n      (_this$hot = this.hot).spliceCellsMeta.apply(_this$hot, [targetIndex - (movingDown ? rowsOfMeta.length : 0), 0].concat(rowsOfMeta));\n    }\n\n    /**\n     * Select cells after the move.\n     *\n     * @param {Array} rows Array of visual row indexes to be moved.\n     * @param {undefined|number} dropIndex Visual row index, being a drop index for the moved rows. Points to where we\n     *   are going to drop the moved elements. To check visualization of drop index please take a look at\n     *   [documentation](@/guides/rows/row-moving.md).\n     */\n  }, {\n    key: \"selectCells\",\n    value: function selectCells(rows, dropIndex) {\n      var rowsLen = rows.length;\n      var startRow = 0;\n      var endRow = 0;\n      var selection = null;\n      var lastColIndex = null;\n      if (this.movedToCollapsed) {\n        var physicalDropIndex = null;\n        if (rows[rowsLen - 1] < dropIndex) {\n          physicalDropIndex = this.dataManager.translateTrimmedRow(dropIndex - rowsLen);\n        } else {\n          physicalDropIndex = this.dataManager.translateTrimmedRow(dropIndex);\n        }\n        var parentObject = this.dataManager.getRowParent(physicalDropIndex === null ? this.hot.countSourceRows() - 1 : physicalDropIndex - 1);\n        var parentIndex = this.dataManager.getRowIndex(parentObject);\n        startRow = this.dataManager.untranslateTrimmedRow(parentIndex);\n        endRow = startRow;\n      } else if (rows[rowsLen - 1] < dropIndex) {\n        endRow = dropIndex - 1;\n        startRow = endRow - rowsLen + 1;\n      } else {\n        startRow = dropIndex;\n        endRow = startRow + rowsLen - 1;\n      }\n      selection = this.hot.selection;\n      lastColIndex = this.hot.countCols() - 1;\n      selection.setRangeStart(this.hot._createCellCoords(startRow, 0));\n      selection.setRangeEnd(this.hot._createCellCoords(endRow, lastColIndex), true);\n    }\n\n    // TODO: Reimplementation of function which is inside the `ManualRowMove` plugin.\n    /**\n     * Indicates if order of rows was changed.\n     *\n     * @param {Array} movedRows Array of visual row indexes to be moved.\n     * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements\n     *   will be placed after the moving action. To check the visualization of the final index, please take a look at\n     *   [documentation](@/guides/rows/row-moving.md).\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isRowOrderChanged\",\n    value: function isRowOrderChanged(movedRows, finalIndex) {\n      return movedRows.some(function (row, nrOfMovedElement) {\n        return row - nrOfMovedElement !== finalIndex;\n      });\n    }\n  }]);\n  return RowMoveController;\n}();\nexport { RowMoveController as default };"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}