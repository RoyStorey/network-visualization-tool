{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4;\nfunction _taggedTemplateLiteral(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nimport { toSingleLine } from \"../../helpers/templateLiteralTag.mjs\";\n/**\n * The `MergedCellCoords` class represents a single merged cell.\n *\n * @private\n * @class MergedCellCoords\n */\nvar MergedCellCoords = /*#__PURE__*/function () {\n  function MergedCellCoords(row, column, rowspan, colspan, cellCoordsFactory, cellRangeFactory) {\n    _classCallCheck(this, MergedCellCoords);\n    /**\n     * The index of the topmost merged cell row.\n     *\n     * @type {number}\n     */\n    this.row = row;\n    /**\n     * The index of the leftmost column.\n     *\n     * @type {number}\n     */\n    this.col = column;\n    /**\n     * The `rowspan` value of the merged cell.\n     *\n     * @type {number}\n     */\n    this.rowspan = rowspan;\n    /**\n     * The `colspan` value of the merged cell.\n     *\n     * @type {number}\n     */\n    this.colspan = colspan;\n    /**\n     * `true` only if the merged cell is bound to be removed.\n     *\n     * @type {boolean}\n     */\n    this.removed = false;\n    /**\n     * The CellCoords function factory.\n     *\n     * @type {Function}\n     */\n    this.cellCoordsFactory = cellCoordsFactory;\n    /**\n     * The CellRange function factory.\n     *\n     * @type {Function}\n     */\n    this.cellRangeFactory = cellRangeFactory;\n  }\n\n  /**\n   * Get a warning message for when the declared merged cell data contains negative values.\n   *\n   * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.\n   * @returns {string}\n   */\n  _createClass(MergedCellCoords, [{\n    key: \"normalize\",\n    value:\n    /**\n     * Sanitize (prevent from going outside the boundaries) the merged cell.\n     *\n     * @param {Core} hotInstance The Handsontable instance.\n     */\n    function normalize(hotInstance) {\n      var totalRows = hotInstance.countRows();\n      var totalColumns = hotInstance.countCols();\n      if (this.row < 0) {\n        this.row = 0;\n      } else if (this.row > totalRows - 1) {\n        this.row = totalRows - 1;\n      }\n      if (this.col < 0) {\n        this.col = 0;\n      } else if (this.col > totalColumns - 1) {\n        this.col = totalColumns - 1;\n      }\n      if (this.row + this.rowspan > totalRows - 1) {\n        this.rowspan = totalRows - this.row;\n      }\n      if (this.col + this.colspan > totalColumns - 1) {\n        this.colspan = totalColumns - this.col;\n      }\n    }\n\n    /**\n     * Returns `true` if the provided coordinates are inside the merged cell.\n     *\n     * @param {number} row The row index.\n     * @param {number} column The column index.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"includes\",\n    value: function includes(row, column) {\n      return this.row <= row && this.col <= column && this.row + this.rowspan - 1 >= row && this.col + this.colspan - 1 >= column;\n    }\n\n    /**\n     * Returns `true` if the provided `column` property is within the column span of the merged cell.\n     *\n     * @param {number} column The column index.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"includesHorizontally\",\n    value: function includesHorizontally(column) {\n      return this.col <= column && this.col + this.colspan - 1 >= column;\n    }\n\n    /**\n     * Returns `true` if the provided `row` property is within the row span of the merged cell.\n     *\n     * @param {number} row Row index.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"includesVertically\",\n    value: function includesVertically(row) {\n      return this.row <= row && this.row + this.rowspan - 1 >= row;\n    }\n\n    /**\n     * Shift (and possibly resize, if needed) the merged cell.\n     *\n     * @param {Array} shiftVector 2-element array containing the information on the shifting in the `x` and `y` axis.\n     * @param {number} indexOfChange Index of the preceding change.\n     * @returns {boolean} Returns `false` if the whole merged cell was removed.\n     */\n  }, {\n    key: \"shift\",\n    value: function shift(shiftVector, indexOfChange) {\n      var shiftValue = shiftVector[0] || shiftVector[1];\n      var shiftedIndex = indexOfChange + Math.abs(shiftVector[0] || shiftVector[1]) - 1;\n      var span = shiftVector[0] ? 'colspan' : 'rowspan';\n      var index = shiftVector[0] ? 'col' : 'row';\n      var changeStart = Math.min(indexOfChange, shiftedIndex);\n      var changeEnd = Math.max(indexOfChange, shiftedIndex);\n      var mergeStart = this[index];\n      var mergeEnd = this[index] + this[span] - 1;\n      if (mergeStart >= indexOfChange) {\n        this[index] += shiftValue;\n      }\n\n      // adding rows/columns\n      if (shiftValue > 0) {\n        if (indexOfChange <= mergeEnd && indexOfChange > mergeStart) {\n          this[span] += shiftValue;\n        }\n\n        // removing rows/columns\n      } else if (shiftValue < 0) {\n        // removing the whole merge\n        if (changeStart <= mergeStart && changeEnd >= mergeEnd) {\n          this.removed = true;\n          return false;\n\n          // removing the merge partially, including the beginning\n        } else if (mergeStart >= changeStart && mergeStart <= changeEnd) {\n          var removedOffset = changeEnd - mergeStart + 1;\n          var preRemovedOffset = Math.abs(shiftValue) - removedOffset;\n          this[index] -= preRemovedOffset + shiftValue;\n          this[span] -= removedOffset;\n\n          // removing the middle part of the merge\n        } else if (mergeStart <= changeStart && mergeEnd >= changeEnd) {\n          this[span] += shiftValue;\n\n          // removing the end part of the merge\n        } else if (mergeStart <= changeStart && mergeEnd >= changeStart && mergeEnd < changeEnd) {\n          var removedPart = mergeEnd - changeStart + 1;\n          this[span] -= removedPart;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Check if the second provided merged cell is \"farther\" in the provided direction.\n     *\n     * @param {MergedCellCoords} mergedCell The merged cell to check.\n     * @param {string} direction Drag direction.\n     * @returns {boolean|null} `true` if the second provided merged cell is \"farther\".\n     */\n  }, {\n    key: \"isFarther\",\n    value: function isFarther(mergedCell, direction) {\n      if (!mergedCell) {\n        return true;\n      }\n      if (direction === 'down') {\n        return mergedCell.row + mergedCell.rowspan - 1 < this.row + this.rowspan - 1;\n      } else if (direction === 'up') {\n        return mergedCell.row > this.row;\n      } else if (direction === 'right') {\n        return mergedCell.col + mergedCell.colspan - 1 < this.col + this.colspan - 1;\n      } else if (direction === 'left') {\n        return mergedCell.col > this.col;\n      }\n      return null;\n    }\n\n    /**\n     * Get the bottom row index of the merged cell.\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getLastRow\",\n    value: function getLastRow() {\n      return this.row + this.rowspan - 1;\n    }\n\n    /**\n     * Get the rightmost column index of the merged cell.\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getLastColumn\",\n    value: function getLastColumn() {\n      return this.col + this.colspan - 1;\n    }\n\n    /**\n     * Get the range coordinates of the merged cell.\n     *\n     * @returns {CellRange}\n     */\n  }, {\n    key: \"getRange\",\n    value: function getRange() {\n      return this.cellRangeFactory(this.cellCoordsFactory(this.row, this.col), this.cellCoordsFactory(this.row, this.col), this.cellCoordsFactory(this.getLastRow(), this.getLastColumn()));\n    }\n  }], [{\n    key: \"NEGATIVE_VALUES_WARNING\",\n    value: function NEGATIVE_VALUES_WARNING(newMergedCell) {\n      return toSingleLine(_templateObject || (_templateObject = _taggedTemplateLiteral([\"The merged cell declared with {row: \", \", col: \", \", \\n      rowspan: \", \", colspan: \", \"} contains negative values, which is \\n      not supported. It will not be added to the collection.\"], [\"The merged cell declared with {row: \", \", col: \", \",\\\\x20\\n      rowspan: \", \", colspan: \", \"} contains negative values, which is\\\\x20\\n      not supported. It will not be added to the collection.\"])), newMergedCell.row, newMergedCell.col, newMergedCell.rowspan, newMergedCell.colspan);\n    }\n\n    /**\n     * Get a warning message for when the declared merged cell data contains values exceeding the table limits.\n     *\n     * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.\n     * @returns {string}\n     */\n  }, {\n    key: \"IS_OUT_OF_BOUNDS_WARNING\",\n    value: function IS_OUT_OF_BOUNDS_WARNING(newMergedCell) {\n      return toSingleLine(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"The merged cell declared at [\", \", \", \"] is positioned \\n      (or positioned partially) outside of the table range. It was not added to the table, please fix your setup.\"], [\"The merged cell declared at [\", \", \", \"] is positioned\\\\x20\\n      (or positioned partially) outside of the table range. It was not added to the table, please fix your setup.\"])), newMergedCell.row, newMergedCell.col);\n    }\n\n    /**\n     * Get a warning message for when the declared merged cell data represents a single cell.\n     *\n     * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.\n     * @returns {string}\n     */\n  }, {\n    key: \"IS_SINGLE_CELL\",\n    value: function IS_SINGLE_CELL(newMergedCell) {\n      return toSingleLine(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"The merged cell declared at [\", \", \", \"] has both \\\"rowspan\\\" \\n      and \\\"colspan\\\" declared as \\\"1\\\", which makes it a single cell. It cannot be added to the collection.\"], [\"The merged cell declared at [\", \", \", \"] has both \\\"rowspan\\\"\\\\x20\\n      and \\\"colspan\\\" declared as \\\"1\\\", which makes it a single cell. It cannot be added to the collection.\"])), newMergedCell.row, newMergedCell.col);\n    }\n\n    /**\n     * Get a warning message for when the declared merged cell data contains \"colspan\" or \"rowspan\", that equals 0.\n     *\n     * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.\n     * @returns {string}\n     */\n  }, {\n    key: \"ZERO_SPAN_WARNING\",\n    value: function ZERO_SPAN_WARNING(newMergedCell) {\n      return toSingleLine(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"The merged cell declared at [\", \", \", \"] has \\\"rowspan\\\" \\n      or \\\"colspan\\\" declared as \\\"0\\\", which is not supported. It cannot be added to the collection.\"], [\"The merged cell declared at [\", \", \", \"] has \\\"rowspan\\\"\\\\x20\\n      or \\\"colspan\\\" declared as \\\"0\\\", which is not supported. It cannot be added to the collection.\"])), newMergedCell.row, newMergedCell.col);\n    }\n\n    /**\n     * Check whether the values provided for a merged cell contain any negative values.\n     *\n     * @param {object} mergedCellInfo Object containing the `row`, `col`, `rowspan` and `colspan` properties.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"containsNegativeValues\",\n    value: function containsNegativeValues(mergedCellInfo) {\n      return mergedCellInfo.row < 0 || mergedCellInfo.col < 0 || mergedCellInfo.rowspan < 0 || mergedCellInfo.colspan < 0;\n    }\n\n    /**\n     * Check whether the provided merged cell information object represents a single cell.\n     *\n     * @private\n     * @param {object} mergedCellInfo An object with `row`, `col`, `rowspan` and `colspan` properties.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isSingleCell\",\n    value: function isSingleCell(mergedCellInfo) {\n      return mergedCellInfo.colspan === 1 && mergedCellInfo.rowspan === 1;\n    }\n\n    /**\n     * Check whether the provided merged cell information object contains a rowspan or colspan of 0.\n     *\n     * @private\n     * @param {object} mergedCellInfo An object with `row`, `col`, `rowspan` and `colspan` properties.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"containsZeroSpan\",\n    value: function containsZeroSpan(mergedCellInfo) {\n      return mergedCellInfo.colspan === 0 || mergedCellInfo.rowspan === 0;\n    }\n\n    /**\n     * Check whether the provided merged cell object is to be declared out of bounds of the table.\n     *\n     * @param {object} mergeCell Object containing the `row`, `col`, `rowspan` and `colspan` properties.\n     * @param {number} rowCount Number of rows in the table.\n     * @param {number} columnCount Number of rows in the table.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isOutOfBounds\",\n    value: function isOutOfBounds(mergeCell, rowCount, columnCount) {\n      return mergeCell.row < 0 || mergeCell.col < 0 || mergeCell.row >= rowCount || mergeCell.row + mergeCell.rowspan - 1 >= rowCount || mergeCell.col >= columnCount || mergeCell.col + mergeCell.colspan - 1 >= columnCount;\n    }\n  }]);\n  return MergedCellCoords;\n}();\nexport default MergedCellCoords;","map":{"version":3,"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_templateObject","_templateObject2","_templateObject3","_templateObject4","_taggedTemplateLiteral","strings","raw","slice","Object","freeze","defineProperties","value","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","defineProperty","_toPropertyKey","key","_createClass","protoProps","staticProps","arg","_toPrimitive","String","input","hint","prim","toPrimitive","undefined","res","call","Number","toSingleLine","MergedCellCoords","row","column","rowspan","colspan","cellCoordsFactory","cellRangeFactory","col","removed","normalize","hotInstance","totalRows","countRows","totalColumns","countCols","includes","includesHorizontally","includesVertically","shift","shiftVector","indexOfChange","shiftValue","shiftedIndex","Math","abs","span","index","changeStart","min","changeEnd","max","mergeStart","mergeEnd","removedOffset","preRemovedOffset","removedPart","isFarther","mergedCell","direction","getLastRow","getLastColumn","getRange","NEGATIVE_VALUES_WARNING","newMergedCell","IS_OUT_OF_BOUNDS_WARNING","IS_SINGLE_CELL","ZERO_SPAN_WARNING","containsNegativeValues","mergedCellInfo","isSingleCell","containsZeroSpan","isOutOfBounds","mergeCell","rowCount","columnCount"],"sources":["/home/rstorey/wwwdev/Blucktool/node_modules/handsontable/plugins/mergeCells/cellCoords.mjs"],"sourcesContent":["import \"core-js/modules/es.symbol.to-primitive.js\";\nimport \"core-js/modules/es.date.to-primitive.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.object.freeze.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4;\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { toSingleLine } from \"../../helpers/templateLiteralTag.mjs\";\n/**\n * The `MergedCellCoords` class represents a single merged cell.\n *\n * @private\n * @class MergedCellCoords\n */\nvar MergedCellCoords = /*#__PURE__*/function () {\n  function MergedCellCoords(row, column, rowspan, colspan, cellCoordsFactory, cellRangeFactory) {\n    _classCallCheck(this, MergedCellCoords);\n    /**\n     * The index of the topmost merged cell row.\n     *\n     * @type {number}\n     */\n    this.row = row;\n    /**\n     * The index of the leftmost column.\n     *\n     * @type {number}\n     */\n    this.col = column;\n    /**\n     * The `rowspan` value of the merged cell.\n     *\n     * @type {number}\n     */\n    this.rowspan = rowspan;\n    /**\n     * The `colspan` value of the merged cell.\n     *\n     * @type {number}\n     */\n    this.colspan = colspan;\n    /**\n     * `true` only if the merged cell is bound to be removed.\n     *\n     * @type {boolean}\n     */\n    this.removed = false;\n    /**\n     * The CellCoords function factory.\n     *\n     * @type {Function}\n     */\n    this.cellCoordsFactory = cellCoordsFactory;\n    /**\n     * The CellRange function factory.\n     *\n     * @type {Function}\n     */\n    this.cellRangeFactory = cellRangeFactory;\n  }\n\n  /**\n   * Get a warning message for when the declared merged cell data contains negative values.\n   *\n   * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.\n   * @returns {string}\n   */\n  _createClass(MergedCellCoords, [{\n    key: \"normalize\",\n    value:\n    /**\n     * Sanitize (prevent from going outside the boundaries) the merged cell.\n     *\n     * @param {Core} hotInstance The Handsontable instance.\n     */\n    function normalize(hotInstance) {\n      var totalRows = hotInstance.countRows();\n      var totalColumns = hotInstance.countCols();\n      if (this.row < 0) {\n        this.row = 0;\n      } else if (this.row > totalRows - 1) {\n        this.row = totalRows - 1;\n      }\n      if (this.col < 0) {\n        this.col = 0;\n      } else if (this.col > totalColumns - 1) {\n        this.col = totalColumns - 1;\n      }\n      if (this.row + this.rowspan > totalRows - 1) {\n        this.rowspan = totalRows - this.row;\n      }\n      if (this.col + this.colspan > totalColumns - 1) {\n        this.colspan = totalColumns - this.col;\n      }\n    }\n\n    /**\n     * Returns `true` if the provided coordinates are inside the merged cell.\n     *\n     * @param {number} row The row index.\n     * @param {number} column The column index.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"includes\",\n    value: function includes(row, column) {\n      return this.row <= row && this.col <= column && this.row + this.rowspan - 1 >= row && this.col + this.colspan - 1 >= column;\n    }\n\n    /**\n     * Returns `true` if the provided `column` property is within the column span of the merged cell.\n     *\n     * @param {number} column The column index.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"includesHorizontally\",\n    value: function includesHorizontally(column) {\n      return this.col <= column && this.col + this.colspan - 1 >= column;\n    }\n\n    /**\n     * Returns `true` if the provided `row` property is within the row span of the merged cell.\n     *\n     * @param {number} row Row index.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"includesVertically\",\n    value: function includesVertically(row) {\n      return this.row <= row && this.row + this.rowspan - 1 >= row;\n    }\n\n    /**\n     * Shift (and possibly resize, if needed) the merged cell.\n     *\n     * @param {Array} shiftVector 2-element array containing the information on the shifting in the `x` and `y` axis.\n     * @param {number} indexOfChange Index of the preceding change.\n     * @returns {boolean} Returns `false` if the whole merged cell was removed.\n     */\n  }, {\n    key: \"shift\",\n    value: function shift(shiftVector, indexOfChange) {\n      var shiftValue = shiftVector[0] || shiftVector[1];\n      var shiftedIndex = indexOfChange + Math.abs(shiftVector[0] || shiftVector[1]) - 1;\n      var span = shiftVector[0] ? 'colspan' : 'rowspan';\n      var index = shiftVector[0] ? 'col' : 'row';\n      var changeStart = Math.min(indexOfChange, shiftedIndex);\n      var changeEnd = Math.max(indexOfChange, shiftedIndex);\n      var mergeStart = this[index];\n      var mergeEnd = this[index] + this[span] - 1;\n      if (mergeStart >= indexOfChange) {\n        this[index] += shiftValue;\n      }\n\n      // adding rows/columns\n      if (shiftValue > 0) {\n        if (indexOfChange <= mergeEnd && indexOfChange > mergeStart) {\n          this[span] += shiftValue;\n        }\n\n        // removing rows/columns\n      } else if (shiftValue < 0) {\n        // removing the whole merge\n        if (changeStart <= mergeStart && changeEnd >= mergeEnd) {\n          this.removed = true;\n          return false;\n\n          // removing the merge partially, including the beginning\n        } else if (mergeStart >= changeStart && mergeStart <= changeEnd) {\n          var removedOffset = changeEnd - mergeStart + 1;\n          var preRemovedOffset = Math.abs(shiftValue) - removedOffset;\n          this[index] -= preRemovedOffset + shiftValue;\n          this[span] -= removedOffset;\n\n          // removing the middle part of the merge\n        } else if (mergeStart <= changeStart && mergeEnd >= changeEnd) {\n          this[span] += shiftValue;\n\n          // removing the end part of the merge\n        } else if (mergeStart <= changeStart && mergeEnd >= changeStart && mergeEnd < changeEnd) {\n          var removedPart = mergeEnd - changeStart + 1;\n          this[span] -= removedPart;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Check if the second provided merged cell is \"farther\" in the provided direction.\n     *\n     * @param {MergedCellCoords} mergedCell The merged cell to check.\n     * @param {string} direction Drag direction.\n     * @returns {boolean|null} `true` if the second provided merged cell is \"farther\".\n     */\n  }, {\n    key: \"isFarther\",\n    value: function isFarther(mergedCell, direction) {\n      if (!mergedCell) {\n        return true;\n      }\n      if (direction === 'down') {\n        return mergedCell.row + mergedCell.rowspan - 1 < this.row + this.rowspan - 1;\n      } else if (direction === 'up') {\n        return mergedCell.row > this.row;\n      } else if (direction === 'right') {\n        return mergedCell.col + mergedCell.colspan - 1 < this.col + this.colspan - 1;\n      } else if (direction === 'left') {\n        return mergedCell.col > this.col;\n      }\n      return null;\n    }\n\n    /**\n     * Get the bottom row index of the merged cell.\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getLastRow\",\n    value: function getLastRow() {\n      return this.row + this.rowspan - 1;\n    }\n\n    /**\n     * Get the rightmost column index of the merged cell.\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getLastColumn\",\n    value: function getLastColumn() {\n      return this.col + this.colspan - 1;\n    }\n\n    /**\n     * Get the range coordinates of the merged cell.\n     *\n     * @returns {CellRange}\n     */\n  }, {\n    key: \"getRange\",\n    value: function getRange() {\n      return this.cellRangeFactory(this.cellCoordsFactory(this.row, this.col), this.cellCoordsFactory(this.row, this.col), this.cellCoordsFactory(this.getLastRow(), this.getLastColumn()));\n    }\n  }], [{\n    key: \"NEGATIVE_VALUES_WARNING\",\n    value: function NEGATIVE_VALUES_WARNING(newMergedCell) {\n      return toSingleLine(_templateObject || (_templateObject = _taggedTemplateLiteral([\"The merged cell declared with {row: \", \", col: \", \", \\n      rowspan: \", \", colspan: \", \"} contains negative values, which is \\n      not supported. It will not be added to the collection.\"], [\"The merged cell declared with {row: \", \", col: \", \",\\\\x20\\n      rowspan: \", \", colspan: \", \"} contains negative values, which is\\\\x20\\n      not supported. It will not be added to the collection.\"])), newMergedCell.row, newMergedCell.col, newMergedCell.rowspan, newMergedCell.colspan);\n    }\n\n    /**\n     * Get a warning message for when the declared merged cell data contains values exceeding the table limits.\n     *\n     * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.\n     * @returns {string}\n     */\n  }, {\n    key: \"IS_OUT_OF_BOUNDS_WARNING\",\n    value: function IS_OUT_OF_BOUNDS_WARNING(newMergedCell) {\n      return toSingleLine(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"The merged cell declared at [\", \", \", \"] is positioned \\n      (or positioned partially) outside of the table range. It was not added to the table, please fix your setup.\"], [\"The merged cell declared at [\", \", \", \"] is positioned\\\\x20\\n      (or positioned partially) outside of the table range. It was not added to the table, please fix your setup.\"])), newMergedCell.row, newMergedCell.col);\n    }\n\n    /**\n     * Get a warning message for when the declared merged cell data represents a single cell.\n     *\n     * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.\n     * @returns {string}\n     */\n  }, {\n    key: \"IS_SINGLE_CELL\",\n    value: function IS_SINGLE_CELL(newMergedCell) {\n      return toSingleLine(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"The merged cell declared at [\", \", \", \"] has both \\\"rowspan\\\" \\n      and \\\"colspan\\\" declared as \\\"1\\\", which makes it a single cell. It cannot be added to the collection.\"], [\"The merged cell declared at [\", \", \", \"] has both \\\"rowspan\\\"\\\\x20\\n      and \\\"colspan\\\" declared as \\\"1\\\", which makes it a single cell. It cannot be added to the collection.\"])), newMergedCell.row, newMergedCell.col);\n    }\n\n    /**\n     * Get a warning message for when the declared merged cell data contains \"colspan\" or \"rowspan\", that equals 0.\n     *\n     * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.\n     * @returns {string}\n     */\n  }, {\n    key: \"ZERO_SPAN_WARNING\",\n    value: function ZERO_SPAN_WARNING(newMergedCell) {\n      return toSingleLine(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"The merged cell declared at [\", \", \", \"] has \\\"rowspan\\\" \\n      or \\\"colspan\\\" declared as \\\"0\\\", which is not supported. It cannot be added to the collection.\"], [\"The merged cell declared at [\", \", \", \"] has \\\"rowspan\\\"\\\\x20\\n      or \\\"colspan\\\" declared as \\\"0\\\", which is not supported. It cannot be added to the collection.\"])), newMergedCell.row, newMergedCell.col);\n    }\n\n    /**\n     * Check whether the values provided for a merged cell contain any negative values.\n     *\n     * @param {object} mergedCellInfo Object containing the `row`, `col`, `rowspan` and `colspan` properties.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"containsNegativeValues\",\n    value: function containsNegativeValues(mergedCellInfo) {\n      return mergedCellInfo.row < 0 || mergedCellInfo.col < 0 || mergedCellInfo.rowspan < 0 || mergedCellInfo.colspan < 0;\n    }\n\n    /**\n     * Check whether the provided merged cell information object represents a single cell.\n     *\n     * @private\n     * @param {object} mergedCellInfo An object with `row`, `col`, `rowspan` and `colspan` properties.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isSingleCell\",\n    value: function isSingleCell(mergedCellInfo) {\n      return mergedCellInfo.colspan === 1 && mergedCellInfo.rowspan === 1;\n    }\n\n    /**\n     * Check whether the provided merged cell information object contains a rowspan or colspan of 0.\n     *\n     * @private\n     * @param {object} mergedCellInfo An object with `row`, `col`, `rowspan` and `colspan` properties.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"containsZeroSpan\",\n    value: function containsZeroSpan(mergedCellInfo) {\n      return mergedCellInfo.colspan === 0 || mergedCellInfo.rowspan === 0;\n    }\n\n    /**\n     * Check whether the provided merged cell object is to be declared out of bounds of the table.\n     *\n     * @param {object} mergeCell Object containing the `row`, `col`, `rowspan` and `colspan` properties.\n     * @param {number} rowCount Number of rows in the table.\n     * @param {number} columnCount Number of rows in the table.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isOutOfBounds\",\n    value: function isOutOfBounds(mergeCell, rowCount, columnCount) {\n      return mergeCell.row < 0 || mergeCell.col < 0 || mergeCell.row >= rowCount || mergeCell.row + mergeCell.rowspan - 1 >= rowCount || mergeCell.col >= columnCount || mergeCell.col + mergeCell.colspan - 1 >= columnCount;\n    }\n  }]);\n  return MergedCellCoords;\n}();\nexport default MergedCellCoords;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}