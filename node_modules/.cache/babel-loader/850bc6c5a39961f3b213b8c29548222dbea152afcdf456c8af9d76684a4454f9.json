{"ast":null,"code":"function _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nimport { rangeEach } from \"../../../helpers/number.mjs\";\nimport { objectEach } from \"../../../helpers/object.mjs\";\nimport { arrayEach } from \"../../../helpers/array.mjs\";\n/**\n * Class responsible for making data operations.\n *\n * @private\n */\nvar DataManager = /*#__PURE__*/function () {\n  function DataManager(nestedRowsPlugin, hotInstance) {\n    _classCallCheck(this, DataManager);\n    /**\n     * Main Handsontable instance reference.\n     *\n     * @type {object}\n     */\n    this.hot = hotInstance;\n    /**\n     * Reference to the source data object.\n     *\n     * @type {Handsontable.CellValue[][]|Handsontable.RowObject[]}\n     */\n    this.data = null;\n    /**\n     * Reference to the NestedRows plugin.\n     *\n     * @type {object}\n     */\n    this.plugin = nestedRowsPlugin;\n    /**\n     * Map of row object parents.\n     *\n     * @type {WeakMap}\n     */\n    this.parentReference = new WeakMap();\n    /**\n     * Nested structure cache.\n     *\n     * @type {object}\n     */\n    this.cache = {\n      levels: [],\n      levelCount: 0,\n      rows: [],\n      nodeInfo: new WeakMap()\n    };\n  }\n\n  /**\n   * Set the data for the manager.\n   *\n   * @param {Handsontable.CellValue[][]|Handsontable.RowObject[]} data Data for the manager.\n   */\n  _createClass(DataManager, [{\n    key: \"setData\",\n    value: function setData(data) {\n      this.data = data;\n    }\n\n    /**\n     * Get the data cached in the manager.\n     *\n     * @returns {Handsontable.CellValue[][]|Handsontable.RowObject[]}\n     */\n  }, {\n    key: \"getData\",\n    value: function getData() {\n      return this.data;\n    }\n\n    /**\n     * Load the \"raw\" source data, without NestedRows' modifications.\n     *\n     * @returns {Handsontable.CellValue[][]|Handsontable.RowObject[]}\n     */\n  }, {\n    key: \"getRawSourceData\",\n    value: function getRawSourceData() {\n      var rawSourceData = null;\n      this.plugin.disableCoreAPIModifiers();\n      rawSourceData = this.hot.getSourceData();\n      this.plugin.enableCoreAPIModifiers();\n      return rawSourceData;\n    }\n\n    /**\n     * Update the Data Manager with new data and refresh cache.\n     *\n     * @param {Handsontable.CellValue[][]|Handsontable.RowObject[]} data Data for the manager.\n     */\n  }, {\n    key: \"updateWithData\",\n    value: function updateWithData(data) {\n      this.setData(data);\n      this.rewriteCache();\n    }\n\n    /**\n     * Rewrite the nested structure cache.\n     *\n     * @private\n     */\n  }, {\n    key: \"rewriteCache\",\n    value: function rewriteCache() {\n      var _this = this;\n      this.cache = {\n        levels: [],\n        levelCount: 0,\n        rows: [],\n        nodeInfo: new WeakMap()\n      };\n      rangeEach(0, this.data.length - 1, function (i) {\n        _this.cacheNode(_this.data[i], 0, null);\n      });\n    }\n\n    /**\n     * Cache a data node.\n     *\n     * @private\n     * @param {object} node Node to cache.\n     * @param {number} level Level of the node.\n     * @param {object} parent Parent of the node.\n     */\n  }, {\n    key: \"cacheNode\",\n    value: function cacheNode(node, level, parent) {\n      var _this2 = this;\n      if (!this.cache.levels[level]) {\n        this.cache.levels[level] = [];\n        this.cache.levelCount += 1;\n      }\n      this.cache.levels[level].push(node);\n      this.cache.rows.push(node);\n      this.cache.nodeInfo.set(node, {\n        parent: parent,\n        row: this.cache.rows.length - 1,\n        level: level\n      });\n      if (this.hasChildren(node)) {\n        arrayEach(node.__children, function (elem) {\n          _this2.cacheNode(elem, level + 1, node);\n        });\n      }\n    }\n\n    /**\n     * Get the date for the provided visual row number.\n     *\n     * @param {number} row Row index.\n     * @returns {object}\n     */\n  }, {\n    key: \"getDataObject\",\n    value: function getDataObject(row) {\n      return row === null || row === void 0 ? null : this.cache.rows[row];\n    }\n\n    /**\n     * Read the row tree in search for a specific row index or row object.\n     *\n     * @private\n     * @param {object} parent The initial parent object.\n     * @param {number} readCount Number of read nodes.\n     * @param {number} neededIndex The row index we search for.\n     * @param {object} neededObject The row object we search for.\n     * @returns {number|object}\n     */\n  }, {\n    key: \"readTreeNodes\",\n    value: function readTreeNodes(parent, readCount, neededIndex, neededObject) {\n      var _this3 = this;\n      var rootLevel = false;\n      var readNodesCount = readCount;\n      if (isNaN(readNodesCount) && readNodesCount.end) {\n        return readNodesCount;\n      }\n      var parentObj = parent;\n      if (!parentObj) {\n        parentObj = {\n          __children: this.data\n        };\n        rootLevel = true;\n        readNodesCount -= 1;\n      }\n      if (neededIndex !== null && neededIndex !== void 0 && readNodesCount === neededIndex) {\n        return {\n          result: parentObj,\n          end: true\n        };\n      }\n      if (neededObject !== null && neededObject !== void 0 && parentObj === neededObject) {\n        return {\n          result: readNodesCount,\n          end: true\n        };\n      }\n      readNodesCount += 1;\n      if (parentObj.__children) {\n        arrayEach(parentObj.__children, function (val) {\n          _this3.parentReference.set(val, rootLevel ? null : parentObj);\n          readNodesCount = _this3.readTreeNodes(val, readNodesCount, neededIndex, neededObject);\n          if (isNaN(readNodesCount) && readNodesCount.end) {\n            return false;\n          }\n        });\n      }\n      return readNodesCount;\n    }\n\n    /**\n     * Mock a parent node.\n     *\n     * @private\n     * @returns {*}\n     */\n  }, {\n    key: \"mockParent\",\n    value: function mockParent() {\n      var fakeParent = this.mockNode();\n      fakeParent.__children = this.data;\n      return fakeParent;\n    }\n\n    /**\n     * Mock a data node.\n     *\n     * @private\n     * @returns {{}}\n     */\n  }, {\n    key: \"mockNode\",\n    value: function mockNode() {\n      var fakeNode = {};\n      objectEach(this.data[0], function (val, key) {\n        fakeNode[key] = null;\n      });\n      return fakeNode;\n    }\n\n    /**\n     * Get the row index for the provided row object.\n     *\n     * @param {object} rowObj The row object.\n     * @returns {number} Row index.\n     */\n  }, {\n    key: \"getRowIndex\",\n    value: function getRowIndex(rowObj) {\n      return rowObj === null || rowObj === void 0 ? null : this.cache.nodeInfo.get(rowObj).row;\n    }\n\n    /**\n     * Get the index of the provided row index/row object within its parent.\n     *\n     * @param {number|object} row Row index / row object.\n     * @returns {number}\n     */\n  }, {\n    key: \"getRowIndexWithinParent\",\n    value: function getRowIndexWithinParent(row) {\n      var rowObj = null;\n      if (isNaN(row)) {\n        rowObj = row;\n      } else {\n        rowObj = this.getDataObject(row);\n      }\n      var parent = this.getRowParent(row);\n      if (parent === null || parent === void 0) {\n        return this.data.indexOf(rowObj);\n      }\n      return parent.__children.indexOf(rowObj);\n    }\n\n    /**\n     * Count all rows (including all parents and children).\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"countAllRows\",\n    value: function countAllRows() {\n      var rootNodeMock = {\n        __children: this.data\n      };\n      return this.countChildren(rootNodeMock);\n    }\n\n    /**\n     * Count children of the provided parent.\n     *\n     * @param {object|number} parent Parent node.\n     * @returns {number} Children count.\n     */\n  }, {\n    key: \"countChildren\",\n    value: function countChildren(parent) {\n      var _this4 = this;\n      var rowCount = 0;\n      var parentNode = parent;\n      if (!isNaN(parentNode)) {\n        parentNode = this.getDataObject(parentNode);\n      }\n      if (!parentNode || !parentNode.__children) {\n        return 0;\n      }\n      arrayEach(parentNode.__children, function (elem) {\n        rowCount += 1;\n        if (elem.__children) {\n          rowCount += _this4.countChildren(elem);\n        }\n      });\n      return rowCount;\n    }\n\n    /**\n     * Get the parent of the row at the provided index.\n     *\n     * @param {number|object} row Physical row index.\n     * @returns {object}\n     */\n  }, {\n    key: \"getRowParent\",\n    value: function getRowParent(row) {\n      var rowObject;\n      if (isNaN(row)) {\n        rowObject = row;\n      } else {\n        rowObject = this.getDataObject(row);\n      }\n      return this.getRowObjectParent(rowObject);\n    }\n\n    /**\n     * Get the parent of the provided row object.\n     *\n     * @private\n     * @param {object} rowObject The row object (tree node).\n     * @returns {object|null}\n     */\n  }, {\n    key: \"getRowObjectParent\",\n    value: function getRowObjectParent(rowObject) {\n      if (!rowObject || _typeof(rowObject) !== 'object') {\n        return null;\n      }\n      return this.cache.nodeInfo.get(rowObject).parent;\n    }\n\n    /**\n     * Get the nesting level for the row with the provided row index.\n     *\n     * @param {number} row Row index.\n     * @returns {number|null} Row level or null, when row doesn't exist.\n     */\n  }, {\n    key: \"getRowLevel\",\n    value: function getRowLevel(row) {\n      var rowObject = null;\n      if (isNaN(row)) {\n        rowObject = row;\n      } else {\n        rowObject = this.getDataObject(row);\n      }\n      return rowObject ? this.getRowObjectLevel(rowObject) : null;\n    }\n\n    /**\n     * Get the nesting level for the row with the provided row index.\n     *\n     * @private\n     * @param {object} rowObject Row object.\n     * @returns {number} Row level.\n     */\n  }, {\n    key: \"getRowObjectLevel\",\n    value: function getRowObjectLevel(rowObject) {\n      return rowObject === null || rowObject === void 0 ? null : this.cache.nodeInfo.get(rowObject).level;\n    }\n\n    /**\n     * Check if the provided row/row element has children.\n     *\n     * @param {number|object} row Row number or row element.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"hasChildren\",\n    value: function hasChildren(row) {\n      var rowObj = row;\n      if (!isNaN(rowObj)) {\n        rowObj = this.getDataObject(rowObj);\n      }\n      return !!(rowObj.__children && rowObj.__children.length);\n    }\n\n    /**\n     * Returns `true` if the row at the provided index has a parent.\n     *\n     * @param {number} index Row index.\n     * @returns {boolean} `true` if the row at the provided index has a parent, `false` otherwise.\n     */\n  }, {\n    key: \"isChild\",\n    value: function isChild(index) {\n      return this.getRowParent(index) !== null;\n    }\n\n    /**\n     * Get child at a provided index from the parent element.\n     *\n     * @param {object} parent The parent row object.\n     * @param {number} index Index of the child element to be retrieved.\n     * @returns {object|null} The child element or `null` if the child doesn't exist.\n     */\n  }, {\n    key: \"getChild\",\n    value: function getChild(parent, index) {\n      var _parent$__children;\n      return ((_parent$__children = parent.__children) === null || _parent$__children === void 0 ? void 0 : _parent$__children[index]) || null;\n    }\n\n    /**\n     * Return `true` of the row at the provided index is located at the topmost level.\n     *\n     * @param {number} index Row index.\n     * @returns {boolean} `true` of the row at the provided index is located at the topmost level, `false` otherwise.\n     */\n  }, {\n    key: \"isRowHighestLevel\",\n    value: function isRowHighestLevel(index) {\n      return !this.isChild(index);\n    }\n\n    /**\n     * Return `true` if the provided row index / row object represents a parent in the nested structure.\n     *\n     * @param {number|object} row Row index / row object.\n     * @returns {boolean} `true` if the row is a parent, `false` otherwise.\n     */\n  }, {\n    key: \"isParent\",\n    value: function isParent(row) {\n      var _rowObj$__children;\n      var rowObj = row;\n      if (!isNaN(rowObj)) {\n        rowObj = this.getDataObject(rowObj);\n      }\n      return rowObj && !!rowObj.__children && ((_rowObj$__children = rowObj.__children) === null || _rowObj$__children === void 0 ? void 0 : _rowObj$__children.length) !== 0;\n    }\n\n    /**\n     * Add a child to the provided parent. It's optional to add a row object as the \"element\".\n     *\n     * @param {object} parent The parent row object.\n     * @param {object} [element] The element to add as a child.\n     */\n  }, {\n    key: \"addChild\",\n    value: function addChild(parent, element) {\n      var childElement = element;\n      this.hot.runHooks('beforeAddChild', parent, childElement);\n      var parentIndex = null;\n      if (parent) {\n        parentIndex = this.getRowIndex(parent);\n      }\n      this.hot.runHooks('beforeCreateRow', parentIndex + this.countChildren(parent) + 1, 1);\n      var functionalParent = parent;\n      if (!parent) {\n        functionalParent = this.mockParent();\n      }\n      if (!functionalParent.__children) {\n        functionalParent.__children = [];\n      }\n      if (!childElement) {\n        childElement = this.mockNode();\n      }\n      functionalParent.__children.push(childElement);\n      this.rewriteCache();\n      var newRowIndex = this.getRowIndex(childElement);\n      this.hot.rowIndexMapper.insertIndexes(newRowIndex, 1);\n      this.hot.runHooks('afterCreateRow', newRowIndex, 1);\n      this.hot.runHooks('afterAddChild', parent, childElement);\n    }\n\n    /**\n     * Add a child node to the provided parent at a specified index.\n     *\n     * @param {object} parent Parent node.\n     * @param {number} index Index to insert the child element at.\n     * @param {object} [element] Element (node) to insert.\n     */\n  }, {\n    key: \"addChildAtIndex\",\n    value: function addChildAtIndex(parent, index, element) {\n      var childElement = element;\n      var flattenedIndex;\n      if (!childElement) {\n        childElement = this.mockNode();\n      }\n      this.hot.runHooks('beforeAddChild', parent, childElement, index);\n      if (parent) {\n        var parentIndex = this.getRowIndex(parent);\n        var finalChildIndex = parentIndex + index + 1;\n        this.hot.runHooks('beforeCreateRow', finalChildIndex, 1);\n        parent.__children.splice(index, null, childElement);\n        this.rewriteCache();\n        this.plugin.disableCoreAPIModifiers();\n        this.hot.setSourceDataAtCell(this.getRowIndexWithinParent(parent), '__children', parent.__children, 'NestedRows.addChildAtIndex');\n        this.hot.rowIndexMapper.insertIndexes(finalChildIndex, 1);\n        this.plugin.enableCoreAPIModifiers();\n        this.hot.runHooks('afterCreateRow', finalChildIndex, 1);\n        flattenedIndex = finalChildIndex;\n      } else {\n        this.plugin.disableCoreAPIModifiers();\n        this.hot.alter('insert_row_above', index, 1, 'NestedRows.addChildAtIndex');\n        this.plugin.enableCoreAPIModifiers();\n        flattenedIndex = this.getRowIndex(this.data[index]);\n      }\n\n      // Workaround for refreshing cache losing the reference to the mocked row.\n      childElement = this.getDataObject(flattenedIndex);\n      this.hot.runHooks('afterAddChild', parent, childElement, index);\n    }\n\n    /**\n     * Add a sibling element at the specified index.\n     *\n     * @param {number} index New element sibling's index.\n     * @param {('above'|'below')} where Direction in which the sibling is to be created.\n     */\n  }, {\n    key: \"addSibling\",\n    value: function addSibling(index) {\n      var where = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'below';\n      var translatedIndex = this.translateTrimmedRow(index);\n      var parent = this.getRowParent(translatedIndex);\n      var indexWithinParent = this.getRowIndexWithinParent(translatedIndex);\n      switch (where) {\n        case 'below':\n          this.addChildAtIndex(parent, indexWithinParent + 1, null);\n          break;\n        case 'above':\n          this.addChildAtIndex(parent, indexWithinParent, null);\n          break;\n        default:\n          break;\n      }\n    }\n\n    /**\n     * Detach the provided element from its parent and add it right after it.\n     *\n     * @param {object|Array} elements Row object or an array of selected coordinates.\n     * @param {boolean} [forceRender=true] If true (default), it triggers render after finished.\n     */\n  }, {\n    key: \"detachFromParent\",\n    value: function detachFromParent(elements) {\n      var _this5 = this;\n      var forceRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var element = null;\n      var rowObjects = [];\n      if (Array.isArray(elements)) {\n        rangeEach(elements[0], elements[2], function (i) {\n          var translatedIndex = _this5.translateTrimmedRow(i);\n          rowObjects.push(_this5.getDataObject(translatedIndex));\n        });\n        rangeEach(0, rowObjects.length - 2, function (i) {\n          _this5.detachFromParent(rowObjects[i], false);\n        });\n        element = rowObjects[rowObjects.length - 1];\n      } else {\n        element = elements;\n      }\n      var childRowIndex = this.getRowIndex(element);\n      var childCount = this.countChildren(element);\n      var indexWithinParent = this.getRowIndexWithinParent(element);\n      var parent = this.getRowParent(element);\n      var grandparent = this.getRowParent(parent);\n      var grandparentRowIndex = this.getRowIndex(grandparent);\n      var movedElementRowIndex = null;\n      this.hot.runHooks('beforeDetachChild', parent, element);\n      if (indexWithinParent !== null && indexWithinParent !== void 0) {\n        var removedRowIndexes = Array.from(new Array(childRowIndex + childCount + 1).keys()).splice(-1 * (childCount + 1));\n        this.hot.runHooks('beforeRemoveRow', childRowIndex, childCount + 1, removedRowIndexes, this.plugin.pluginName);\n        parent.__children.splice(indexWithinParent, 1);\n        this.rewriteCache();\n        this.hot.runHooks('afterRemoveRow', childRowIndex, childCount + 1, removedRowIndexes, this.plugin.pluginName);\n        if (grandparent) {\n          movedElementRowIndex = grandparentRowIndex + this.countChildren(grandparent);\n          var lastGrandparentChild = this.getChild(grandparent, this.countChildren(grandparent) - 1);\n          var lastGrandparentChildIndex = this.getRowIndex(lastGrandparentChild);\n          this.hot.runHooks('beforeCreateRow', lastGrandparentChildIndex + 1, childCount + 1, this.plugin.pluginName);\n          grandparent.__children.push(element);\n        } else {\n          movedElementRowIndex = this.hot.countRows() + 1;\n          this.hot.runHooks('beforeCreateRow', movedElementRowIndex - 2, childCount + 1, this.plugin.pluginName);\n          this.data.push(element);\n        }\n      }\n      this.rewriteCache();\n      this.hot.runHooks('afterCreateRow', movedElementRowIndex - 2, childCount + 1, this.plugin.pluginName);\n      this.hot.runHooks('afterDetachChild', parent, element, this.getRowIndex(element));\n      if (forceRender) {\n        this.hot.render();\n      }\n    }\n\n    /**\n     * Filter the data by the `logicRows` array.\n     *\n     * @private\n     * @param {number} index Index of the first row to remove.\n     * @param {number} amount Number of elements to remove.\n     * @param {Array} logicRows Array of indexes to remove.\n     */\n  }, {\n    key: \"filterData\",\n    value: function filterData(index, amount, logicRows) {\n      var _this6 = this;\n      // TODO: why are the first 2 arguments not used?\n\n      var elementsToRemove = [];\n      arrayEach(logicRows, function (elem) {\n        elementsToRemove.push(_this6.getDataObject(elem));\n      });\n      arrayEach(elementsToRemove, function (elem) {\n        var indexWithinParent = _this6.getRowIndexWithinParent(elem);\n        var tempParent = _this6.getRowParent(elem);\n        if (tempParent === null) {\n          _this6.data.splice(indexWithinParent, 1);\n        } else {\n          tempParent.__children.splice(indexWithinParent, 1);\n        }\n      });\n      this.rewriteCache();\n    }\n\n    /**\n     * Used to splice the source data. Needed to properly modify the nested structure, which wouldn't work with the\n     * default script.\n     *\n     * @private\n     * @param {number} index Physical index of the element at the splice beginning.\n     * @param {number} amount Number of elements to be removed.\n     * @param {object[]} elements Array of row objects to add.\n     */\n  }, {\n    key: \"spliceData\",\n    value: function spliceData(index, amount, elements) {\n      var previousElement = this.getDataObject(index - 1);\n      var newRowParent = null;\n      var indexWithinParent = index;\n      if (previousElement && previousElement.__children && previousElement.__children.length === 0) {\n        newRowParent = previousElement;\n        indexWithinParent = 0;\n      } else if (index < this.countAllRows()) {\n        newRowParent = this.getRowParent(index);\n        indexWithinParent = this.getRowIndexWithinParent(index);\n      }\n      if (newRowParent) {\n        if (elements) {\n          var _newRowParent$__child;\n          (_newRowParent$__child = newRowParent.__children).splice.apply(_newRowParent$__child, [indexWithinParent, amount].concat(_toConsumableArray(elements)));\n        } else {\n          newRowParent.__children.splice(indexWithinParent, amount);\n        }\n      } else if (elements) {\n        var _this$data;\n        (_this$data = this.data).splice.apply(_this$data, [indexWithinParent, amount].concat(_toConsumableArray(elements)));\n      } else {\n        this.data.splice(indexWithinParent, amount);\n      }\n      this.rewriteCache();\n    }\n\n    /**\n     * Update the `__children` key of the upmost parent of the provided row object.\n     *\n     * @private\n     * @param {object} rowElement Row object.\n     */\n  }, {\n    key: \"syncRowWithRawSource\",\n    value: function syncRowWithRawSource(rowElement) {\n      var upmostParent = rowElement;\n      var tempParent = null;\n      do {\n        tempParent = this.getRowParent(tempParent);\n        if (tempParent !== null) {\n          upmostParent = tempParent;\n        }\n      } while (tempParent !== null);\n      this.plugin.disableCoreAPIModifiers();\n      this.hot.setSourceDataAtCell(this.getRowIndex(upmostParent), '__children', upmostParent.__children, 'NestedRows.syncRowWithRawSource');\n      this.plugin.enableCoreAPIModifiers();\n    }\n\n    /* eslint-disable jsdoc/require-param */\n    /**\n     * Move a single row.\n     *\n     * @param {number} fromIndex Index of the row to be moved.\n     * @param {number} toIndex Index of the destination.\n     * @param {boolean} moveToCollapsed `true` if moving a row to a collapsed parent.\n     * @param {boolean} moveToLastChild `true` if moving a row to be a last child of the new parent.\n     */\n\n    /* eslint-enable jsdoc/require-param */\n  }, {\n    key: \"moveRow\",\n    value: function moveRow(fromIndex, toIndex, moveToCollapsed, moveToLastChild) {\n      var moveToLastRow = toIndex === this.hot.countRows();\n      var fromParent = this.getRowParent(fromIndex);\n      var indexInFromParent = this.getRowIndexWithinParent(fromIndex);\n      var elemToMove = fromParent.__children.slice(indexInFromParent, indexInFromParent + 1);\n      var movingUp = fromIndex > toIndex;\n      var toParent = moveToLastRow ? this.getRowParent(toIndex - 1) : this.getRowParent(toIndex);\n      if (toParent === null || toParent === void 0) {\n        toParent = this.getRowParent(toIndex - 1);\n      }\n      if (toParent === null || toParent === void 0) {\n        toParent = this.getDataObject(toIndex - 1);\n      }\n      if (!toParent) {\n        toParent = this.getDataObject(toIndex);\n        toParent.__children = [];\n      } else if (!toParent.__children) {\n        toParent.__children = [];\n      }\n      var indexInTargetParent = moveToLastRow || moveToCollapsed || moveToLastChild ? toParent.__children.length : this.getRowIndexWithinParent(toIndex);\n      var sameParent = fromParent === toParent;\n      toParent.__children.splice(indexInTargetParent, 0, elemToMove[0]);\n      fromParent.__children.splice(indexInFromParent + (movingUp && sameParent ? 1 : 0), 1);\n\n      // Sync the changes in the cached data with the actual data stored in HOT.\n      this.syncRowWithRawSource(fromParent);\n      if (!sameParent) {\n        this.syncRowWithRawSource(toParent);\n      }\n    }\n\n    /**\n     * Translate the visual row index to the physical index, taking into consideration the state of collapsed rows.\n     *\n     * @private\n     * @param {number} row Row index.\n     * @returns {number}\n     */\n  }, {\n    key: \"translateTrimmedRow\",\n    value: function translateTrimmedRow(row) {\n      if (this.plugin.collapsingUI) {\n        return this.plugin.collapsingUI.translateTrimmedRow(row);\n      }\n      return row;\n    }\n\n    /**\n     * Translate the physical row index to the visual index, taking into consideration the state of collapsed rows.\n     *\n     * @private\n     * @param {number} row Row index.\n     * @returns {number}\n     */\n  }, {\n    key: \"untranslateTrimmedRow\",\n    value: function untranslateTrimmedRow(row) {\n      if (this.plugin.collapsingUI) {\n        return this.plugin.collapsingUI.untranslateTrimmedRow(row);\n      }\n      return row;\n    }\n  }]);\n  return DataManager;\n}();\nexport default DataManager;","map":{"version":3,"names":["_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","o","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","Array","from","test","iter","Symbol","iterator","isArray","len","length","i","arr2","_typeof","obj","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","_toPropertyKey","key","_createClass","protoProps","staticProps","arg","_toPrimitive","String","input","hint","prim","toPrimitive","undefined","res","Number","rangeEach","objectEach","arrayEach","DataManager","nestedRowsPlugin","hotInstance","hot","data","plugin","parentReference","WeakMap","cache","levels","levelCount","rows","nodeInfo","value","setData","getData","getRawSourceData","rawSourceData","disableCoreAPIModifiers","getSourceData","enableCoreAPIModifiers","updateWithData","rewriteCache","_this","cacheNode","node","level","parent","_this2","push","set","row","hasChildren","__children","elem","getDataObject","readTreeNodes","readCount","neededIndex","neededObject","_this3","rootLevel","readNodesCount","isNaN","end","parentObj","result","val","mockParent","fakeParent","mockNode","fakeNode","getRowIndex","rowObj","get","getRowIndexWithinParent","getRowParent","indexOf","countAllRows","rootNodeMock","countChildren","_this4","rowCount","parentNode","rowObject","getRowObjectParent","getRowLevel","getRowObjectLevel","isChild","index","getChild","_parent$__children","isRowHighestLevel","isParent","_rowObj$__children","addChild","element","childElement","runHooks","parentIndex","functionalParent","newRowIndex","rowIndexMapper","insertIndexes","addChildAtIndex","flattenedIndex","finalChildIndex","splice","setSourceDataAtCell","alter","addSibling","where","arguments","translatedIndex","translateTrimmedRow","indexWithinParent","detachFromParent","elements","_this5","forceRender","rowObjects","childRowIndex","childCount","grandparent","grandparentRowIndex","movedElementRowIndex","removedRowIndexes","keys","pluginName","lastGrandparentChild","lastGrandparentChildIndex","countRows","render","filterData","amount","logicRows","_this6","elementsToRemove","tempParent","spliceData","previousElement","newRowParent","_newRowParent$__child","apply","concat","_this$data","syncRowWithRawSource","rowElement","upmostParent","moveRow","fromIndex","toIndex","moveToCollapsed","moveToLastChild","moveToLastRow","fromParent","indexInFromParent","elemToMove","movingUp","toParent","indexInTargetParent","sameParent","collapsingUI","untranslateTrimmedRow"],"sources":["/home/rstorey/wwwdev/Blucktool/node_modules/handsontable/plugins/nestedRows/data/dataManager.mjs"],"sourcesContent":["function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.weak-map.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.symbol.to-primitive.js\";\nimport \"core-js/modules/es.date.to-primitive.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { rangeEach } from \"../../../helpers/number.mjs\";\nimport { objectEach } from \"../../../helpers/object.mjs\";\nimport { arrayEach } from \"../../../helpers/array.mjs\";\n/**\n * Class responsible for making data operations.\n *\n * @private\n */\nvar DataManager = /*#__PURE__*/function () {\n  function DataManager(nestedRowsPlugin, hotInstance) {\n    _classCallCheck(this, DataManager);\n    /**\n     * Main Handsontable instance reference.\n     *\n     * @type {object}\n     */\n    this.hot = hotInstance;\n    /**\n     * Reference to the source data object.\n     *\n     * @type {Handsontable.CellValue[][]|Handsontable.RowObject[]}\n     */\n    this.data = null;\n    /**\n     * Reference to the NestedRows plugin.\n     *\n     * @type {object}\n     */\n    this.plugin = nestedRowsPlugin;\n    /**\n     * Map of row object parents.\n     *\n     * @type {WeakMap}\n     */\n    this.parentReference = new WeakMap();\n    /**\n     * Nested structure cache.\n     *\n     * @type {object}\n     */\n    this.cache = {\n      levels: [],\n      levelCount: 0,\n      rows: [],\n      nodeInfo: new WeakMap()\n    };\n  }\n\n  /**\n   * Set the data for the manager.\n   *\n   * @param {Handsontable.CellValue[][]|Handsontable.RowObject[]} data Data for the manager.\n   */\n  _createClass(DataManager, [{\n    key: \"setData\",\n    value: function setData(data) {\n      this.data = data;\n    }\n\n    /**\n     * Get the data cached in the manager.\n     *\n     * @returns {Handsontable.CellValue[][]|Handsontable.RowObject[]}\n     */\n  }, {\n    key: \"getData\",\n    value: function getData() {\n      return this.data;\n    }\n\n    /**\n     * Load the \"raw\" source data, without NestedRows' modifications.\n     *\n     * @returns {Handsontable.CellValue[][]|Handsontable.RowObject[]}\n     */\n  }, {\n    key: \"getRawSourceData\",\n    value: function getRawSourceData() {\n      var rawSourceData = null;\n      this.plugin.disableCoreAPIModifiers();\n      rawSourceData = this.hot.getSourceData();\n      this.plugin.enableCoreAPIModifiers();\n      return rawSourceData;\n    }\n\n    /**\n     * Update the Data Manager with new data and refresh cache.\n     *\n     * @param {Handsontable.CellValue[][]|Handsontable.RowObject[]} data Data for the manager.\n     */\n  }, {\n    key: \"updateWithData\",\n    value: function updateWithData(data) {\n      this.setData(data);\n      this.rewriteCache();\n    }\n\n    /**\n     * Rewrite the nested structure cache.\n     *\n     * @private\n     */\n  }, {\n    key: \"rewriteCache\",\n    value: function rewriteCache() {\n      var _this = this;\n      this.cache = {\n        levels: [],\n        levelCount: 0,\n        rows: [],\n        nodeInfo: new WeakMap()\n      };\n      rangeEach(0, this.data.length - 1, function (i) {\n        _this.cacheNode(_this.data[i], 0, null);\n      });\n    }\n\n    /**\n     * Cache a data node.\n     *\n     * @private\n     * @param {object} node Node to cache.\n     * @param {number} level Level of the node.\n     * @param {object} parent Parent of the node.\n     */\n  }, {\n    key: \"cacheNode\",\n    value: function cacheNode(node, level, parent) {\n      var _this2 = this;\n      if (!this.cache.levels[level]) {\n        this.cache.levels[level] = [];\n        this.cache.levelCount += 1;\n      }\n      this.cache.levels[level].push(node);\n      this.cache.rows.push(node);\n      this.cache.nodeInfo.set(node, {\n        parent: parent,\n        row: this.cache.rows.length - 1,\n        level: level\n      });\n      if (this.hasChildren(node)) {\n        arrayEach(node.__children, function (elem) {\n          _this2.cacheNode(elem, level + 1, node);\n        });\n      }\n    }\n\n    /**\n     * Get the date for the provided visual row number.\n     *\n     * @param {number} row Row index.\n     * @returns {object}\n     */\n  }, {\n    key: \"getDataObject\",\n    value: function getDataObject(row) {\n      return row === null || row === void 0 ? null : this.cache.rows[row];\n    }\n\n    /**\n     * Read the row tree in search for a specific row index or row object.\n     *\n     * @private\n     * @param {object} parent The initial parent object.\n     * @param {number} readCount Number of read nodes.\n     * @param {number} neededIndex The row index we search for.\n     * @param {object} neededObject The row object we search for.\n     * @returns {number|object}\n     */\n  }, {\n    key: \"readTreeNodes\",\n    value: function readTreeNodes(parent, readCount, neededIndex, neededObject) {\n      var _this3 = this;\n      var rootLevel = false;\n      var readNodesCount = readCount;\n      if (isNaN(readNodesCount) && readNodesCount.end) {\n        return readNodesCount;\n      }\n      var parentObj = parent;\n      if (!parentObj) {\n        parentObj = {\n          __children: this.data\n        };\n        rootLevel = true;\n        readNodesCount -= 1;\n      }\n      if (neededIndex !== null && neededIndex !== void 0 && readNodesCount === neededIndex) {\n        return {\n          result: parentObj,\n          end: true\n        };\n      }\n      if (neededObject !== null && neededObject !== void 0 && parentObj === neededObject) {\n        return {\n          result: readNodesCount,\n          end: true\n        };\n      }\n      readNodesCount += 1;\n      if (parentObj.__children) {\n        arrayEach(parentObj.__children, function (val) {\n          _this3.parentReference.set(val, rootLevel ? null : parentObj);\n          readNodesCount = _this3.readTreeNodes(val, readNodesCount, neededIndex, neededObject);\n          if (isNaN(readNodesCount) && readNodesCount.end) {\n            return false;\n          }\n        });\n      }\n      return readNodesCount;\n    }\n\n    /**\n     * Mock a parent node.\n     *\n     * @private\n     * @returns {*}\n     */\n  }, {\n    key: \"mockParent\",\n    value: function mockParent() {\n      var fakeParent = this.mockNode();\n      fakeParent.__children = this.data;\n      return fakeParent;\n    }\n\n    /**\n     * Mock a data node.\n     *\n     * @private\n     * @returns {{}}\n     */\n  }, {\n    key: \"mockNode\",\n    value: function mockNode() {\n      var fakeNode = {};\n      objectEach(this.data[0], function (val, key) {\n        fakeNode[key] = null;\n      });\n      return fakeNode;\n    }\n\n    /**\n     * Get the row index for the provided row object.\n     *\n     * @param {object} rowObj The row object.\n     * @returns {number} Row index.\n     */\n  }, {\n    key: \"getRowIndex\",\n    value: function getRowIndex(rowObj) {\n      return rowObj === null || rowObj === void 0 ? null : this.cache.nodeInfo.get(rowObj).row;\n    }\n\n    /**\n     * Get the index of the provided row index/row object within its parent.\n     *\n     * @param {number|object} row Row index / row object.\n     * @returns {number}\n     */\n  }, {\n    key: \"getRowIndexWithinParent\",\n    value: function getRowIndexWithinParent(row) {\n      var rowObj = null;\n      if (isNaN(row)) {\n        rowObj = row;\n      } else {\n        rowObj = this.getDataObject(row);\n      }\n      var parent = this.getRowParent(row);\n      if (parent === null || parent === void 0) {\n        return this.data.indexOf(rowObj);\n      }\n      return parent.__children.indexOf(rowObj);\n    }\n\n    /**\n     * Count all rows (including all parents and children).\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"countAllRows\",\n    value: function countAllRows() {\n      var rootNodeMock = {\n        __children: this.data\n      };\n      return this.countChildren(rootNodeMock);\n    }\n\n    /**\n     * Count children of the provided parent.\n     *\n     * @param {object|number} parent Parent node.\n     * @returns {number} Children count.\n     */\n  }, {\n    key: \"countChildren\",\n    value: function countChildren(parent) {\n      var _this4 = this;\n      var rowCount = 0;\n      var parentNode = parent;\n      if (!isNaN(parentNode)) {\n        parentNode = this.getDataObject(parentNode);\n      }\n      if (!parentNode || !parentNode.__children) {\n        return 0;\n      }\n      arrayEach(parentNode.__children, function (elem) {\n        rowCount += 1;\n        if (elem.__children) {\n          rowCount += _this4.countChildren(elem);\n        }\n      });\n      return rowCount;\n    }\n\n    /**\n     * Get the parent of the row at the provided index.\n     *\n     * @param {number|object} row Physical row index.\n     * @returns {object}\n     */\n  }, {\n    key: \"getRowParent\",\n    value: function getRowParent(row) {\n      var rowObject;\n      if (isNaN(row)) {\n        rowObject = row;\n      } else {\n        rowObject = this.getDataObject(row);\n      }\n      return this.getRowObjectParent(rowObject);\n    }\n\n    /**\n     * Get the parent of the provided row object.\n     *\n     * @private\n     * @param {object} rowObject The row object (tree node).\n     * @returns {object|null}\n     */\n  }, {\n    key: \"getRowObjectParent\",\n    value: function getRowObjectParent(rowObject) {\n      if (!rowObject || _typeof(rowObject) !== 'object') {\n        return null;\n      }\n      return this.cache.nodeInfo.get(rowObject).parent;\n    }\n\n    /**\n     * Get the nesting level for the row with the provided row index.\n     *\n     * @param {number} row Row index.\n     * @returns {number|null} Row level or null, when row doesn't exist.\n     */\n  }, {\n    key: \"getRowLevel\",\n    value: function getRowLevel(row) {\n      var rowObject = null;\n      if (isNaN(row)) {\n        rowObject = row;\n      } else {\n        rowObject = this.getDataObject(row);\n      }\n      return rowObject ? this.getRowObjectLevel(rowObject) : null;\n    }\n\n    /**\n     * Get the nesting level for the row with the provided row index.\n     *\n     * @private\n     * @param {object} rowObject Row object.\n     * @returns {number} Row level.\n     */\n  }, {\n    key: \"getRowObjectLevel\",\n    value: function getRowObjectLevel(rowObject) {\n      return rowObject === null || rowObject === void 0 ? null : this.cache.nodeInfo.get(rowObject).level;\n    }\n\n    /**\n     * Check if the provided row/row element has children.\n     *\n     * @param {number|object} row Row number or row element.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"hasChildren\",\n    value: function hasChildren(row) {\n      var rowObj = row;\n      if (!isNaN(rowObj)) {\n        rowObj = this.getDataObject(rowObj);\n      }\n      return !!(rowObj.__children && rowObj.__children.length);\n    }\n\n    /**\n     * Returns `true` if the row at the provided index has a parent.\n     *\n     * @param {number} index Row index.\n     * @returns {boolean} `true` if the row at the provided index has a parent, `false` otherwise.\n     */\n  }, {\n    key: \"isChild\",\n    value: function isChild(index) {\n      return this.getRowParent(index) !== null;\n    }\n\n    /**\n     * Get child at a provided index from the parent element.\n     *\n     * @param {object} parent The parent row object.\n     * @param {number} index Index of the child element to be retrieved.\n     * @returns {object|null} The child element or `null` if the child doesn't exist.\n     */\n  }, {\n    key: \"getChild\",\n    value: function getChild(parent, index) {\n      var _parent$__children;\n      return ((_parent$__children = parent.__children) === null || _parent$__children === void 0 ? void 0 : _parent$__children[index]) || null;\n    }\n\n    /**\n     * Return `true` of the row at the provided index is located at the topmost level.\n     *\n     * @param {number} index Row index.\n     * @returns {boolean} `true` of the row at the provided index is located at the topmost level, `false` otherwise.\n     */\n  }, {\n    key: \"isRowHighestLevel\",\n    value: function isRowHighestLevel(index) {\n      return !this.isChild(index);\n    }\n\n    /**\n     * Return `true` if the provided row index / row object represents a parent in the nested structure.\n     *\n     * @param {number|object} row Row index / row object.\n     * @returns {boolean} `true` if the row is a parent, `false` otherwise.\n     */\n  }, {\n    key: \"isParent\",\n    value: function isParent(row) {\n      var _rowObj$__children;\n      var rowObj = row;\n      if (!isNaN(rowObj)) {\n        rowObj = this.getDataObject(rowObj);\n      }\n      return rowObj && !!rowObj.__children && ((_rowObj$__children = rowObj.__children) === null || _rowObj$__children === void 0 ? void 0 : _rowObj$__children.length) !== 0;\n    }\n\n    /**\n     * Add a child to the provided parent. It's optional to add a row object as the \"element\".\n     *\n     * @param {object} parent The parent row object.\n     * @param {object} [element] The element to add as a child.\n     */\n  }, {\n    key: \"addChild\",\n    value: function addChild(parent, element) {\n      var childElement = element;\n      this.hot.runHooks('beforeAddChild', parent, childElement);\n      var parentIndex = null;\n      if (parent) {\n        parentIndex = this.getRowIndex(parent);\n      }\n      this.hot.runHooks('beforeCreateRow', parentIndex + this.countChildren(parent) + 1, 1);\n      var functionalParent = parent;\n      if (!parent) {\n        functionalParent = this.mockParent();\n      }\n      if (!functionalParent.__children) {\n        functionalParent.__children = [];\n      }\n      if (!childElement) {\n        childElement = this.mockNode();\n      }\n      functionalParent.__children.push(childElement);\n      this.rewriteCache();\n      var newRowIndex = this.getRowIndex(childElement);\n      this.hot.rowIndexMapper.insertIndexes(newRowIndex, 1);\n      this.hot.runHooks('afterCreateRow', newRowIndex, 1);\n      this.hot.runHooks('afterAddChild', parent, childElement);\n    }\n\n    /**\n     * Add a child node to the provided parent at a specified index.\n     *\n     * @param {object} parent Parent node.\n     * @param {number} index Index to insert the child element at.\n     * @param {object} [element] Element (node) to insert.\n     */\n  }, {\n    key: \"addChildAtIndex\",\n    value: function addChildAtIndex(parent, index, element) {\n      var childElement = element;\n      var flattenedIndex;\n      if (!childElement) {\n        childElement = this.mockNode();\n      }\n      this.hot.runHooks('beforeAddChild', parent, childElement, index);\n      if (parent) {\n        var parentIndex = this.getRowIndex(parent);\n        var finalChildIndex = parentIndex + index + 1;\n        this.hot.runHooks('beforeCreateRow', finalChildIndex, 1);\n        parent.__children.splice(index, null, childElement);\n        this.rewriteCache();\n        this.plugin.disableCoreAPIModifiers();\n        this.hot.setSourceDataAtCell(this.getRowIndexWithinParent(parent), '__children', parent.__children, 'NestedRows.addChildAtIndex');\n        this.hot.rowIndexMapper.insertIndexes(finalChildIndex, 1);\n        this.plugin.enableCoreAPIModifiers();\n        this.hot.runHooks('afterCreateRow', finalChildIndex, 1);\n        flattenedIndex = finalChildIndex;\n      } else {\n        this.plugin.disableCoreAPIModifiers();\n        this.hot.alter('insert_row_above', index, 1, 'NestedRows.addChildAtIndex');\n        this.plugin.enableCoreAPIModifiers();\n        flattenedIndex = this.getRowIndex(this.data[index]);\n      }\n\n      // Workaround for refreshing cache losing the reference to the mocked row.\n      childElement = this.getDataObject(flattenedIndex);\n      this.hot.runHooks('afterAddChild', parent, childElement, index);\n    }\n\n    /**\n     * Add a sibling element at the specified index.\n     *\n     * @param {number} index New element sibling's index.\n     * @param {('above'|'below')} where Direction in which the sibling is to be created.\n     */\n  }, {\n    key: \"addSibling\",\n    value: function addSibling(index) {\n      var where = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'below';\n      var translatedIndex = this.translateTrimmedRow(index);\n      var parent = this.getRowParent(translatedIndex);\n      var indexWithinParent = this.getRowIndexWithinParent(translatedIndex);\n      switch (where) {\n        case 'below':\n          this.addChildAtIndex(parent, indexWithinParent + 1, null);\n          break;\n        case 'above':\n          this.addChildAtIndex(parent, indexWithinParent, null);\n          break;\n        default:\n          break;\n      }\n    }\n\n    /**\n     * Detach the provided element from its parent and add it right after it.\n     *\n     * @param {object|Array} elements Row object or an array of selected coordinates.\n     * @param {boolean} [forceRender=true] If true (default), it triggers render after finished.\n     */\n  }, {\n    key: \"detachFromParent\",\n    value: function detachFromParent(elements) {\n      var _this5 = this;\n      var forceRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var element = null;\n      var rowObjects = [];\n      if (Array.isArray(elements)) {\n        rangeEach(elements[0], elements[2], function (i) {\n          var translatedIndex = _this5.translateTrimmedRow(i);\n          rowObjects.push(_this5.getDataObject(translatedIndex));\n        });\n        rangeEach(0, rowObjects.length - 2, function (i) {\n          _this5.detachFromParent(rowObjects[i], false);\n        });\n        element = rowObjects[rowObjects.length - 1];\n      } else {\n        element = elements;\n      }\n      var childRowIndex = this.getRowIndex(element);\n      var childCount = this.countChildren(element);\n      var indexWithinParent = this.getRowIndexWithinParent(element);\n      var parent = this.getRowParent(element);\n      var grandparent = this.getRowParent(parent);\n      var grandparentRowIndex = this.getRowIndex(grandparent);\n      var movedElementRowIndex = null;\n      this.hot.runHooks('beforeDetachChild', parent, element);\n      if (indexWithinParent !== null && indexWithinParent !== void 0) {\n        var removedRowIndexes = Array.from(new Array(childRowIndex + childCount + 1).keys()).splice(-1 * (childCount + 1));\n        this.hot.runHooks('beforeRemoveRow', childRowIndex, childCount + 1, removedRowIndexes, this.plugin.pluginName);\n        parent.__children.splice(indexWithinParent, 1);\n        this.rewriteCache();\n        this.hot.runHooks('afterRemoveRow', childRowIndex, childCount + 1, removedRowIndexes, this.plugin.pluginName);\n        if (grandparent) {\n          movedElementRowIndex = grandparentRowIndex + this.countChildren(grandparent);\n          var lastGrandparentChild = this.getChild(grandparent, this.countChildren(grandparent) - 1);\n          var lastGrandparentChildIndex = this.getRowIndex(lastGrandparentChild);\n          this.hot.runHooks('beforeCreateRow', lastGrandparentChildIndex + 1, childCount + 1, this.plugin.pluginName);\n          grandparent.__children.push(element);\n        } else {\n          movedElementRowIndex = this.hot.countRows() + 1;\n          this.hot.runHooks('beforeCreateRow', movedElementRowIndex - 2, childCount + 1, this.plugin.pluginName);\n          this.data.push(element);\n        }\n      }\n      this.rewriteCache();\n      this.hot.runHooks('afterCreateRow', movedElementRowIndex - 2, childCount + 1, this.plugin.pluginName);\n      this.hot.runHooks('afterDetachChild', parent, element, this.getRowIndex(element));\n      if (forceRender) {\n        this.hot.render();\n      }\n    }\n\n    /**\n     * Filter the data by the `logicRows` array.\n     *\n     * @private\n     * @param {number} index Index of the first row to remove.\n     * @param {number} amount Number of elements to remove.\n     * @param {Array} logicRows Array of indexes to remove.\n     */\n  }, {\n    key: \"filterData\",\n    value: function filterData(index, amount, logicRows) {\n      var _this6 = this;\n      // TODO: why are the first 2 arguments not used?\n\n      var elementsToRemove = [];\n      arrayEach(logicRows, function (elem) {\n        elementsToRemove.push(_this6.getDataObject(elem));\n      });\n      arrayEach(elementsToRemove, function (elem) {\n        var indexWithinParent = _this6.getRowIndexWithinParent(elem);\n        var tempParent = _this6.getRowParent(elem);\n        if (tempParent === null) {\n          _this6.data.splice(indexWithinParent, 1);\n        } else {\n          tempParent.__children.splice(indexWithinParent, 1);\n        }\n      });\n      this.rewriteCache();\n    }\n\n    /**\n     * Used to splice the source data. Needed to properly modify the nested structure, which wouldn't work with the\n     * default script.\n     *\n     * @private\n     * @param {number} index Physical index of the element at the splice beginning.\n     * @param {number} amount Number of elements to be removed.\n     * @param {object[]} elements Array of row objects to add.\n     */\n  }, {\n    key: \"spliceData\",\n    value: function spliceData(index, amount, elements) {\n      var previousElement = this.getDataObject(index - 1);\n      var newRowParent = null;\n      var indexWithinParent = index;\n      if (previousElement && previousElement.__children && previousElement.__children.length === 0) {\n        newRowParent = previousElement;\n        indexWithinParent = 0;\n      } else if (index < this.countAllRows()) {\n        newRowParent = this.getRowParent(index);\n        indexWithinParent = this.getRowIndexWithinParent(index);\n      }\n      if (newRowParent) {\n        if (elements) {\n          var _newRowParent$__child;\n          (_newRowParent$__child = newRowParent.__children).splice.apply(_newRowParent$__child, [indexWithinParent, amount].concat(_toConsumableArray(elements)));\n        } else {\n          newRowParent.__children.splice(indexWithinParent, amount);\n        }\n      } else if (elements) {\n        var _this$data;\n        (_this$data = this.data).splice.apply(_this$data, [indexWithinParent, amount].concat(_toConsumableArray(elements)));\n      } else {\n        this.data.splice(indexWithinParent, amount);\n      }\n      this.rewriteCache();\n    }\n\n    /**\n     * Update the `__children` key of the upmost parent of the provided row object.\n     *\n     * @private\n     * @param {object} rowElement Row object.\n     */\n  }, {\n    key: \"syncRowWithRawSource\",\n    value: function syncRowWithRawSource(rowElement) {\n      var upmostParent = rowElement;\n      var tempParent = null;\n      do {\n        tempParent = this.getRowParent(tempParent);\n        if (tempParent !== null) {\n          upmostParent = tempParent;\n        }\n      } while (tempParent !== null);\n      this.plugin.disableCoreAPIModifiers();\n      this.hot.setSourceDataAtCell(this.getRowIndex(upmostParent), '__children', upmostParent.__children, 'NestedRows.syncRowWithRawSource');\n      this.plugin.enableCoreAPIModifiers();\n    }\n\n    /* eslint-disable jsdoc/require-param */\n    /**\n     * Move a single row.\n     *\n     * @param {number} fromIndex Index of the row to be moved.\n     * @param {number} toIndex Index of the destination.\n     * @param {boolean} moveToCollapsed `true` if moving a row to a collapsed parent.\n     * @param {boolean} moveToLastChild `true` if moving a row to be a last child of the new parent.\n     */\n\n    /* eslint-enable jsdoc/require-param */\n  }, {\n    key: \"moveRow\",\n    value: function moveRow(fromIndex, toIndex, moveToCollapsed, moveToLastChild) {\n      var moveToLastRow = toIndex === this.hot.countRows();\n      var fromParent = this.getRowParent(fromIndex);\n      var indexInFromParent = this.getRowIndexWithinParent(fromIndex);\n      var elemToMove = fromParent.__children.slice(indexInFromParent, indexInFromParent + 1);\n      var movingUp = fromIndex > toIndex;\n      var toParent = moveToLastRow ? this.getRowParent(toIndex - 1) : this.getRowParent(toIndex);\n      if (toParent === null || toParent === void 0) {\n        toParent = this.getRowParent(toIndex - 1);\n      }\n      if (toParent === null || toParent === void 0) {\n        toParent = this.getDataObject(toIndex - 1);\n      }\n      if (!toParent) {\n        toParent = this.getDataObject(toIndex);\n        toParent.__children = [];\n      } else if (!toParent.__children) {\n        toParent.__children = [];\n      }\n      var indexInTargetParent = moveToLastRow || moveToCollapsed || moveToLastChild ? toParent.__children.length : this.getRowIndexWithinParent(toIndex);\n      var sameParent = fromParent === toParent;\n      toParent.__children.splice(indexInTargetParent, 0, elemToMove[0]);\n      fromParent.__children.splice(indexInFromParent + (movingUp && sameParent ? 1 : 0), 1);\n\n      // Sync the changes in the cached data with the actual data stored in HOT.\n      this.syncRowWithRawSource(fromParent);\n      if (!sameParent) {\n        this.syncRowWithRawSource(toParent);\n      }\n    }\n\n    /**\n     * Translate the visual row index to the physical index, taking into consideration the state of collapsed rows.\n     *\n     * @private\n     * @param {number} row Row index.\n     * @returns {number}\n     */\n  }, {\n    key: \"translateTrimmedRow\",\n    value: function translateTrimmedRow(row) {\n      if (this.plugin.collapsingUI) {\n        return this.plugin.collapsingUI.translateTrimmedRow(row);\n      }\n      return row;\n    }\n\n    /**\n     * Translate the physical row index to the visual index, taking into consideration the state of collapsed rows.\n     *\n     * @private\n     * @param {number} row Row index.\n     * @returns {number}\n     */\n  }, {\n    key: \"untranslateTrimmedRow\",\n    value: function untranslateTrimmedRow(row) {\n      if (this.plugin.collapsingUI) {\n        return this.plugin.collapsingUI.untranslateTrimmedRow(row);\n      }\n      return row;\n    }\n  }]);\n  return DataManager;\n}();\nexport default DataManager;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}