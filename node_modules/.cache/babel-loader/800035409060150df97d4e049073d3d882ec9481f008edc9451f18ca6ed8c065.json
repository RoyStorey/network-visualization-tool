{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nimport { innerHeight, innerWidth, getScrollLeft, getScrollTop, offset } from \"../../../helpers/dom/element.mjs\";\n/**\n * @class Scroll\n */\nvar Scroll = /*#__PURE__*/function () {\n  /**\n   * The data access object.\n   *\n   * @protected\n   * @type {ScrollDao}\n   */\n\n  /**\n   * Holds the last column reached by the scroll, which determines the scroll snapping direction\n   * (left or right) for a next horizontal scroll.\n   *\n   * @protected\n   * @type {number}\n   */\n\n  /**\n   * Holds the last row reached by the scroll, which determines the scroll snapping direction\n   * (top or bottom) for a next vertical scroll.\n   *\n   * @protected\n   * @type {number}\n   */\n\n  /**\n   * @param {ScrollDao} dataAccessObject Tha data access object.\n   */\n  function Scroll(dataAccessObject) {\n    _classCallCheck(this, Scroll);\n    _defineProperty(this, \"dataAccessObject\", void 0);\n    _defineProperty(this, \"lastScrolledColumnPos\", -1);\n    _defineProperty(this, \"lastScrolledRowPos\", -1);\n    this.dataAccessObject = dataAccessObject;\n  }\n\n  /**\n   * Scrolls viewport to a cell.\n   *\n   * @param {CellCoords} coords The cell coordinates.\n   * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.\n   * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right of the table.\n   * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom of the table.\n   * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left of the table.\n   * @returns {boolean}\n   */\n  _createClass(Scroll, [{\n    key: \"scrollViewport\",\n    value: function scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft) {\n      var scrolledHorizontally = this.scrollViewportHorizontally(coords.col, snapToRight, snapToLeft);\n      var scrolledVertically = this.scrollViewportVertically(coords.row, snapToTop, snapToBottom);\n      return scrolledHorizontally || scrolledVertically;\n    }\n\n    /**\n     * Scrolls viewport to a column.\n     *\n     * @param {number} column Visual column index.\n     * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right of the table.\n     * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left of the table.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"scrollViewportHorizontally\",\n    value: function scrollViewportHorizontally(column, snapToRight, snapToLeft) {\n      var _this$dataAccessObjec = this.dataAccessObject,\n        drawn = _this$dataAccessObjec.drawn,\n        totalColumns = _this$dataAccessObjec.totalColumns;\n\n      // do not scroll the viewport when the column points to a range outside of the dataset\n      if (!drawn || !Number.isInteger(column) || column < 0 || column > totalColumns) {\n        return false;\n      }\n      var firstVisibleColumn = this.getFirstVisibleColumn();\n      var lastVisibleColumn = this.getLastVisibleColumn();\n      var autoSnapping = snapToRight === void 0 && snapToLeft === void 0;\n      var _this$dataAccessObjec2 = this.dataAccessObject,\n        fixedColumnsStart = _this$dataAccessObjec2.fixedColumnsStart,\n        inlineStartOverlay = _this$dataAccessObjec2.inlineStartOverlay;\n\n      // for auto-snapping (both snap* arguments are undefined) do not scroll the viewport\n      // when the columns points to the overlays\n      if (autoSnapping && column < fixedColumnsStart) {\n        return false;\n      }\n      var result = false;\n\n      // if there is no fully visible columns use the supporting variable (lastScrolledColumnPos) to\n      // determine the snapping direction (left or right)\n      if (firstVisibleColumn === -1) {\n        result = inlineStartOverlay.scrollTo(column, autoSnapping ? column > this.lastScrolledColumnPos : snapToRight);\n      } else if (autoSnapping && (column < firstVisibleColumn || column > lastVisibleColumn) || !autoSnapping) {\n        // if there is at least one fully visible column determine the snapping direction based on\n        // that columns or by snapToRight/snapToLeft flags, if provided.\n        result = inlineStartOverlay.scrollTo(column, autoSnapping ? column > lastVisibleColumn : snapToRight);\n      }\n      if (result) {\n        this.lastScrolledColumnPos = column;\n      }\n      return result;\n    }\n\n    /**\n     * Scrolls viewport to a row.\n     *\n     * @param {number} row Visual row index.\n     * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.\n     * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom of the table.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"scrollViewportVertically\",\n    value: function scrollViewportVertically(row, snapToTop, snapToBottom) {\n      var _this$dataAccessObjec3 = this.dataAccessObject,\n        drawn = _this$dataAccessObjec3.drawn,\n        totalRows = _this$dataAccessObjec3.totalRows;\n\n      // do not scroll the viewport when the row points to a range outside of the dataset\n      if (!drawn || !Number.isInteger(row) || row < 0 || row > totalRows) {\n        return false;\n      }\n      var firstVisibleRow = this.getFirstVisibleRow();\n      var lastVisibleRow = this.getLastVisibleRow();\n      var autoSnapping = snapToTop === void 0 && snapToBottom === void 0;\n      var _this$dataAccessObjec4 = this.dataAccessObject,\n        fixedRowsBottom = _this$dataAccessObjec4.fixedRowsBottom,\n        fixedRowsTop = _this$dataAccessObjec4.fixedRowsTop,\n        topOverlay = _this$dataAccessObjec4.topOverlay;\n\n      // for auto-snapping (both snap* arguments are undefined) do not scroll the viewport\n      // when the rows points to the overlays\n      if (autoSnapping && (row < fixedRowsTop || row > totalRows - fixedRowsBottom - 1)) {\n        return false;\n      }\n      var result = false;\n\n      // if there is no fully visible rows use the supporting variable (lastScrolledRowPos) to\n      // determine the snapping direction (top or bottom)\n      if (firstVisibleRow === -1) {\n        result = topOverlay.scrollTo(row, autoSnapping ? row > this.lastScrolledRowPos : snapToBottom);\n      } else if (autoSnapping && (row < firstVisibleRow || row > lastVisibleRow) || !autoSnapping) {\n        // if there is at least one fully visible row determine the snapping direction based on\n        // that rows or by snapToTop/snapToBottom flags, if provided.\n        result = topOverlay.scrollTo(row, autoSnapping ? row > lastVisibleRow : snapToBottom);\n      }\n      if (result) {\n        this.lastScrolledRowPos = row;\n      }\n      return result;\n    }\n\n    /**\n     * Get first visible row based on virtual dom and how table is visible in browser window viewport.\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getFirstVisibleRow\",\n    value: function getFirstVisibleRow() {\n      var _this$dataAccessObjec5 = this.dataAccessObject,\n        topOverlay = _this$dataAccessObjec5.topOverlay,\n        wtTable = _this$dataAccessObjec5.wtTable,\n        wtViewport = _this$dataAccessObjec5.wtViewport,\n        totalRows = _this$dataAccessObjec5.totalRows,\n        fixedRowsTop = _this$dataAccessObjec5.fixedRowsTop,\n        rootWindow = _this$dataAccessObjec5.rootWindow;\n      var firstVisibleRow = wtTable.getFirstVisibleRow();\n      if (topOverlay.mainTableScrollableElement === rootWindow) {\n        var rootElementOffset = offset(wtTable.wtRootElement);\n        var totalTableHeight = innerHeight(wtTable.hider);\n        var windowHeight = innerHeight(rootWindow);\n        var windowScrollTop = getScrollTop(rootWindow, rootWindow);\n\n        // Only calculate firstVisibleRow when table didn't filled (from up) whole viewport space\n        if (rootElementOffset.top + totalTableHeight - windowHeight <= windowScrollTop) {\n          var rowsHeight = wtViewport.getColumnHeaderHeight();\n          rowsHeight += topOverlay.sumCellSizes(0, fixedRowsTop);\n          for (var row = totalRows; row > 0; row--) {\n            rowsHeight += topOverlay.sumCellSizes(row - 1, row);\n            if (rootElementOffset.top + totalTableHeight - rowsHeight <= windowScrollTop) {\n              // Return physical row + 1\n              firstVisibleRow = row;\n              break;\n            }\n          }\n        }\n      }\n      return firstVisibleRow;\n    }\n\n    /**\n     * Get last visible row based on virtual dom and how table is visible in browser window viewport.\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getLastVisibleRow\",\n    value: function getLastVisibleRow() {\n      var _this$dataAccessObjec6 = this.dataAccessObject,\n        topOverlay = _this$dataAccessObjec6.topOverlay,\n        wtTable = _this$dataAccessObjec6.wtTable,\n        wtViewport = _this$dataAccessObjec6.wtViewport,\n        totalRows = _this$dataAccessObjec6.totalRows,\n        rootWindow = _this$dataAccessObjec6.rootWindow;\n      var lastVisibleRow = wtTable.getLastVisibleRow();\n      if (topOverlay.mainTableScrollableElement === rootWindow) {\n        var rootElementOffset = offset(wtTable.wtRootElement);\n        var windowScrollTop = getScrollTop(rootWindow, rootWindow);\n\n        // Only calculate lastVisibleRow when table didn't filled (from bottom) whole viewport space\n        if (rootElementOffset.top > windowScrollTop) {\n          var windowHeight = innerHeight(rootWindow);\n          var rowsHeight = wtViewport.getColumnHeaderHeight();\n          for (var row = 1; row <= totalRows; row++) {\n            rowsHeight += topOverlay.sumCellSizes(row - 1, row);\n            if (rootElementOffset.top + rowsHeight - windowScrollTop >= windowHeight) {\n              // Return physical row - 1 (-2 because rangeEach gives row index + 1 - sumCellSizes requirements)\n              lastVisibleRow = row - 2;\n              break;\n            }\n          }\n        }\n      }\n      return lastVisibleRow;\n    }\n\n    /**\n     * Get first visible column based on virtual dom and how table is visible in browser window viewport.\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getFirstVisibleColumn\",\n    value: function getFirstVisibleColumn() {\n      var _this$dataAccessObjec7 = this.dataAccessObject,\n        inlineStartOverlay = _this$dataAccessObjec7.inlineStartOverlay,\n        wtTable = _this$dataAccessObjec7.wtTable,\n        wtViewport = _this$dataAccessObjec7.wtViewport,\n        totalColumns = _this$dataAccessObjec7.totalColumns,\n        rootWindow = _this$dataAccessObjec7.rootWindow;\n      var firstVisibleColumn = wtTable.getFirstVisibleColumn();\n      if (inlineStartOverlay.mainTableScrollableElement === rootWindow) {\n        var rootElementOffset = offset(wtTable.wtRootElement);\n        var totalTableWidth = innerWidth(wtTable.hider);\n        var windowWidth = innerWidth(rootWindow);\n        var windowScrollLeft = Math.abs(getScrollLeft(rootWindow, rootWindow));\n\n        // Only calculate firstVisibleColumn when table didn't filled (from left) whole viewport space\n        if (rootElementOffset.left + totalTableWidth - windowWidth <= windowScrollLeft) {\n          var columnsWidth = wtViewport.getRowHeaderWidth();\n          for (var column = totalColumns; column > 0; column--) {\n            columnsWidth += inlineStartOverlay.sumCellSizes(column - 1, column);\n            if (rootElementOffset.left + totalTableWidth - columnsWidth <= windowScrollLeft) {\n              // Return physical column + 1\n              firstVisibleColumn = column;\n              break;\n            }\n          }\n        }\n      }\n      return firstVisibleColumn;\n    }\n\n    /**\n     * Get last visible column based on virtual dom and how table is visible in browser window viewport.\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getLastVisibleColumn\",\n    value: function getLastVisibleColumn() {\n      var _this$dataAccessObjec8 = this.dataAccessObject,\n        inlineStartOverlay = _this$dataAccessObjec8.inlineStartOverlay,\n        wtTable = _this$dataAccessObjec8.wtTable,\n        wtViewport = _this$dataAccessObjec8.wtViewport,\n        totalColumns = _this$dataAccessObjec8.totalColumns,\n        rootWindow = _this$dataAccessObjec8.rootWindow;\n      var lastVisibleColumn = wtTable.getLastVisibleColumn();\n      if (inlineStartOverlay.mainTableScrollableElement === rootWindow) {\n        var rootElementOffset = offset(wtTable.wtRootElement);\n        var windowScrollLeft = Math.abs(getScrollLeft(rootWindow, rootWindow));\n\n        // Only calculate lastVisibleColumn when table didn't filled (from right) whole viewport space\n        if (rootElementOffset.left > windowScrollLeft) {\n          var windowWidth = innerWidth(rootWindow);\n          var columnsWidth = wtViewport.getRowHeaderWidth();\n          for (var column = 1; column <= totalColumns; column++) {\n            columnsWidth += inlineStartOverlay.sumCellSizes(column - 1, column);\n            if (rootElementOffset.left + columnsWidth - windowScrollLeft >= windowWidth) {\n              // Return physical column - 1 (-2 because rangeEach gives column index + 1 - sumCellSizes requirements)\n              lastVisibleColumn = column - 2;\n              break;\n            }\n          }\n        }\n      }\n      return lastVisibleColumn;\n    }\n  }]);\n  return Scroll;\n}();\nexport default Scroll;","map":{"version":3,"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","_toPropertyKey","key","_createClass","protoProps","staticProps","_defineProperty","value","arg","_toPrimitive","String","input","hint","prim","toPrimitive","undefined","res","call","Number","innerHeight","innerWidth","getScrollLeft","getScrollTop","offset","Scroll","dataAccessObject","scrollViewport","coords","snapToTop","snapToRight","snapToBottom","snapToLeft","scrolledHorizontally","scrollViewportHorizontally","col","scrolledVertically","scrollViewportVertically","row","column","_this$dataAccessObjec","drawn","totalColumns","isInteger","firstVisibleColumn","getFirstVisibleColumn","lastVisibleColumn","getLastVisibleColumn","autoSnapping","_this$dataAccessObjec2","fixedColumnsStart","inlineStartOverlay","result","scrollTo","lastScrolledColumnPos","_this$dataAccessObjec3","totalRows","firstVisibleRow","getFirstVisibleRow","lastVisibleRow","getLastVisibleRow","_this$dataAccessObjec4","fixedRowsBottom","fixedRowsTop","topOverlay","lastScrolledRowPos","_this$dataAccessObjec5","wtTable","wtViewport","rootWindow","mainTableScrollableElement","rootElementOffset","wtRootElement","totalTableHeight","hider","windowHeight","windowScrollTop","top","rowsHeight","getColumnHeaderHeight","sumCellSizes","_this$dataAccessObjec6","_this$dataAccessObjec7","totalTableWidth","windowWidth","windowScrollLeft","Math","abs","left","columnsWidth","getRowHeaderWidth","_this$dataAccessObjec8"],"sources":["/home/rstorey/wwwdev/Blucktool/node_modules/handsontable/3rdparty/walkontable/src/scroll.mjs"],"sourcesContent":["function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nimport \"core-js/modules/es.number.is-integer.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.symbol.to-primitive.js\";\nimport \"core-js/modules/es.date.to-primitive.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { innerHeight, innerWidth, getScrollLeft, getScrollTop, offset } from \"../../../helpers/dom/element.mjs\";\n/**\n * @class Scroll\n */\nvar Scroll = /*#__PURE__*/function () {\n  /**\n   * The data access object.\n   *\n   * @protected\n   * @type {ScrollDao}\n   */\n\n  /**\n   * Holds the last column reached by the scroll, which determines the scroll snapping direction\n   * (left or right) for a next horizontal scroll.\n   *\n   * @protected\n   * @type {number}\n   */\n\n  /**\n   * Holds the last row reached by the scroll, which determines the scroll snapping direction\n   * (top or bottom) for a next vertical scroll.\n   *\n   * @protected\n   * @type {number}\n   */\n\n  /**\n   * @param {ScrollDao} dataAccessObject Tha data access object.\n   */\n  function Scroll(dataAccessObject) {\n    _classCallCheck(this, Scroll);\n    _defineProperty(this, \"dataAccessObject\", void 0);\n    _defineProperty(this, \"lastScrolledColumnPos\", -1);\n    _defineProperty(this, \"lastScrolledRowPos\", -1);\n    this.dataAccessObject = dataAccessObject;\n  }\n\n  /**\n   * Scrolls viewport to a cell.\n   *\n   * @param {CellCoords} coords The cell coordinates.\n   * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.\n   * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right of the table.\n   * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom of the table.\n   * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left of the table.\n   * @returns {boolean}\n   */\n  _createClass(Scroll, [{\n    key: \"scrollViewport\",\n    value: function scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft) {\n      var scrolledHorizontally = this.scrollViewportHorizontally(coords.col, snapToRight, snapToLeft);\n      var scrolledVertically = this.scrollViewportVertically(coords.row, snapToTop, snapToBottom);\n      return scrolledHorizontally || scrolledVertically;\n    }\n\n    /**\n     * Scrolls viewport to a column.\n     *\n     * @param {number} column Visual column index.\n     * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right of the table.\n     * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left of the table.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"scrollViewportHorizontally\",\n    value: function scrollViewportHorizontally(column, snapToRight, snapToLeft) {\n      var _this$dataAccessObjec = this.dataAccessObject,\n        drawn = _this$dataAccessObjec.drawn,\n        totalColumns = _this$dataAccessObjec.totalColumns;\n\n      // do not scroll the viewport when the column points to a range outside of the dataset\n      if (!drawn || !Number.isInteger(column) || column < 0 || column > totalColumns) {\n        return false;\n      }\n      var firstVisibleColumn = this.getFirstVisibleColumn();\n      var lastVisibleColumn = this.getLastVisibleColumn();\n      var autoSnapping = snapToRight === void 0 && snapToLeft === void 0;\n      var _this$dataAccessObjec2 = this.dataAccessObject,\n        fixedColumnsStart = _this$dataAccessObjec2.fixedColumnsStart,\n        inlineStartOverlay = _this$dataAccessObjec2.inlineStartOverlay;\n\n      // for auto-snapping (both snap* arguments are undefined) do not scroll the viewport\n      // when the columns points to the overlays\n      if (autoSnapping && column < fixedColumnsStart) {\n        return false;\n      }\n      var result = false;\n\n      // if there is no fully visible columns use the supporting variable (lastScrolledColumnPos) to\n      // determine the snapping direction (left or right)\n      if (firstVisibleColumn === -1) {\n        result = inlineStartOverlay.scrollTo(column, autoSnapping ? column > this.lastScrolledColumnPos : snapToRight);\n      } else if (autoSnapping && (column < firstVisibleColumn || column > lastVisibleColumn) || !autoSnapping) {\n        // if there is at least one fully visible column determine the snapping direction based on\n        // that columns or by snapToRight/snapToLeft flags, if provided.\n        result = inlineStartOverlay.scrollTo(column, autoSnapping ? column > lastVisibleColumn : snapToRight);\n      }\n      if (result) {\n        this.lastScrolledColumnPos = column;\n      }\n      return result;\n    }\n\n    /**\n     * Scrolls viewport to a row.\n     *\n     * @param {number} row Visual row index.\n     * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.\n     * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom of the table.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"scrollViewportVertically\",\n    value: function scrollViewportVertically(row, snapToTop, snapToBottom) {\n      var _this$dataAccessObjec3 = this.dataAccessObject,\n        drawn = _this$dataAccessObjec3.drawn,\n        totalRows = _this$dataAccessObjec3.totalRows;\n\n      // do not scroll the viewport when the row points to a range outside of the dataset\n      if (!drawn || !Number.isInteger(row) || row < 0 || row > totalRows) {\n        return false;\n      }\n      var firstVisibleRow = this.getFirstVisibleRow();\n      var lastVisibleRow = this.getLastVisibleRow();\n      var autoSnapping = snapToTop === void 0 && snapToBottom === void 0;\n      var _this$dataAccessObjec4 = this.dataAccessObject,\n        fixedRowsBottom = _this$dataAccessObjec4.fixedRowsBottom,\n        fixedRowsTop = _this$dataAccessObjec4.fixedRowsTop,\n        topOverlay = _this$dataAccessObjec4.topOverlay;\n\n      // for auto-snapping (both snap* arguments are undefined) do not scroll the viewport\n      // when the rows points to the overlays\n      if (autoSnapping && (row < fixedRowsTop || row > totalRows - fixedRowsBottom - 1)) {\n        return false;\n      }\n      var result = false;\n\n      // if there is no fully visible rows use the supporting variable (lastScrolledRowPos) to\n      // determine the snapping direction (top or bottom)\n      if (firstVisibleRow === -1) {\n        result = topOverlay.scrollTo(row, autoSnapping ? row > this.lastScrolledRowPos : snapToBottom);\n      } else if (autoSnapping && (row < firstVisibleRow || row > lastVisibleRow) || !autoSnapping) {\n        // if there is at least one fully visible row determine the snapping direction based on\n        // that rows or by snapToTop/snapToBottom flags, if provided.\n        result = topOverlay.scrollTo(row, autoSnapping ? row > lastVisibleRow : snapToBottom);\n      }\n      if (result) {\n        this.lastScrolledRowPos = row;\n      }\n      return result;\n    }\n\n    /**\n     * Get first visible row based on virtual dom and how table is visible in browser window viewport.\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getFirstVisibleRow\",\n    value: function getFirstVisibleRow() {\n      var _this$dataAccessObjec5 = this.dataAccessObject,\n        topOverlay = _this$dataAccessObjec5.topOverlay,\n        wtTable = _this$dataAccessObjec5.wtTable,\n        wtViewport = _this$dataAccessObjec5.wtViewport,\n        totalRows = _this$dataAccessObjec5.totalRows,\n        fixedRowsTop = _this$dataAccessObjec5.fixedRowsTop,\n        rootWindow = _this$dataAccessObjec5.rootWindow;\n      var firstVisibleRow = wtTable.getFirstVisibleRow();\n      if (topOverlay.mainTableScrollableElement === rootWindow) {\n        var rootElementOffset = offset(wtTable.wtRootElement);\n        var totalTableHeight = innerHeight(wtTable.hider);\n        var windowHeight = innerHeight(rootWindow);\n        var windowScrollTop = getScrollTop(rootWindow, rootWindow);\n\n        // Only calculate firstVisibleRow when table didn't filled (from up) whole viewport space\n        if (rootElementOffset.top + totalTableHeight - windowHeight <= windowScrollTop) {\n          var rowsHeight = wtViewport.getColumnHeaderHeight();\n          rowsHeight += topOverlay.sumCellSizes(0, fixedRowsTop);\n          for (var row = totalRows; row > 0; row--) {\n            rowsHeight += topOverlay.sumCellSizes(row - 1, row);\n            if (rootElementOffset.top + totalTableHeight - rowsHeight <= windowScrollTop) {\n              // Return physical row + 1\n              firstVisibleRow = row;\n              break;\n            }\n          }\n        }\n      }\n      return firstVisibleRow;\n    }\n\n    /**\n     * Get last visible row based on virtual dom and how table is visible in browser window viewport.\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getLastVisibleRow\",\n    value: function getLastVisibleRow() {\n      var _this$dataAccessObjec6 = this.dataAccessObject,\n        topOverlay = _this$dataAccessObjec6.topOverlay,\n        wtTable = _this$dataAccessObjec6.wtTable,\n        wtViewport = _this$dataAccessObjec6.wtViewport,\n        totalRows = _this$dataAccessObjec6.totalRows,\n        rootWindow = _this$dataAccessObjec6.rootWindow;\n      var lastVisibleRow = wtTable.getLastVisibleRow();\n      if (topOverlay.mainTableScrollableElement === rootWindow) {\n        var rootElementOffset = offset(wtTable.wtRootElement);\n        var windowScrollTop = getScrollTop(rootWindow, rootWindow);\n\n        // Only calculate lastVisibleRow when table didn't filled (from bottom) whole viewport space\n        if (rootElementOffset.top > windowScrollTop) {\n          var windowHeight = innerHeight(rootWindow);\n          var rowsHeight = wtViewport.getColumnHeaderHeight();\n          for (var row = 1; row <= totalRows; row++) {\n            rowsHeight += topOverlay.sumCellSizes(row - 1, row);\n            if (rootElementOffset.top + rowsHeight - windowScrollTop >= windowHeight) {\n              // Return physical row - 1 (-2 because rangeEach gives row index + 1 - sumCellSizes requirements)\n              lastVisibleRow = row - 2;\n              break;\n            }\n          }\n        }\n      }\n      return lastVisibleRow;\n    }\n\n    /**\n     * Get first visible column based on virtual dom and how table is visible in browser window viewport.\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getFirstVisibleColumn\",\n    value: function getFirstVisibleColumn() {\n      var _this$dataAccessObjec7 = this.dataAccessObject,\n        inlineStartOverlay = _this$dataAccessObjec7.inlineStartOverlay,\n        wtTable = _this$dataAccessObjec7.wtTable,\n        wtViewport = _this$dataAccessObjec7.wtViewport,\n        totalColumns = _this$dataAccessObjec7.totalColumns,\n        rootWindow = _this$dataAccessObjec7.rootWindow;\n      var firstVisibleColumn = wtTable.getFirstVisibleColumn();\n      if (inlineStartOverlay.mainTableScrollableElement === rootWindow) {\n        var rootElementOffset = offset(wtTable.wtRootElement);\n        var totalTableWidth = innerWidth(wtTable.hider);\n        var windowWidth = innerWidth(rootWindow);\n        var windowScrollLeft = Math.abs(getScrollLeft(rootWindow, rootWindow));\n\n        // Only calculate firstVisibleColumn when table didn't filled (from left) whole viewport space\n        if (rootElementOffset.left + totalTableWidth - windowWidth <= windowScrollLeft) {\n          var columnsWidth = wtViewport.getRowHeaderWidth();\n          for (var column = totalColumns; column > 0; column--) {\n            columnsWidth += inlineStartOverlay.sumCellSizes(column - 1, column);\n            if (rootElementOffset.left + totalTableWidth - columnsWidth <= windowScrollLeft) {\n              // Return physical column + 1\n              firstVisibleColumn = column;\n              break;\n            }\n          }\n        }\n      }\n      return firstVisibleColumn;\n    }\n\n    /**\n     * Get last visible column based on virtual dom and how table is visible in browser window viewport.\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getLastVisibleColumn\",\n    value: function getLastVisibleColumn() {\n      var _this$dataAccessObjec8 = this.dataAccessObject,\n        inlineStartOverlay = _this$dataAccessObjec8.inlineStartOverlay,\n        wtTable = _this$dataAccessObjec8.wtTable,\n        wtViewport = _this$dataAccessObjec8.wtViewport,\n        totalColumns = _this$dataAccessObjec8.totalColumns,\n        rootWindow = _this$dataAccessObjec8.rootWindow;\n      var lastVisibleColumn = wtTable.getLastVisibleColumn();\n      if (inlineStartOverlay.mainTableScrollableElement === rootWindow) {\n        var rootElementOffset = offset(wtTable.wtRootElement);\n        var windowScrollLeft = Math.abs(getScrollLeft(rootWindow, rootWindow));\n\n        // Only calculate lastVisibleColumn when table didn't filled (from right) whole viewport space\n        if (rootElementOffset.left > windowScrollLeft) {\n          var windowWidth = innerWidth(rootWindow);\n          var columnsWidth = wtViewport.getRowHeaderWidth();\n          for (var column = 1; column <= totalColumns; column++) {\n            columnsWidth += inlineStartOverlay.sumCellSizes(column - 1, column);\n            if (rootElementOffset.left + columnsWidth - windowScrollLeft >= windowWidth) {\n              // Return physical column - 1 (-2 because rangeEach gives column index + 1 - sumCellSizes requirements)\n              lastVisibleColumn = column - 2;\n              break;\n            }\n          }\n        }\n      }\n      return lastVisibleColumn;\n    }\n  }]);\n  return Scroll;\n}();\nexport default Scroll;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}