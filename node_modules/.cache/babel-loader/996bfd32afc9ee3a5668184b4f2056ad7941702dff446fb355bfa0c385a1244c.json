{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nimport { isObject } from \"./../helpers/object.mjs\";\nimport { rangeEach } from \"./../helpers/number.mjs\";\nimport { stringify } from \"./../helpers/mixed.mjs\";\n/**\n * @class SamplesGenerator\n */\nvar SamplesGenerator = /*#__PURE__*/function () {\n  function SamplesGenerator(dataFactory) {\n    _classCallCheck(this, SamplesGenerator);\n    /**\n     * Samples prepared for calculations.\n     *\n     * @type {Map}\n     * @default {null}\n     */\n    this.samples = null;\n    /**\n     * Function which give the data to collect samples.\n     *\n     * @type {Function}\n     */\n    this.dataFactory = dataFactory;\n    /**\n     * Custom number of samples to take of each value length.\n     *\n     * @type {number}\n     * @default {null}\n     */\n    this.customSampleCount = null;\n    /**\n     * `true` if duplicate samples collection should be allowed, `false` otherwise.\n     *\n     * @type {boolean}\n     * @default {false}\n     */\n    this.allowDuplicates = false;\n  }\n\n  /**\n   * Get the sample count for this instance.\n   *\n   * @returns {number}\n   */\n  _createClass(SamplesGenerator, [{\n    key: \"getSampleCount\",\n    value: function getSampleCount() {\n      if (this.customSampleCount) {\n        return this.customSampleCount;\n      }\n      return SamplesGenerator.SAMPLE_COUNT;\n    }\n\n    /**\n     * Set the sample count.\n     *\n     * @param {number} sampleCount Number of samples to be collected.\n     */\n  }, {\n    key: \"setSampleCount\",\n    value: function setSampleCount(sampleCount) {\n      this.customSampleCount = sampleCount;\n    }\n\n    /**\n     * Set if the generator should accept duplicate values.\n     *\n     * @param {boolean} allowDuplicates `true` to allow duplicate values.\n     */\n  }, {\n    key: \"setAllowDuplicates\",\n    value: function setAllowDuplicates(allowDuplicates) {\n      this.allowDuplicates = allowDuplicates;\n    }\n\n    /**\n     * Generate samples for row. You can control which area should be sampled by passing `rowRange` object and `colRange` object.\n     *\n     * @param {object|number} rowRange The rows range to generate the samples.\n     * @param {object} colRange The column range to generate the samples.\n     * @returns {object}\n     */\n  }, {\n    key: \"generateRowSamples\",\n    value: function generateRowSamples(rowRange, colRange) {\n      return this.generateSamples('row', colRange, rowRange);\n    }\n\n    /**\n     * Generate samples for column. You can control which area should be sampled by passing `colRange` object and `rowRange` object.\n     *\n     * @param {object} colRange Column index.\n     * @param {object} rowRange Column index.\n     * @returns {object}\n     */\n  }, {\n    key: \"generateColumnSamples\",\n    value: function generateColumnSamples(colRange, rowRange) {\n      return this.generateSamples('col', rowRange, colRange);\n    }\n\n    /**\n     * Generate collection of samples.\n     *\n     * @param {string} type Type to generate. Can be `col` or `row`.\n     * @param {object} range The range to generate the samples.\n     * @param {object|number} specifierRange The range to generate the samples.\n     * @returns {Map}\n     */\n  }, {\n    key: \"generateSamples\",\n    value: function generateSamples(type, range, specifierRange) {\n      var _this = this;\n      var samples = new Map();\n      var _ref = typeof specifierRange === 'number' ? {\n          from: specifierRange,\n          to: specifierRange\n        } : specifierRange,\n        from = _ref.from,\n        to = _ref.to;\n      rangeEach(from, to, function (index) {\n        var sample = _this.generateSample(type, range, index);\n        samples.set(index, sample);\n      });\n      return samples;\n    }\n\n    /**\n     * Generate sample for specified type (`row` or `col`).\n     *\n     * @param {string} type Samples type `row` or `col`.\n     * @param {object} range The range to generate the samples.\n     * @param {number} specifierValue The range to generate the samples.\n     * @returns {Map}\n     */\n  }, {\n    key: \"generateSample\",\n    value: function generateSample(type, range, specifierValue) {\n      var _this2 = this;\n      if (type !== 'row' && type !== 'col') {\n        throw new Error('Unsupported sample type');\n      }\n      var samples = new Map();\n      var computedKey = type === 'row' ? 'col' : 'row';\n      var sampledValues = [];\n      rangeEach(range.from, range.to, function (index) {\n        var _ref2 = type === 'row' ? _this2.dataFactory(specifierValue, index) : _this2.dataFactory(index, specifierValue),\n          value = _ref2.value,\n          bundleSeed = _ref2.bundleSeed;\n        var hasCustomBundleSeed = typeof bundleSeed === 'string' && bundleSeed.length > 0;\n        var seed;\n        if (hasCustomBundleSeed) {\n          seed = bundleSeed;\n        } else if (isObject(value)) {\n          seed = \"\".concat(Object.keys(value).length);\n        } else if (Array.isArray(value)) {\n          seed = \"\".concat(value.length);\n        } else {\n          seed = \"\".concat(stringify(value).length);\n        }\n        if (!samples.has(seed)) {\n          samples.set(seed, {\n            needed: _this2.getSampleCount(),\n            strings: []\n          });\n        }\n        var sample = samples.get(seed);\n        if (sample.needed) {\n          var duplicate = sampledValues.indexOf(value) > -1;\n          if (!duplicate || _this2.allowDuplicates || hasCustomBundleSeed) {\n            sample.strings.push(_defineProperty({\n              value: value\n            }, computedKey, index));\n            sampledValues.push(value);\n            sample.needed -= 1;\n          }\n        }\n      });\n      return samples;\n    }\n  }], [{\n    key: \"SAMPLE_COUNT\",\n    get:\n    /**\n     * Number of samples to take of each value length.\n     *\n     * @type {number}\n     */\n    function get() {\n      return 3;\n    }\n  }]);\n  return SamplesGenerator;\n}();\nexport default SamplesGenerator;","map":{"version":3,"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_defineProperty","key","value","_toPropertyKey","Object","defineProperty","enumerable","configurable","writable","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","_createClass","protoProps","staticProps","arg","_toPrimitive","String","input","hint","prim","toPrimitive","undefined","res","call","Number","isObject","rangeEach","stringify","SamplesGenerator","dataFactory","samples","customSampleCount","allowDuplicates","getSampleCount","SAMPLE_COUNT","setSampleCount","sampleCount","setAllowDuplicates","generateRowSamples","rowRange","colRange","generateSamples","generateColumnSamples","type","range","specifierRange","_this","Map","_ref","from","to","index","sample","generateSample","set","specifierValue","_this2","Error","computedKey","sampledValues","_ref2","bundleSeed","hasCustomBundleSeed","seed","concat","keys","Array","isArray","has","needed","strings","get","duplicate","indexOf","push"],"sources":["/home/rstorey/wwwdev/Blucktool/node_modules/handsontable/utils/samplesGenerator.mjs"],"sourcesContent":["function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.symbol.to-primitive.js\";\nimport \"core-js/modules/es.date.to-primitive.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { isObject } from \"./../helpers/object.mjs\";\nimport { rangeEach } from \"./../helpers/number.mjs\";\nimport { stringify } from \"./../helpers/mixed.mjs\";\n/**\n * @class SamplesGenerator\n */\nvar SamplesGenerator = /*#__PURE__*/function () {\n  function SamplesGenerator(dataFactory) {\n    _classCallCheck(this, SamplesGenerator);\n    /**\n     * Samples prepared for calculations.\n     *\n     * @type {Map}\n     * @default {null}\n     */\n    this.samples = null;\n    /**\n     * Function which give the data to collect samples.\n     *\n     * @type {Function}\n     */\n    this.dataFactory = dataFactory;\n    /**\n     * Custom number of samples to take of each value length.\n     *\n     * @type {number}\n     * @default {null}\n     */\n    this.customSampleCount = null;\n    /**\n     * `true` if duplicate samples collection should be allowed, `false` otherwise.\n     *\n     * @type {boolean}\n     * @default {false}\n     */\n    this.allowDuplicates = false;\n  }\n\n  /**\n   * Get the sample count for this instance.\n   *\n   * @returns {number}\n   */\n  _createClass(SamplesGenerator, [{\n    key: \"getSampleCount\",\n    value: function getSampleCount() {\n      if (this.customSampleCount) {\n        return this.customSampleCount;\n      }\n      return SamplesGenerator.SAMPLE_COUNT;\n    }\n\n    /**\n     * Set the sample count.\n     *\n     * @param {number} sampleCount Number of samples to be collected.\n     */\n  }, {\n    key: \"setSampleCount\",\n    value: function setSampleCount(sampleCount) {\n      this.customSampleCount = sampleCount;\n    }\n\n    /**\n     * Set if the generator should accept duplicate values.\n     *\n     * @param {boolean} allowDuplicates `true` to allow duplicate values.\n     */\n  }, {\n    key: \"setAllowDuplicates\",\n    value: function setAllowDuplicates(allowDuplicates) {\n      this.allowDuplicates = allowDuplicates;\n    }\n\n    /**\n     * Generate samples for row. You can control which area should be sampled by passing `rowRange` object and `colRange` object.\n     *\n     * @param {object|number} rowRange The rows range to generate the samples.\n     * @param {object} colRange The column range to generate the samples.\n     * @returns {object}\n     */\n  }, {\n    key: \"generateRowSamples\",\n    value: function generateRowSamples(rowRange, colRange) {\n      return this.generateSamples('row', colRange, rowRange);\n    }\n\n    /**\n     * Generate samples for column. You can control which area should be sampled by passing `colRange` object and `rowRange` object.\n     *\n     * @param {object} colRange Column index.\n     * @param {object} rowRange Column index.\n     * @returns {object}\n     */\n  }, {\n    key: \"generateColumnSamples\",\n    value: function generateColumnSamples(colRange, rowRange) {\n      return this.generateSamples('col', rowRange, colRange);\n    }\n\n    /**\n     * Generate collection of samples.\n     *\n     * @param {string} type Type to generate. Can be `col` or `row`.\n     * @param {object} range The range to generate the samples.\n     * @param {object|number} specifierRange The range to generate the samples.\n     * @returns {Map}\n     */\n  }, {\n    key: \"generateSamples\",\n    value: function generateSamples(type, range, specifierRange) {\n      var _this = this;\n      var samples = new Map();\n      var _ref = typeof specifierRange === 'number' ? {\n          from: specifierRange,\n          to: specifierRange\n        } : specifierRange,\n        from = _ref.from,\n        to = _ref.to;\n      rangeEach(from, to, function (index) {\n        var sample = _this.generateSample(type, range, index);\n        samples.set(index, sample);\n      });\n      return samples;\n    }\n\n    /**\n     * Generate sample for specified type (`row` or `col`).\n     *\n     * @param {string} type Samples type `row` or `col`.\n     * @param {object} range The range to generate the samples.\n     * @param {number} specifierValue The range to generate the samples.\n     * @returns {Map}\n     */\n  }, {\n    key: \"generateSample\",\n    value: function generateSample(type, range, specifierValue) {\n      var _this2 = this;\n      if (type !== 'row' && type !== 'col') {\n        throw new Error('Unsupported sample type');\n      }\n      var samples = new Map();\n      var computedKey = type === 'row' ? 'col' : 'row';\n      var sampledValues = [];\n      rangeEach(range.from, range.to, function (index) {\n        var _ref2 = type === 'row' ? _this2.dataFactory(specifierValue, index) : _this2.dataFactory(index, specifierValue),\n          value = _ref2.value,\n          bundleSeed = _ref2.bundleSeed;\n        var hasCustomBundleSeed = typeof bundleSeed === 'string' && bundleSeed.length > 0;\n        var seed;\n        if (hasCustomBundleSeed) {\n          seed = bundleSeed;\n        } else if (isObject(value)) {\n          seed = \"\".concat(Object.keys(value).length);\n        } else if (Array.isArray(value)) {\n          seed = \"\".concat(value.length);\n        } else {\n          seed = \"\".concat(stringify(value).length);\n        }\n        if (!samples.has(seed)) {\n          samples.set(seed, {\n            needed: _this2.getSampleCount(),\n            strings: []\n          });\n        }\n        var sample = samples.get(seed);\n        if (sample.needed) {\n          var duplicate = sampledValues.indexOf(value) > -1;\n          if (!duplicate || _this2.allowDuplicates || hasCustomBundleSeed) {\n            sample.strings.push(_defineProperty({\n              value: value\n            }, computedKey, index));\n            sampledValues.push(value);\n            sample.needed -= 1;\n          }\n        }\n      });\n      return samples;\n    }\n  }], [{\n    key: \"SAMPLE_COUNT\",\n    get:\n    /**\n     * Number of samples to take of each value length.\n     *\n     * @type {number}\n     */\n    function get() {\n      return 3;\n    }\n  }]);\n  return SamplesGenerator;\n}();\nexport default SamplesGenerator;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}