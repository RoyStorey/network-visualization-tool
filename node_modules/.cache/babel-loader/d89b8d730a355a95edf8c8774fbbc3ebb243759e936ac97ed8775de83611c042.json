{"ast":null,"code":"function _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (_x = (_i = _i.call(arr)).next, 0 === i) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n    } catch (err) {\n      _d = !0, _e = err;\n    } finally {\n      try {\n        if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nimport { CellRange } from \"./../3rdparty/walkontable/src/index.mjs\";\nimport { arrayEach, arrayReduce } from \"./../helpers/array.mjs\";\nimport { isUndefined } from \"./../helpers/mixed.mjs\";\nexport var SELECTION_TYPE_UNRECOGNIZED = 0;\nexport var SELECTION_TYPE_EMPTY = 1;\nexport var SELECTION_TYPE_ARRAY = 2;\nexport var SELECTION_TYPE_OBJECT = 3;\nexport var SELECTION_TYPES = [SELECTION_TYPE_OBJECT, SELECTION_TYPE_ARRAY];\nvar ARRAY_TYPE_PATTERN = [['number'], ['number', 'string'], ['number', 'undefined'], ['number', 'string', 'undefined']];\nvar rootCall = Symbol('root');\nvar childCall = Symbol('child');\n\n/**\n * Detect selection schema structure.\n *\n * @param {*} selectionRanges The selected range or and array of selected ranges. This type of data is produced by\n * `hot.getSelected()`, `hot.getSelectedLast()`, `hot.getSelectedRange()`\n * and `hot.getSelectedRangeLast()` methods.\n * @param {symbol} _callSymbol The symbol object which indicates source of the helper invocation.\n * @returns {number} Returns a number that specifies the type of detected selection schema. If selection schema type\n * is unrecognized than it returns `0`.\n */\nexport function detectSelectionType(selectionRanges) {\n  var _callSymbol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : rootCall;\n  if (_callSymbol !== rootCall && _callSymbol !== childCall) {\n    throw new Error('The second argument is used internally only and cannot be overwritten.');\n  }\n  var isArray = Array.isArray(selectionRanges);\n  var isRootCall = _callSymbol === rootCall;\n  var result = SELECTION_TYPE_UNRECOGNIZED;\n  if (isArray) {\n    var firstItem = selectionRanges[0];\n    if (selectionRanges.length === 0) {\n      result = SELECTION_TYPE_EMPTY;\n    } else if (isRootCall && firstItem instanceof CellRange) {\n      result = SELECTION_TYPE_OBJECT;\n    } else if (isRootCall && Array.isArray(firstItem)) {\n      result = detectSelectionType(firstItem, childCall);\n    } else if (selectionRanges.length >= 2 && selectionRanges.length <= 4) {\n      var isArrayType = !selectionRanges.some(function (value, index) {\n        return !ARRAY_TYPE_PATTERN[index].includes(_typeof(value));\n      });\n      if (isArrayType) {\n        result = SELECTION_TYPE_ARRAY;\n      }\n    }\n  }\n  return result;\n}\n\n/**\n * Factory function designed for normalization data schema from different data structures of the selection ranges.\n *\n * @param {number} type Selection type which will be processed.\n * @param {object} [options] The normalization options.\n * @param {boolean} [options.keepDirection=false] If `true`, the coordinates which contain the direction of the\n *                                                selected cells won't be changed. Otherwise, the selection will be\n *                                                normalized to values starting from top-left to bottom-right.\n * @param {Function} [options.propToCol] Pass the converting function (usually `datamap.propToCol`) if the column\n *                                       defined as props should be normalized to the numeric values.\n * @returns {number[]} Returns normalized data about selected range as an array (`[rowStart, columnStart, rowEnd, columnEnd]`).\n */\nexport function normalizeSelectionFactory(type) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    _ref$keepDirection = _ref.keepDirection,\n    keepDirection = _ref$keepDirection === void 0 ? false : _ref$keepDirection,\n    propToCol = _ref.propToCol;\n  if (!SELECTION_TYPES.includes(type)) {\n    throw new Error('Unsupported selection ranges schema type was provided.');\n  }\n  return function (selection) {\n    var isObjectType = type === SELECTION_TYPE_OBJECT;\n    var rowStart = isObjectType ? selection.from.row : selection[0];\n    var columnStart = isObjectType ? selection.from.col : selection[1];\n    var rowEnd = isObjectType ? selection.to.row : selection[2];\n    var columnEnd = isObjectType ? selection.to.col : selection[3];\n    if (typeof propToCol === 'function') {\n      if (typeof columnStart === 'string') {\n        columnStart = propToCol(columnStart);\n      }\n      if (typeof columnEnd === 'string') {\n        columnEnd = propToCol(columnEnd);\n      }\n    }\n    if (isUndefined(rowEnd)) {\n      rowEnd = rowStart;\n    }\n    if (isUndefined(columnEnd)) {\n      columnEnd = columnStart;\n    }\n    if (!keepDirection) {\n      var origRowStart = rowStart;\n      var origColumnStart = columnStart;\n      var origRowEnd = rowEnd;\n      var origColumnEnd = columnEnd;\n      rowStart = Math.min(origRowStart, origRowEnd);\n      columnStart = Math.min(origColumnStart, origColumnEnd);\n      rowEnd = Math.max(origRowStart, origRowEnd);\n      columnEnd = Math.max(origColumnStart, origColumnEnd);\n    }\n    return [rowStart, columnStart, rowEnd, columnEnd];\n  };\n}\n\n/**\n * Function transform selection ranges (produced by `hot.getSelected()` and `hot.getSelectedRange()`) to normalized\n * data structure. It merges repeated ranges into consecutive coordinates. The returned structure\n * contains an array of arrays. The single item contains at index 0 visual column index from the selection was\n * started and at index 1 distance as a count of selected columns.\n *\n * @param {Array[]|CellRange[]} selectionRanges Selection ranges produced by Handsontable.\n * @returns {Array[]} Returns an array of arrays with ranges defines in that schema:\n *                   `[[visualColumnStart, distance], [visualColumnStart, distance], ...]`.\n *                   The column distances are always created starting from the left (zero index) to the\n *                   right (the latest column index).\n */\nexport function transformSelectionToColumnDistance(selectionRanges) {\n  var selectionType = detectSelectionType(selectionRanges);\n  if (selectionType === SELECTION_TYPE_UNRECOGNIZED || selectionType === SELECTION_TYPE_EMPTY) {\n    return [];\n  }\n  var selectionSchemaNormalizer = normalizeSelectionFactory(selectionType);\n  var unorderedIndexes = new Set();\n\n  // Iterate through all ranges and collect all column indexes which are not saved yet.\n  arrayEach(selectionRanges, function (selection) {\n    var _selectionSchemaNorma = selectionSchemaNormalizer(selection),\n      _selectionSchemaNorma2 = _slicedToArray(_selectionSchemaNorma, 4),\n      columnStart = _selectionSchemaNorma2[1],\n      columnEnd = _selectionSchemaNorma2[3];\n    var columnNonHeaderStart = Math.max(columnStart, 0);\n    var amount = columnEnd - columnNonHeaderStart + 1;\n    arrayEach(Array.from(new Array(amount), function (_, i) {\n      return columnNonHeaderStart + i;\n    }), function (index) {\n      if (!unorderedIndexes.has(index)) {\n        unorderedIndexes.add(index);\n      }\n    });\n  });\n\n  // Sort indexes in ascending order to easily detecting non-consecutive columns.\n  var orderedIndexes = Array.from(unorderedIndexes).sort(function (a, b) {\n    return a - b;\n  });\n  var normalizedColumnRanges = arrayReduce(orderedIndexes, function (acc, visualColumnIndex, index, array) {\n    if (index !== 0 && visualColumnIndex === array[index - 1] + 1) {\n      acc[acc.length - 1][1] += 1;\n    } else {\n      acc.push([visualColumnIndex, 1]);\n    }\n    return acc;\n  }, []);\n  return normalizedColumnRanges;\n}\n\n/**\n * Function transform selection ranges (produced by `hot.getSelected()` and `hot.getSelectedRange()`) to normalized\n * data structure. It merges repeated ranges into consecutive coordinates. The returned structure\n * contains an array of arrays. The single item contains at index 0 visual column index from the selection was\n * started and at index 1 distance as a count of selected columns.\n *\n * @param {Array[]|CellRange[]} selectionRanges Selection ranges produced by Handsontable.\n * @returns {Array[]} Returns an array of arrays with ranges defines in that schema:\n *                   `[[visualColumnStart, distance], [visualColumnStart, distance], ...]`.\n *                   The column distances are always created starting from the left (zero index) to the\n *                   right (the latest column index).\n */\nexport function transformSelectionToRowDistance(selectionRanges) {\n  var selectionType = detectSelectionType(selectionRanges);\n  if (selectionType === SELECTION_TYPE_UNRECOGNIZED || selectionType === SELECTION_TYPE_EMPTY) {\n    return [];\n  }\n  var selectionSchemaNormalizer = normalizeSelectionFactory(selectionType);\n  var unorderedIndexes = new Set();\n\n  // Iterate through all ranges and collect all column indexes which are not saved yet.\n  arrayEach(selectionRanges, function (selection) {\n    var _selectionSchemaNorma3 = selectionSchemaNormalizer(selection),\n      _selectionSchemaNorma4 = _slicedToArray(_selectionSchemaNorma3, 3),\n      rowStart = _selectionSchemaNorma4[0],\n      rowEnd = _selectionSchemaNorma4[2];\n    var rowNonHeaderStart = Math.max(rowStart, 0);\n    var amount = rowEnd - rowNonHeaderStart + 1;\n    arrayEach(Array.from(new Array(amount), function (_, i) {\n      return rowNonHeaderStart + i;\n    }), function (index) {\n      if (!unorderedIndexes.has(index)) {\n        unorderedIndexes.add(index);\n      }\n    });\n  });\n\n  // Sort indexes in ascending order to easily detecting non-consecutive columns.\n  var orderedIndexes = Array.from(unorderedIndexes).sort(function (a, b) {\n    return a - b;\n  });\n  var normalizedRowRanges = arrayReduce(orderedIndexes, function (acc, rowIndex, index, array) {\n    if (index !== 0 && rowIndex === array[index - 1] + 1) {\n      acc[acc.length - 1][1] += 1;\n    } else {\n      acc.push([rowIndex, 1]);\n    }\n    return acc;\n  }, []);\n  return normalizedRowRanges;\n}\n\n/**\n * Check if passed value can be treated as valid cell coordinate. The second argument is\n * used to check if the value doesn't exceed the defined max table rows/columns count.\n *\n * @param {number} coord The coordinate to validate (row index or column index).\n * @param {number} maxTableItemsCount The value that declares the maximum coordinate that is still validatable.\n * @returns {boolean}\n */\nexport function isValidCoord(coord) {\n  var maxTableItemsCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;\n  return typeof coord === 'number' && coord >= 0 && coord < maxTableItemsCount;\n}","map":{"version":3,"names":["_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","TypeError","o","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","Array","from","test","len","length","arr2","_i","Symbol","iterator","_s","_e","_x","_r","_arr","_n","_d","next","done","push","value","err","return","isArray","_typeof","obj","CellRange","arrayEach","arrayReduce","isUndefined","SELECTION_TYPE_UNRECOGNIZED","SELECTION_TYPE_EMPTY","SELECTION_TYPE_ARRAY","SELECTION_TYPE_OBJECT","SELECTION_TYPES","ARRAY_TYPE_PATTERN","rootCall","childCall","detectSelectionType","selectionRanges","_callSymbol","arguments","undefined","Error","isRootCall","result","firstItem","isArrayType","some","index","includes","normalizeSelectionFactory","type","_ref","_ref$keepDirection","keepDirection","propToCol","selection","isObjectType","rowStart","row","columnStart","col","rowEnd","to","columnEnd","origRowStart","origColumnStart","origRowEnd","origColumnEnd","Math","min","max","transformSelectionToColumnDistance","selectionType","selectionSchemaNormalizer","unorderedIndexes","Set","_selectionSchemaNorma","_selectionSchemaNorma2","columnNonHeaderStart","amount","_","has","add","orderedIndexes","sort","a","b","normalizedColumnRanges","acc","visualColumnIndex","array","transformSelectionToRowDistance","_selectionSchemaNorma3","_selectionSchemaNorma4","rowNonHeaderStart","normalizedRowRanges","rowIndex","isValidCoord","coord","maxTableItemsCount","Infinity"],"sources":["/home/rstorey/wwwdev/Blucktool/node_modules/handsontable/selection/utils.mjs"],"sourcesContent":["function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport { CellRange } from \"./../3rdparty/walkontable/src/index.mjs\";\nimport { arrayEach, arrayReduce } from \"./../helpers/array.mjs\";\nimport { isUndefined } from \"./../helpers/mixed.mjs\";\nexport var SELECTION_TYPE_UNRECOGNIZED = 0;\nexport var SELECTION_TYPE_EMPTY = 1;\nexport var SELECTION_TYPE_ARRAY = 2;\nexport var SELECTION_TYPE_OBJECT = 3;\nexport var SELECTION_TYPES = [SELECTION_TYPE_OBJECT, SELECTION_TYPE_ARRAY];\nvar ARRAY_TYPE_PATTERN = [['number'], ['number', 'string'], ['number', 'undefined'], ['number', 'string', 'undefined']];\nvar rootCall = Symbol('root');\nvar childCall = Symbol('child');\n\n/**\n * Detect selection schema structure.\n *\n * @param {*} selectionRanges The selected range or and array of selected ranges. This type of data is produced by\n * `hot.getSelected()`, `hot.getSelectedLast()`, `hot.getSelectedRange()`\n * and `hot.getSelectedRangeLast()` methods.\n * @param {symbol} _callSymbol The symbol object which indicates source of the helper invocation.\n * @returns {number} Returns a number that specifies the type of detected selection schema. If selection schema type\n * is unrecognized than it returns `0`.\n */\nexport function detectSelectionType(selectionRanges) {\n  var _callSymbol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : rootCall;\n  if (_callSymbol !== rootCall && _callSymbol !== childCall) {\n    throw new Error('The second argument is used internally only and cannot be overwritten.');\n  }\n  var isArray = Array.isArray(selectionRanges);\n  var isRootCall = _callSymbol === rootCall;\n  var result = SELECTION_TYPE_UNRECOGNIZED;\n  if (isArray) {\n    var firstItem = selectionRanges[0];\n    if (selectionRanges.length === 0) {\n      result = SELECTION_TYPE_EMPTY;\n    } else if (isRootCall && firstItem instanceof CellRange) {\n      result = SELECTION_TYPE_OBJECT;\n    } else if (isRootCall && Array.isArray(firstItem)) {\n      result = detectSelectionType(firstItem, childCall);\n    } else if (selectionRanges.length >= 2 && selectionRanges.length <= 4) {\n      var isArrayType = !selectionRanges.some(function (value, index) {\n        return !ARRAY_TYPE_PATTERN[index].includes(_typeof(value));\n      });\n      if (isArrayType) {\n        result = SELECTION_TYPE_ARRAY;\n      }\n    }\n  }\n  return result;\n}\n\n/**\n * Factory function designed for normalization data schema from different data structures of the selection ranges.\n *\n * @param {number} type Selection type which will be processed.\n * @param {object} [options] The normalization options.\n * @param {boolean} [options.keepDirection=false] If `true`, the coordinates which contain the direction of the\n *                                                selected cells won't be changed. Otherwise, the selection will be\n *                                                normalized to values starting from top-left to bottom-right.\n * @param {Function} [options.propToCol] Pass the converting function (usually `datamap.propToCol`) if the column\n *                                       defined as props should be normalized to the numeric values.\n * @returns {number[]} Returns normalized data about selected range as an array (`[rowStart, columnStart, rowEnd, columnEnd]`).\n */\nexport function normalizeSelectionFactory(type) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    _ref$keepDirection = _ref.keepDirection,\n    keepDirection = _ref$keepDirection === void 0 ? false : _ref$keepDirection,\n    propToCol = _ref.propToCol;\n  if (!SELECTION_TYPES.includes(type)) {\n    throw new Error('Unsupported selection ranges schema type was provided.');\n  }\n  return function (selection) {\n    var isObjectType = type === SELECTION_TYPE_OBJECT;\n    var rowStart = isObjectType ? selection.from.row : selection[0];\n    var columnStart = isObjectType ? selection.from.col : selection[1];\n    var rowEnd = isObjectType ? selection.to.row : selection[2];\n    var columnEnd = isObjectType ? selection.to.col : selection[3];\n    if (typeof propToCol === 'function') {\n      if (typeof columnStart === 'string') {\n        columnStart = propToCol(columnStart);\n      }\n      if (typeof columnEnd === 'string') {\n        columnEnd = propToCol(columnEnd);\n      }\n    }\n    if (isUndefined(rowEnd)) {\n      rowEnd = rowStart;\n    }\n    if (isUndefined(columnEnd)) {\n      columnEnd = columnStart;\n    }\n    if (!keepDirection) {\n      var origRowStart = rowStart;\n      var origColumnStart = columnStart;\n      var origRowEnd = rowEnd;\n      var origColumnEnd = columnEnd;\n      rowStart = Math.min(origRowStart, origRowEnd);\n      columnStart = Math.min(origColumnStart, origColumnEnd);\n      rowEnd = Math.max(origRowStart, origRowEnd);\n      columnEnd = Math.max(origColumnStart, origColumnEnd);\n    }\n    return [rowStart, columnStart, rowEnd, columnEnd];\n  };\n}\n\n/**\n * Function transform selection ranges (produced by `hot.getSelected()` and `hot.getSelectedRange()`) to normalized\n * data structure. It merges repeated ranges into consecutive coordinates. The returned structure\n * contains an array of arrays. The single item contains at index 0 visual column index from the selection was\n * started and at index 1 distance as a count of selected columns.\n *\n * @param {Array[]|CellRange[]} selectionRanges Selection ranges produced by Handsontable.\n * @returns {Array[]} Returns an array of arrays with ranges defines in that schema:\n *                   `[[visualColumnStart, distance], [visualColumnStart, distance], ...]`.\n *                   The column distances are always created starting from the left (zero index) to the\n *                   right (the latest column index).\n */\nexport function transformSelectionToColumnDistance(selectionRanges) {\n  var selectionType = detectSelectionType(selectionRanges);\n  if (selectionType === SELECTION_TYPE_UNRECOGNIZED || selectionType === SELECTION_TYPE_EMPTY) {\n    return [];\n  }\n  var selectionSchemaNormalizer = normalizeSelectionFactory(selectionType);\n  var unorderedIndexes = new Set();\n\n  // Iterate through all ranges and collect all column indexes which are not saved yet.\n  arrayEach(selectionRanges, function (selection) {\n    var _selectionSchemaNorma = selectionSchemaNormalizer(selection),\n      _selectionSchemaNorma2 = _slicedToArray(_selectionSchemaNorma, 4),\n      columnStart = _selectionSchemaNorma2[1],\n      columnEnd = _selectionSchemaNorma2[3];\n    var columnNonHeaderStart = Math.max(columnStart, 0);\n    var amount = columnEnd - columnNonHeaderStart + 1;\n    arrayEach(Array.from(new Array(amount), function (_, i) {\n      return columnNonHeaderStart + i;\n    }), function (index) {\n      if (!unorderedIndexes.has(index)) {\n        unorderedIndexes.add(index);\n      }\n    });\n  });\n\n  // Sort indexes in ascending order to easily detecting non-consecutive columns.\n  var orderedIndexes = Array.from(unorderedIndexes).sort(function (a, b) {\n    return a - b;\n  });\n  var normalizedColumnRanges = arrayReduce(orderedIndexes, function (acc, visualColumnIndex, index, array) {\n    if (index !== 0 && visualColumnIndex === array[index - 1] + 1) {\n      acc[acc.length - 1][1] += 1;\n    } else {\n      acc.push([visualColumnIndex, 1]);\n    }\n    return acc;\n  }, []);\n  return normalizedColumnRanges;\n}\n\n/**\n * Function transform selection ranges (produced by `hot.getSelected()` and `hot.getSelectedRange()`) to normalized\n * data structure. It merges repeated ranges into consecutive coordinates. The returned structure\n * contains an array of arrays. The single item contains at index 0 visual column index from the selection was\n * started and at index 1 distance as a count of selected columns.\n *\n * @param {Array[]|CellRange[]} selectionRanges Selection ranges produced by Handsontable.\n * @returns {Array[]} Returns an array of arrays with ranges defines in that schema:\n *                   `[[visualColumnStart, distance], [visualColumnStart, distance], ...]`.\n *                   The column distances are always created starting from the left (zero index) to the\n *                   right (the latest column index).\n */\nexport function transformSelectionToRowDistance(selectionRanges) {\n  var selectionType = detectSelectionType(selectionRanges);\n  if (selectionType === SELECTION_TYPE_UNRECOGNIZED || selectionType === SELECTION_TYPE_EMPTY) {\n    return [];\n  }\n  var selectionSchemaNormalizer = normalizeSelectionFactory(selectionType);\n  var unorderedIndexes = new Set();\n\n  // Iterate through all ranges and collect all column indexes which are not saved yet.\n  arrayEach(selectionRanges, function (selection) {\n    var _selectionSchemaNorma3 = selectionSchemaNormalizer(selection),\n      _selectionSchemaNorma4 = _slicedToArray(_selectionSchemaNorma3, 3),\n      rowStart = _selectionSchemaNorma4[0],\n      rowEnd = _selectionSchemaNorma4[2];\n    var rowNonHeaderStart = Math.max(rowStart, 0);\n    var amount = rowEnd - rowNonHeaderStart + 1;\n    arrayEach(Array.from(new Array(amount), function (_, i) {\n      return rowNonHeaderStart + i;\n    }), function (index) {\n      if (!unorderedIndexes.has(index)) {\n        unorderedIndexes.add(index);\n      }\n    });\n  });\n\n  // Sort indexes in ascending order to easily detecting non-consecutive columns.\n  var orderedIndexes = Array.from(unorderedIndexes).sort(function (a, b) {\n    return a - b;\n  });\n  var normalizedRowRanges = arrayReduce(orderedIndexes, function (acc, rowIndex, index, array) {\n    if (index !== 0 && rowIndex === array[index - 1] + 1) {\n      acc[acc.length - 1][1] += 1;\n    } else {\n      acc.push([rowIndex, 1]);\n    }\n    return acc;\n  }, []);\n  return normalizedRowRanges;\n}\n\n/**\n * Check if passed value can be treated as valid cell coordinate. The second argument is\n * used to check if the value doesn't exceed the defined max table rows/columns count.\n *\n * @param {number} coord The coordinate to validate (row index or column index).\n * @param {number} maxTableItemsCount The value that declares the maximum coordinate that is still validatable.\n * @returns {boolean}\n */\nexport function isValidCoord(coord) {\n  var maxTableItemsCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;\n  return typeof coord === 'number' && coord >= 0 && coord < maxTableItemsCount;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}