{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nvar _templateObject;\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (_x = (_i = _i.call(arr)).next, 0 === i) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n    } catch (err) {\n      _d = !0, _e = err;\n    } finally {\n      try {\n        if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _taggedTemplateLiteral(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nimport Highlight from \"./highlight/highlight.mjs\";\nimport { AREA_TYPE, HEADER_TYPE, CELL_TYPE } from \"./highlight/constants.mjs\";\nimport SelectionRange from \"./range.mjs\";\nimport { createObjectPropListener, mixin } from \"./../helpers/object.mjs\";\nimport { isUndefined } from \"./../helpers/mixed.mjs\";\nimport { arrayEach } from \"./../helpers/array.mjs\";\nimport localHooks from \"./../mixins/localHooks.mjs\";\nimport Transformation from \"./transformation.mjs\";\nimport { detectSelectionType, isValidCoord, normalizeSelectionFactory, SELECTION_TYPE_EMPTY, SELECTION_TYPE_UNRECOGNIZED } from \"./utils.mjs\";\nimport { toSingleLine } from \"./../helpers/templateLiteralTag.mjs\";\n/**\n * @class Selection\n * @util\n */\nvar Selection = /*#__PURE__*/function () {\n  function Selection(settings, tableProps) {\n    var _this = this;\n    _classCallCheck(this, Selection);\n    /**\n     * Handsontable settings instance.\n     *\n     * @type {GridSettings}\n     */\n    this.settings = settings;\n    /**\n     * An additional object with dynamically defined properties which describes table state.\n     *\n     * @type {object}\n     */\n    this.tableProps = tableProps;\n    /**\n     * The flag which determines if the selection is in progress.\n     *\n     * @type {boolean}\n     */\n    this.inProgress = false;\n    /**\n     * The flag indicates that selection was performed by clicking the corner overlay.\n     *\n     * @type {boolean}\n     */\n    this.selectedByCorner = false;\n    /**\n     * The collection of the selection layer levels where the whole row was selected using the row header or\n     * the corner header.\n     *\n     * @type {Set.<number>}\n     */\n    this.selectedByRowHeader = new Set();\n    /**\n     * The collection of the selection layer levels where the whole column was selected using the column header or\n     * the corner header.\n     *\n     * @type {Set.<number>}\n     */\n    this.selectedByColumnHeader = new Set();\n    /**\n     * Selection data layer (handle visual coordinates).\n     *\n     * @type {SelectionRange}\n     */\n    this.selectedRange = new SelectionRange(function (highlight, from, to) {\n      return _this.tableProps.createCellRange(highlight, from, to);\n    });\n    /**\n     * Visualization layer.\n     *\n     * @type {Highlight}\n     */\n    this.highlight = new Highlight({\n      headerClassName: settings.currentHeaderClassName,\n      activeHeaderClassName: settings.activeHeaderClassName,\n      rowClassName: settings.currentRowClassName,\n      columnClassName: settings.currentColClassName,\n      disabledCellSelection: function disabledCellSelection(row, column) {\n        return _this.tableProps.isDisabledCellSelection(row, column);\n      },\n      cellCornerVisible: function cellCornerVisible() {\n        return _this.isCellCornerVisible.apply(_this, arguments);\n      },\n      areaCornerVisible: function areaCornerVisible() {\n        return _this.isAreaCornerVisible.apply(_this, arguments);\n      },\n      visualToRenderableCoords: function visualToRenderableCoords(coords) {\n        return _this.tableProps.visualToRenderableCoords(coords);\n      },\n      renderableToVisualCoords: function renderableToVisualCoords(coords) {\n        return _this.tableProps.renderableToVisualCoords(coords);\n      },\n      createCellCoords: function createCellCoords(row, column) {\n        return _this.tableProps.createCellCoords(row, column);\n      },\n      createCellRange: function createCellRange(highlight, from, to) {\n        return _this.tableProps.createCellRange(highlight, from, to);\n      },\n      rowIndexMapper: function rowIndexMapper() {\n        return _this.tableProps.rowIndexMapper();\n      },\n      columnIndexMapper: function columnIndexMapper() {\n        return _this.tableProps.columnIndexMapper();\n      }\n    });\n    /**\n     * The module for modifying coordinates.\n     *\n     * @type {Transformation}\n     */\n    this.transformation = new Transformation(this.selectedRange, {\n      countRows: function countRows() {\n        return _this.tableProps.countRowsTranslated();\n      },\n      countCols: function countCols() {\n        return _this.tableProps.countColsTranslated();\n      },\n      visualToRenderableCoords: function visualToRenderableCoords(coords) {\n        return _this.tableProps.visualToRenderableCoords(coords);\n      },\n      renderableToVisualCoords: function renderableToVisualCoords(coords) {\n        return _this.tableProps.renderableToVisualCoords(coords);\n      },\n      createCellCoords: function createCellCoords(row, column) {\n        return _this.tableProps.createCellCoords(row, column);\n      },\n      fixedRowsBottom: function fixedRowsBottom() {\n        return settings.fixedRowsBottom;\n      },\n      minSpareRows: function minSpareRows() {\n        return settings.minSpareRows;\n      },\n      minSpareCols: function minSpareCols() {\n        return settings.minSpareCols;\n      },\n      autoWrapRow: function autoWrapRow() {\n        return settings.autoWrapRow;\n      },\n      autoWrapCol: function autoWrapCol() {\n        return settings.autoWrapCol;\n      }\n    });\n    this.transformation.addLocalHook('beforeTransformStart', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _this.runLocalHooks.apply(_this, ['beforeModifyTransformStart'].concat(args));\n    });\n    this.transformation.addLocalHook('afterTransformStart', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return _this.runLocalHooks.apply(_this, ['afterModifyTransformStart'].concat(args));\n    });\n    this.transformation.addLocalHook('beforeTransformEnd', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return _this.runLocalHooks.apply(_this, ['beforeModifyTransformEnd'].concat(args));\n    });\n    this.transformation.addLocalHook('afterTransformEnd', function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      return _this.runLocalHooks.apply(_this, ['afterModifyTransformEnd'].concat(args));\n    });\n    this.transformation.addLocalHook('insertRowRequire', function () {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n      return _this.runLocalHooks.apply(_this, ['insertRowRequire'].concat(args));\n    });\n    this.transformation.addLocalHook('insertColRequire', function () {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n      return _this.runLocalHooks.apply(_this, ['insertColRequire'].concat(args));\n    });\n  }\n\n  /**\n   * Get data layer for current selection.\n   *\n   * @returns {SelectionRange}\n   */\n  _createClass(Selection, [{\n    key: \"getSelectedRange\",\n    value: function getSelectedRange() {\n      return this.selectedRange;\n    }\n\n    /**\n     * Indicate that selection process began. It sets internaly `.inProgress` property to `true`.\n     */\n  }, {\n    key: \"begin\",\n    value: function begin() {\n      this.inProgress = true;\n    }\n\n    /**\n     * Indicate that selection process finished. It sets internaly `.inProgress` property to `false`.\n     */\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      this.runLocalHooks('afterSelectionFinished', Array.from(this.selectedRange));\n      this.inProgress = false;\n    }\n\n    /**\n     * Check if the process of selecting the cell/cells is in progress.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isInProgress\",\n    value: function isInProgress() {\n      return this.inProgress;\n    }\n\n    /**\n     * Starts selection range on given coordinate object.\n     *\n     * @param {CellCoords} coords Visual coords.\n     * @param {boolean} [multipleSelection] If `true`, selection will be worked in 'multiple' mode. This option works\n     *                                      only when 'selectionMode' is set as 'multiple'. If the argument is not defined\n     *                                      the default trigger will be used.\n     * @param {boolean} [fragment=false] If `true`, the selection will be treated as a partial selection where the\n     *                                   `setRangeEnd` method won't be called on every `setRangeStart` call.\n     */\n  }, {\n    key: \"setRangeStart\",\n    value: function setRangeStart(coords, multipleSelection) {\n      var fragment = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var isMultipleMode = this.settings.selectionMode === 'multiple';\n      var isMultipleSelection = isUndefined(multipleSelection) ? this.tableProps.getShortcutManager().isCtrlPressed() : multipleSelection;\n      var isRowNegative = coords.row < 0;\n      var isColumnNegative = coords.col < 0;\n      var selectedByCorner = isRowNegative && isColumnNegative;\n      // We are creating copy. We would like to modify just the start of the selection by below hook. Then original coords\n      // should be handled by next methods.\n      var coordsClone = coords.clone();\n      this.selectedByCorner = selectedByCorner;\n      this.runLocalHooks(\"beforeSetRangeStart\".concat(fragment ? 'Only' : ''), coordsClone);\n      if (!isMultipleMode || isMultipleMode && !isMultipleSelection && isUndefined(multipleSelection)) {\n        this.selectedRange.clear();\n      }\n      this.selectedRange.add(coordsClone);\n      if (this.getLayerLevel() === 0) {\n        this.selectedByRowHeader.clear();\n        this.selectedByColumnHeader.clear();\n      }\n      if (!selectedByCorner && isColumnNegative) {\n        this.selectedByRowHeader.add(this.getLayerLevel());\n      }\n      if (!selectedByCorner && isRowNegative) {\n        this.selectedByColumnHeader.add(this.getLayerLevel());\n      }\n      if (!fragment) {\n        this.setRangeEnd(coords);\n      }\n    }\n\n    /**\n     * Starts selection range on given coordinate object.\n     *\n     * @param {CellCoords} coords Visual coords.\n     * @param {boolean} [multipleSelection] If `true`, selection will be worked in 'multiple' mode. This option works\n     *                                      only when 'selectionMode' is set as 'multiple'. If the argument is not defined\n     *                                      the default trigger will be used.\n     */\n  }, {\n    key: \"setRangeStartOnly\",\n    value: function setRangeStartOnly(coords, multipleSelection) {\n      this.setRangeStart(coords, multipleSelection, true);\n    }\n\n    /**\n     * Ends selection range on given coordinate object.\n     *\n     * @param {CellCoords} coords Visual coords.\n     */\n  }, {\n    key: \"setRangeEnd\",\n    value: function setRangeEnd(coords) {\n      if (this.selectedRange.isEmpty()) {\n        return;\n      }\n\n      // We are creating copy. We would like to modify just the end of the selection by below hook. Then original coords\n      // should be handled by next methods.\n      var coordsClone = coords.clone();\n      this.runLocalHooks('beforeSetRangeEnd', coordsClone);\n      this.begin();\n      var cellRange = this.selectedRange.current();\n      if (this.settings.selectionMode !== 'single') {\n        cellRange.setTo(this.tableProps.createCellCoords(coordsClone.row, coordsClone.col));\n      }\n\n      // Set up current selection.\n      this.highlight.getCell().clear();\n      if (this.highlight.isEnabledFor(CELL_TYPE, cellRange.highlight)) {\n        this.highlight.getCell().add(this.selectedRange.current().highlight).commit().syncWith(cellRange);\n      }\n      var layerLevel = this.getLayerLevel();\n\n      // If the next layer level is lower than previous then clear all area and header highlights. This is the\n      // indication that the new selection is performing.\n      if (layerLevel < this.highlight.layerLevel) {\n        arrayEach(this.highlight.getAreas(), function (highlight) {\n          return void highlight.clear();\n        });\n        arrayEach(this.highlight.getHeaders(), function (highlight) {\n          return void highlight.clear();\n        });\n        arrayEach(this.highlight.getActiveHeaders(), function (highlight) {\n          return void highlight.clear();\n        });\n      }\n      this.highlight.useLayerLevel(layerLevel);\n      var areaHighlight = this.highlight.createOrGetArea();\n      var headerHighlight = this.highlight.createOrGetHeader();\n      var activeHeaderHighlight = this.highlight.createOrGetActiveHeader();\n      areaHighlight.clear();\n      headerHighlight.clear();\n      activeHeaderHighlight.clear();\n      if (this.highlight.isEnabledFor(AREA_TYPE, cellRange.highlight) && (this.isMultiple() || layerLevel >= 1)) {\n        areaHighlight.add(cellRange.from).add(cellRange.to).commit();\n        if (layerLevel === 1) {\n          // For single cell selection in the same layer, we do not create area selection to prevent blue background.\n          // When non-consecutive selection is performed we have to add that missing area selection to the previous layer\n          // based on previous coordinates. It only occurs when the previous selection wasn't select multiple cells.\n          var previousRange = this.selectedRange.previous();\n          this.highlight.useLayerLevel(layerLevel - 1).createOrGetArea().add(previousRange.from).commit()\n          // Range may start with hidden indexes. Commit would not found start point (as we add just the `from` coords).\n          .syncWith(previousRange);\n          this.highlight.useLayerLevel(layerLevel);\n        }\n      }\n      if (this.highlight.isEnabledFor(HEADER_TYPE, cellRange.highlight)) {\n        // The header selection generally contains cell selection. In a case when all rows (or columns)\n        // are hidden that visual coordinates are translated to renderable coordinates that do not exist.\n        // Hence no header highlight is generated. In that case, to make a column (or a row) header\n        // highlight, the row and column index has to point to the header (the negative value). See #7052.\n        var areAnyRowsRendered = this.tableProps.countRowsTranslated() === 0;\n        var areAnyColumnsRendered = this.tableProps.countColsTranslated() === 0;\n        var headerCellRange = cellRange;\n        if (areAnyRowsRendered || areAnyColumnsRendered) {\n          headerCellRange = cellRange.clone();\n        }\n        if (areAnyRowsRendered) {\n          headerCellRange.from.row = -1;\n        }\n        if (areAnyColumnsRendered) {\n          headerCellRange.from.col = -1;\n        }\n        if (this.settings.selectionMode === 'single') {\n          if (this.isSelectedByAnyHeader()) {\n            headerCellRange.from.normalize();\n          }\n          headerHighlight.add(headerCellRange.from).commit();\n        } else {\n          headerHighlight.add(headerCellRange.from).add(headerCellRange.to).commit();\n        }\n        if (this.isEntireRowSelected()) {\n          var isRowSelected = this.tableProps.countCols() === cellRange.getWidth();\n\n          // Make sure that the whole row is selected (in case where selectionMode is set to 'single')\n          if (isRowSelected) {\n            activeHeaderHighlight.add(this.tableProps.createCellCoords(cellRange.from.row, -1)).add(this.tableProps.createCellCoords(cellRange.to.row, -1)).commit();\n          }\n        }\n        if (this.isEntireColumnSelected()) {\n          var isColumnSelected = this.tableProps.countRows() === cellRange.getHeight();\n\n          // Make sure that the whole column is selected (in case where selectionMode is set to 'single')\n          if (isColumnSelected) {\n            activeHeaderHighlight.add(this.tableProps.createCellCoords(-1, cellRange.from.col)).add(this.tableProps.createCellCoords(-1, cellRange.to.col)).commit();\n          }\n        }\n      }\n      this.runLocalHooks('afterSetRangeEnd', coords);\n    }\n\n    /**\n     * Returns information if we have a multiselection. This method check multiselection only on the latest layer of\n     * the selection.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isMultiple\",\n    value: function isMultiple() {\n      var isMultipleListener = createObjectPropListener(!this.selectedRange.current().isSingle());\n      this.runLocalHooks('afterIsMultipleSelection', isMultipleListener);\n      return isMultipleListener.value;\n    }\n\n    /**\n     * Selects cell relative to the current cell (if possible).\n     *\n     * @param {number} rowDelta Rows number to move, value can be passed as negative number.\n     * @param {number} colDelta Columns number to move, value can be passed as negative number.\n     * @param {boolean} [force=false] If `true` the new rows/columns will be created if necessary. Otherwise, row/column will\n     *                        be created according to `minSpareRows/minSpareCols` settings of Handsontable.\n     */\n  }, {\n    key: \"transformStart\",\n    value: function transformStart(rowDelta, colDelta) {\n      var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      this.setRangeStart(this.transformation.transformStart(rowDelta, colDelta, force));\n    }\n\n    /**\n     * Sets selection end cell relative to the current selection end cell (if possible).\n     *\n     * @param {number} rowDelta Rows number to move, value can be passed as negative number.\n     * @param {number} colDelta Columns number to move, value can be passed as negative number.\n     */\n  }, {\n    key: \"transformEnd\",\n    value: function transformEnd(rowDelta, colDelta) {\n      this.setRangeEnd(this.transformation.transformEnd(rowDelta, colDelta));\n    }\n\n    /**\n     * Returns currently used layer level.\n     *\n     * @returns {number} Returns layer level starting from 0. If no selection was added to the table -1 is returned.\n     */\n  }, {\n    key: \"getLayerLevel\",\n    value: function getLayerLevel() {\n      return this.selectedRange.size() - 1;\n    }\n\n    /**\n     * Returns `true` if currently there is a selection on the screen, `false` otherwise.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isSelected\",\n    value: function isSelected() {\n      return !this.selectedRange.isEmpty();\n    }\n\n    /**\n     * Returns `true` if the selection was applied by clicking to the row header. If the `layerLevel`\n     * argument is passed then only that layer will be checked. Otherwise, it checks if any row header\n     * was clicked on any selection layer level.\n     *\n     * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isSelectedByRowHeader\",\n    value: function isSelectedByRowHeader() {\n      var layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n      return !this.isSelectedByCorner(layerLevel) && this.isEntireRowSelected(layerLevel);\n    }\n\n    /**\n     * Returns `true` if the selection consists of entire rows (including their headers). If the `layerLevel`\n     * argument is passed then only that layer will be checked. Otherwise, it checks the selection for all layers.\n     *\n     * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isEntireRowSelected\",\n    value: function isEntireRowSelected() {\n      var layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n      return layerLevel === -1 ? this.selectedByRowHeader.size > 0 : this.selectedByRowHeader.has(layerLevel);\n    }\n\n    /**\n     * Returns `true` if the selection was applied by clicking to the column header. If the `layerLevel`\n     * argument is passed then only that layer will be checked. Otherwise, it checks if any column header\n     * was clicked on any selection layer level.\n     *\n     * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isSelectedByColumnHeader\",\n    value: function isSelectedByColumnHeader() {\n      var layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n      return !this.isSelectedByCorner() && this.isEntireColumnSelected(layerLevel);\n    }\n\n    /**\n     * Returns `true` if the selection consists of entire columns (including their headers). If the `layerLevel`\n     * argument is passed then only that layer will be checked. Otherwise, it checks the selection for all layers.\n     *\n     * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isEntireColumnSelected\",\n    value: function isEntireColumnSelected() {\n      var layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n      return layerLevel === -1 ? this.selectedByColumnHeader.size > 0 : this.selectedByColumnHeader.has(layerLevel);\n    }\n\n    /**\n     * Returns `true` if the selection was applied by clicking on the row or column header on any layer level.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isSelectedByAnyHeader\",\n    value: function isSelectedByAnyHeader() {\n      return this.isSelectedByRowHeader(-1) || this.isSelectedByColumnHeader(-1) || this.isSelectedByCorner();\n    }\n\n    /**\n     * Returns `true` if the selection was applied by clicking on the left-top corner overlay.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isSelectedByCorner\",\n    value: function isSelectedByCorner() {\n      return this.selectedByCorner;\n    }\n\n    /**\n     * Returns `true` if coords is within selection coords. This method iterates through all selection layers to check if\n     * the coords object is within selection range.\n     *\n     * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"inInSelection\",\n    value: function inInSelection(coords) {\n      return this.selectedRange.includes(coords);\n    }\n\n    /**\n     * Returns `true` if the cell corner should be visible.\n     *\n     * @private\n     * @returns {boolean} `true` if the corner element has to be visible, `false` otherwise.\n     */\n  }, {\n    key: \"isCellCornerVisible\",\n    value: function isCellCornerVisible() {\n      return this.settings.fillHandle && !this.tableProps.isEditorOpened() && !this.isMultiple();\n    }\n\n    /**\n     * Returns `true` if the area corner should be visible.\n     *\n     * @param {number} layerLevel The layer level.\n     * @returns {boolean} `true` if the corner element has to be visible, `false` otherwise.\n     */\n  }, {\n    key: \"isAreaCornerVisible\",\n    value: function isAreaCornerVisible(layerLevel) {\n      if (Number.isInteger(layerLevel) && layerLevel !== this.getLayerLevel()) {\n        return false;\n      }\n      return this.settings.fillHandle && !this.tableProps.isEditorOpened() && this.isMultiple();\n    }\n\n    /**\n     * Clear the selection by resetting the collected ranges and highlights.\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      // TODO: collections selectedByColumnHeader and selectedByRowHeader should be clear too.\n      this.selectedRange.clear();\n      this.highlight.clear();\n    }\n\n    /**\n     * Deselects all selected cells.\n     */\n  }, {\n    key: \"deselect\",\n    value: function deselect() {\n      if (!this.isSelected()) {\n        return;\n      }\n      this.inProgress = false;\n      this.clear();\n      this.runLocalHooks('afterDeselect');\n    }\n\n    /**\n     * Select all cells.\n     *\n     * @param {boolean} [includeRowHeaders=false] `true` If the selection should include the row headers, `false`\n     * otherwise.\n     * @param {boolean} [includeColumnHeaders=false] `true` If the selection should include the column headers, `false`\n     * otherwise.\n     */\n  }, {\n    key: \"selectAll\",\n    value: function selectAll() {\n      var includeRowHeaders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var includeColumnHeaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var nrOfRows = this.tableProps.countRows();\n      var nrOfColumns = this.tableProps.countCols();\n\n      // We can't select cells when there is no data.\n      if (!includeRowHeaders && !includeColumnHeaders && (nrOfRows === 0 || nrOfColumns === 0)) {\n        return;\n      }\n      var startCoords = this.tableProps.createCellCoords(includeColumnHeaders ? -1 : 0, includeRowHeaders ? -1 : 0);\n      var endCoords = this.tableProps.createCellCoords(nrOfRows - 1, nrOfColumns - 1);\n      this.clear();\n      this.setRangeStartOnly(startCoords);\n      this.selectedByRowHeader.add(this.getLayerLevel());\n      this.selectedByColumnHeader.add(this.getLayerLevel());\n      this.setRangeEnd(endCoords);\n      this.finish();\n    }\n\n    /**\n     * Make multiple, non-contiguous selection specified by `row` and `column` values or a range of cells\n     * finishing at `endRow`, `endColumn`. The method supports two input formats, first as an array of arrays such\n     * as `[[rowStart, columnStart, rowEnd, columnEnd]]` and second format as an array of CellRange objects.\n     * If the passed ranges have another format the exception will be thrown.\n     *\n     * @param {Array[]|CellRange[]} selectionRanges The coordinates which define what the cells should be selected.\n     * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.\n     */\n  }, {\n    key: \"selectCells\",\n    value: function selectCells(selectionRanges) {\n      var _this2 = this;\n      var selectionType = detectSelectionType(selectionRanges);\n      if (selectionType === SELECTION_TYPE_EMPTY) {\n        return false;\n      } else if (selectionType === SELECTION_TYPE_UNRECOGNIZED) {\n        throw new Error(toSingleLine(_templateObject || (_templateObject = _taggedTemplateLiteral([\"Unsupported format of the selection ranges was passed. To select cells pass \\n        the coordinates as an array of arrays ([[rowStart, columnStart/columnPropStart, rowEnd, \\n        columnEnd/columnPropEnd]]) or as an array of CellRange objects.\"], [\"Unsupported format of the selection ranges was passed. To select cells pass\\\\x20\\n        the coordinates as an array of arrays ([[rowStart, columnStart/columnPropStart, rowEnd,\\\\x20\\n        columnEnd/columnPropEnd]]) or as an array of CellRange objects.\"]))));\n      }\n      var selectionSchemaNormalizer = normalizeSelectionFactory(selectionType, {\n        propToCol: function propToCol(prop) {\n          return _this2.tableProps.propToCol(prop);\n        },\n        keepDirection: true\n      });\n      var nrOfRows = this.tableProps.countRows();\n      var nrOfColumns = this.tableProps.countCols();\n\n      // Check if every layer of the coordinates are valid.\n      var isValid = !selectionRanges.some(function (selection) {\n        var _selectionSchemaNorma = selectionSchemaNormalizer(selection),\n          _selectionSchemaNorma2 = _slicedToArray(_selectionSchemaNorma, 4),\n          rowStart = _selectionSchemaNorma2[0],\n          columnStart = _selectionSchemaNorma2[1],\n          rowEnd = _selectionSchemaNorma2[2],\n          columnEnd = _selectionSchemaNorma2[3];\n        var _isValid = isValidCoord(rowStart, nrOfRows) && isValidCoord(columnStart, nrOfColumns) && isValidCoord(rowEnd, nrOfRows) && isValidCoord(columnEnd, nrOfColumns);\n        return !_isValid;\n      });\n      if (isValid) {\n        this.clear();\n        arrayEach(selectionRanges, function (selection) {\n          var _selectionSchemaNorma3 = selectionSchemaNormalizer(selection),\n            _selectionSchemaNorma4 = _slicedToArray(_selectionSchemaNorma3, 4),\n            rowStart = _selectionSchemaNorma4[0],\n            columnStart = _selectionSchemaNorma4[1],\n            rowEnd = _selectionSchemaNorma4[2],\n            columnEnd = _selectionSchemaNorma4[3];\n          _this2.setRangeStartOnly(_this2.tableProps.createCellCoords(rowStart, columnStart), false);\n          _this2.setRangeEnd(_this2.tableProps.createCellCoords(rowEnd, columnEnd));\n          _this2.finish();\n        });\n      }\n      return isValid;\n    }\n\n    /**\n     * Select column specified by `startColumn` visual index or column property or a range of columns finishing at\n     * `endColumn`.\n     *\n     * @param {number|string} startColumn Visual column index or column property from which the selection starts.\n     * @param {number|string} [endColumn] Visual column index or column property from to the selection finishes.\n     * @param {number} [headerLevel=-1] A row header index that triggers the column selection. The value can\n     *                                  take -1 to -N, where -1 means the header closest to the cells.\n     *\n     * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.\n     */\n  }, {\n    key: \"selectColumns\",\n    value: function selectColumns(startColumn) {\n      var endColumn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startColumn;\n      var headerLevel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n      var start = typeof startColumn === 'string' ? this.tableProps.propToCol(startColumn) : startColumn;\n      var end = typeof endColumn === 'string' ? this.tableProps.propToCol(endColumn) : endColumn;\n      var nrOfColumns = this.tableProps.countCols();\n      var nrOfRows = this.tableProps.countRows();\n      var isValid = isValidCoord(start, nrOfColumns) && isValidCoord(end, nrOfColumns);\n      if (isValid) {\n        this.setRangeStartOnly(this.tableProps.createCellCoords(headerLevel, start));\n        this.setRangeEnd(this.tableProps.createCellCoords(nrOfRows - 1, end));\n        this.finish();\n      }\n      return isValid;\n    }\n\n    /**\n     * Select row specified by `startRow` visual index or a range of rows finishing at `endRow`.\n     *\n     * @param {number} startRow Visual row index from which the selection starts.\n     * @param {number} [endRow] Visual row index from to the selection finishes.\n     * @param {number} [headerLevel=-1] A column header index that triggers the row selection.\n     *                                  The value can take -1 to -N, where -1 means the header\n     *                                  closest to the cells.\n     * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.\n     */\n  }, {\n    key: \"selectRows\",\n    value: function selectRows(startRow) {\n      var endRow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startRow;\n      var headerLevel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n      var nrOfRows = this.tableProps.countRows();\n      var nrOfColumns = this.tableProps.countCols();\n      var isValid = isValidCoord(startRow, nrOfRows) && isValidCoord(endRow, nrOfRows);\n      if (isValid) {\n        this.setRangeStartOnly(this.tableProps.createCellCoords(startRow, headerLevel));\n        this.setRangeEnd(this.tableProps.createCellCoords(endRow, nrOfColumns - 1));\n        this.finish();\n      }\n      return isValid;\n    }\n\n    /**\n     * Rewrite the rendered state of the selection as visual selection may have a new representation in the DOM.\n     */\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      var customSelections = this.highlight.getCustomSelections();\n      customSelections.forEach(function (customSelection) {\n        customSelection.commit();\n      });\n      if (!this.isSelected()) {\n        return;\n      }\n      var cellHighlight = this.highlight.getCell();\n      var currentLayer = this.getLayerLevel();\n      cellHighlight.commit().syncWith(this.selectedRange.current());\n\n      // Rewriting rendered ranges going through all layers.\n      for (var layerLevel = 0; layerLevel < this.selectedRange.size(); layerLevel += 1) {\n        this.highlight.useLayerLevel(layerLevel);\n        var areaHighlight = this.highlight.createOrGetArea();\n        var headerHighlight = this.highlight.createOrGetHeader();\n        var activeHeaderHighlight = this.highlight.createOrGetActiveHeader();\n        areaHighlight.commit();\n        headerHighlight.commit();\n        activeHeaderHighlight.commit();\n      }\n\n      // Reverting starting layer for the Highlight.\n      this.highlight.useLayerLevel(currentLayer);\n    }\n  }]);\n  return Selection;\n}();\nmixin(Selection, localHooks);\nexport default Selection;","map":{"version":3,"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_templateObject","_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","TypeError","o","minLen","_arrayLikeToArray","n","Object","toString","call","slice","name","Array","from","test","len","length","arr2","_i","_s","_e","_x","_r","_arr","_n","_d","next","done","push","value","err","return","isArray","_taggedTemplateLiteral","strings","raw","freeze","defineProperties","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","_toPropertyKey","key","_createClass","protoProps","staticProps","arg","_toPrimitive","String","input","hint","prim","toPrimitive","undefined","res","Number","Highlight","AREA_TYPE","HEADER_TYPE","CELL_TYPE","SelectionRange","createObjectPropListener","mixin","isUndefined","arrayEach","localHooks","Transformation","detectSelectionType","isValidCoord","normalizeSelectionFactory","SELECTION_TYPE_EMPTY","SELECTION_TYPE_UNRECOGNIZED","toSingleLine","Selection","settings","tableProps","_this","inProgress","selectedByCorner","selectedByRowHeader","Set","selectedByColumnHeader","selectedRange","highlight","to","createCellRange","headerClassName","currentHeaderClassName","activeHeaderClassName","rowClassName","currentRowClassName","columnClassName","currentColClassName","disabledCellSelection","row","column","isDisabledCellSelection","cellCornerVisible","isCellCornerVisible","apply","arguments","areaCornerVisible","isAreaCornerVisible","visualToRenderableCoords","coords","renderableToVisualCoords","createCellCoords","rowIndexMapper","columnIndexMapper","transformation","countRows","countRowsTranslated","countCols","countColsTranslated","fixedRowsBottom","minSpareRows","minSpareCols","autoWrapRow","autoWrapCol","addLocalHook","_len","args","_key","runLocalHooks","concat","_len2","_key2","_len3","_key3","_len4","_key4","_len5","_key5","_len6","_key6","getSelectedRange","begin","finish","isInProgress","setRangeStart","multipleSelection","fragment","isMultipleMode","selectionMode","isMultipleSelection","getShortcutManager","isCtrlPressed","isRowNegative","isColumnNegative","col","coordsClone","clone","clear","add","getLayerLevel","setRangeEnd","setRangeStartOnly","isEmpty","cellRange","current","setTo","getCell","isEnabledFor","commit","syncWith","layerLevel","getAreas","getHeaders","getActiveHeaders","useLayerLevel","areaHighlight","createOrGetArea","headerHighlight","createOrGetHeader","activeHeaderHighlight","createOrGetActiveHeader","isMultiple","previousRange","previous","areAnyRowsRendered","areAnyColumnsRendered","headerCellRange","isSelectedByAnyHeader","normalize","isEntireRowSelected","isRowSelected","getWidth","isEntireColumnSelected","isColumnSelected","getHeight","isMultipleListener","isSingle","transformStart","rowDelta","colDelta","force","transformEnd","size","isSelected","isSelectedByRowHeader","isSelectedByCorner","has","isSelectedByColumnHeader","inInSelection","includes","fillHandle","isEditorOpened","isInteger","deselect","selectAll","includeRowHeaders","includeColumnHeaders","nrOfRows","nrOfColumns","startCoords","endCoords","selectCells","selectionRanges","_this2","selectionType","Error","selectionSchemaNormalizer","propToCol","prop","keepDirection","isValid","some","selection","_selectionSchemaNorma","_selectionSchemaNorma2","rowStart","columnStart","rowEnd","columnEnd","_isValid","_selectionSchemaNorma3","_selectionSchemaNorma4","selectColumns","startColumn","endColumn","headerLevel","start","end","selectRows","startRow","endRow","refresh","customSelections","getCustomSelections","forEach","customSelection","cellHighlight","currentLayer"],"sources":["/home/rstorey/wwwdev/Blucktool/node_modules/handsontable/selection/selection.mjs"],"sourcesContent":["function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nvar _templateObject;\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.number.is-integer.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.symbol.to-primitive.js\";\nimport \"core-js/modules/es.date.to-primitive.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.object.freeze.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport Highlight from \"./highlight/highlight.mjs\";\nimport { AREA_TYPE, HEADER_TYPE, CELL_TYPE } from \"./highlight/constants.mjs\";\nimport SelectionRange from \"./range.mjs\";\nimport { createObjectPropListener, mixin } from \"./../helpers/object.mjs\";\nimport { isUndefined } from \"./../helpers/mixed.mjs\";\nimport { arrayEach } from \"./../helpers/array.mjs\";\nimport localHooks from \"./../mixins/localHooks.mjs\";\nimport Transformation from \"./transformation.mjs\";\nimport { detectSelectionType, isValidCoord, normalizeSelectionFactory, SELECTION_TYPE_EMPTY, SELECTION_TYPE_UNRECOGNIZED } from \"./utils.mjs\";\nimport { toSingleLine } from \"./../helpers/templateLiteralTag.mjs\";\n/**\n * @class Selection\n * @util\n */\nvar Selection = /*#__PURE__*/function () {\n  function Selection(settings, tableProps) {\n    var _this = this;\n    _classCallCheck(this, Selection);\n    /**\n     * Handsontable settings instance.\n     *\n     * @type {GridSettings}\n     */\n    this.settings = settings;\n    /**\n     * An additional object with dynamically defined properties which describes table state.\n     *\n     * @type {object}\n     */\n    this.tableProps = tableProps;\n    /**\n     * The flag which determines if the selection is in progress.\n     *\n     * @type {boolean}\n     */\n    this.inProgress = false;\n    /**\n     * The flag indicates that selection was performed by clicking the corner overlay.\n     *\n     * @type {boolean}\n     */\n    this.selectedByCorner = false;\n    /**\n     * The collection of the selection layer levels where the whole row was selected using the row header or\n     * the corner header.\n     *\n     * @type {Set.<number>}\n     */\n    this.selectedByRowHeader = new Set();\n    /**\n     * The collection of the selection layer levels where the whole column was selected using the column header or\n     * the corner header.\n     *\n     * @type {Set.<number>}\n     */\n    this.selectedByColumnHeader = new Set();\n    /**\n     * Selection data layer (handle visual coordinates).\n     *\n     * @type {SelectionRange}\n     */\n    this.selectedRange = new SelectionRange(function (highlight, from, to) {\n      return _this.tableProps.createCellRange(highlight, from, to);\n    });\n    /**\n     * Visualization layer.\n     *\n     * @type {Highlight}\n     */\n    this.highlight = new Highlight({\n      headerClassName: settings.currentHeaderClassName,\n      activeHeaderClassName: settings.activeHeaderClassName,\n      rowClassName: settings.currentRowClassName,\n      columnClassName: settings.currentColClassName,\n      disabledCellSelection: function disabledCellSelection(row, column) {\n        return _this.tableProps.isDisabledCellSelection(row, column);\n      },\n      cellCornerVisible: function cellCornerVisible() {\n        return _this.isCellCornerVisible.apply(_this, arguments);\n      },\n      areaCornerVisible: function areaCornerVisible() {\n        return _this.isAreaCornerVisible.apply(_this, arguments);\n      },\n      visualToRenderableCoords: function visualToRenderableCoords(coords) {\n        return _this.tableProps.visualToRenderableCoords(coords);\n      },\n      renderableToVisualCoords: function renderableToVisualCoords(coords) {\n        return _this.tableProps.renderableToVisualCoords(coords);\n      },\n      createCellCoords: function createCellCoords(row, column) {\n        return _this.tableProps.createCellCoords(row, column);\n      },\n      createCellRange: function createCellRange(highlight, from, to) {\n        return _this.tableProps.createCellRange(highlight, from, to);\n      },\n      rowIndexMapper: function rowIndexMapper() {\n        return _this.tableProps.rowIndexMapper();\n      },\n      columnIndexMapper: function columnIndexMapper() {\n        return _this.tableProps.columnIndexMapper();\n      }\n    });\n    /**\n     * The module for modifying coordinates.\n     *\n     * @type {Transformation}\n     */\n    this.transformation = new Transformation(this.selectedRange, {\n      countRows: function countRows() {\n        return _this.tableProps.countRowsTranslated();\n      },\n      countCols: function countCols() {\n        return _this.tableProps.countColsTranslated();\n      },\n      visualToRenderableCoords: function visualToRenderableCoords(coords) {\n        return _this.tableProps.visualToRenderableCoords(coords);\n      },\n      renderableToVisualCoords: function renderableToVisualCoords(coords) {\n        return _this.tableProps.renderableToVisualCoords(coords);\n      },\n      createCellCoords: function createCellCoords(row, column) {\n        return _this.tableProps.createCellCoords(row, column);\n      },\n      fixedRowsBottom: function fixedRowsBottom() {\n        return settings.fixedRowsBottom;\n      },\n      minSpareRows: function minSpareRows() {\n        return settings.minSpareRows;\n      },\n      minSpareCols: function minSpareCols() {\n        return settings.minSpareCols;\n      },\n      autoWrapRow: function autoWrapRow() {\n        return settings.autoWrapRow;\n      },\n      autoWrapCol: function autoWrapCol() {\n        return settings.autoWrapCol;\n      }\n    });\n    this.transformation.addLocalHook('beforeTransformStart', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _this.runLocalHooks.apply(_this, ['beforeModifyTransformStart'].concat(args));\n    });\n    this.transformation.addLocalHook('afterTransformStart', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return _this.runLocalHooks.apply(_this, ['afterModifyTransformStart'].concat(args));\n    });\n    this.transformation.addLocalHook('beforeTransformEnd', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return _this.runLocalHooks.apply(_this, ['beforeModifyTransformEnd'].concat(args));\n    });\n    this.transformation.addLocalHook('afterTransformEnd', function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      return _this.runLocalHooks.apply(_this, ['afterModifyTransformEnd'].concat(args));\n    });\n    this.transformation.addLocalHook('insertRowRequire', function () {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n      return _this.runLocalHooks.apply(_this, ['insertRowRequire'].concat(args));\n    });\n    this.transformation.addLocalHook('insertColRequire', function () {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n      return _this.runLocalHooks.apply(_this, ['insertColRequire'].concat(args));\n    });\n  }\n\n  /**\n   * Get data layer for current selection.\n   *\n   * @returns {SelectionRange}\n   */\n  _createClass(Selection, [{\n    key: \"getSelectedRange\",\n    value: function getSelectedRange() {\n      return this.selectedRange;\n    }\n\n    /**\n     * Indicate that selection process began. It sets internaly `.inProgress` property to `true`.\n     */\n  }, {\n    key: \"begin\",\n    value: function begin() {\n      this.inProgress = true;\n    }\n\n    /**\n     * Indicate that selection process finished. It sets internaly `.inProgress` property to `false`.\n     */\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      this.runLocalHooks('afterSelectionFinished', Array.from(this.selectedRange));\n      this.inProgress = false;\n    }\n\n    /**\n     * Check if the process of selecting the cell/cells is in progress.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isInProgress\",\n    value: function isInProgress() {\n      return this.inProgress;\n    }\n\n    /**\n     * Starts selection range on given coordinate object.\n     *\n     * @param {CellCoords} coords Visual coords.\n     * @param {boolean} [multipleSelection] If `true`, selection will be worked in 'multiple' mode. This option works\n     *                                      only when 'selectionMode' is set as 'multiple'. If the argument is not defined\n     *                                      the default trigger will be used.\n     * @param {boolean} [fragment=false] If `true`, the selection will be treated as a partial selection where the\n     *                                   `setRangeEnd` method won't be called on every `setRangeStart` call.\n     */\n  }, {\n    key: \"setRangeStart\",\n    value: function setRangeStart(coords, multipleSelection) {\n      var fragment = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var isMultipleMode = this.settings.selectionMode === 'multiple';\n      var isMultipleSelection = isUndefined(multipleSelection) ? this.tableProps.getShortcutManager().isCtrlPressed() : multipleSelection;\n      var isRowNegative = coords.row < 0;\n      var isColumnNegative = coords.col < 0;\n      var selectedByCorner = isRowNegative && isColumnNegative;\n      // We are creating copy. We would like to modify just the start of the selection by below hook. Then original coords\n      // should be handled by next methods.\n      var coordsClone = coords.clone();\n      this.selectedByCorner = selectedByCorner;\n      this.runLocalHooks(\"beforeSetRangeStart\".concat(fragment ? 'Only' : ''), coordsClone);\n      if (!isMultipleMode || isMultipleMode && !isMultipleSelection && isUndefined(multipleSelection)) {\n        this.selectedRange.clear();\n      }\n      this.selectedRange.add(coordsClone);\n      if (this.getLayerLevel() === 0) {\n        this.selectedByRowHeader.clear();\n        this.selectedByColumnHeader.clear();\n      }\n      if (!selectedByCorner && isColumnNegative) {\n        this.selectedByRowHeader.add(this.getLayerLevel());\n      }\n      if (!selectedByCorner && isRowNegative) {\n        this.selectedByColumnHeader.add(this.getLayerLevel());\n      }\n      if (!fragment) {\n        this.setRangeEnd(coords);\n      }\n    }\n\n    /**\n     * Starts selection range on given coordinate object.\n     *\n     * @param {CellCoords} coords Visual coords.\n     * @param {boolean} [multipleSelection] If `true`, selection will be worked in 'multiple' mode. This option works\n     *                                      only when 'selectionMode' is set as 'multiple'. If the argument is not defined\n     *                                      the default trigger will be used.\n     */\n  }, {\n    key: \"setRangeStartOnly\",\n    value: function setRangeStartOnly(coords, multipleSelection) {\n      this.setRangeStart(coords, multipleSelection, true);\n    }\n\n    /**\n     * Ends selection range on given coordinate object.\n     *\n     * @param {CellCoords} coords Visual coords.\n     */\n  }, {\n    key: \"setRangeEnd\",\n    value: function setRangeEnd(coords) {\n      if (this.selectedRange.isEmpty()) {\n        return;\n      }\n\n      // We are creating copy. We would like to modify just the end of the selection by below hook. Then original coords\n      // should be handled by next methods.\n      var coordsClone = coords.clone();\n      this.runLocalHooks('beforeSetRangeEnd', coordsClone);\n      this.begin();\n      var cellRange = this.selectedRange.current();\n      if (this.settings.selectionMode !== 'single') {\n        cellRange.setTo(this.tableProps.createCellCoords(coordsClone.row, coordsClone.col));\n      }\n\n      // Set up current selection.\n      this.highlight.getCell().clear();\n      if (this.highlight.isEnabledFor(CELL_TYPE, cellRange.highlight)) {\n        this.highlight.getCell().add(this.selectedRange.current().highlight).commit().syncWith(cellRange);\n      }\n      var layerLevel = this.getLayerLevel();\n\n      // If the next layer level is lower than previous then clear all area and header highlights. This is the\n      // indication that the new selection is performing.\n      if (layerLevel < this.highlight.layerLevel) {\n        arrayEach(this.highlight.getAreas(), function (highlight) {\n          return void highlight.clear();\n        });\n        arrayEach(this.highlight.getHeaders(), function (highlight) {\n          return void highlight.clear();\n        });\n        arrayEach(this.highlight.getActiveHeaders(), function (highlight) {\n          return void highlight.clear();\n        });\n      }\n      this.highlight.useLayerLevel(layerLevel);\n      var areaHighlight = this.highlight.createOrGetArea();\n      var headerHighlight = this.highlight.createOrGetHeader();\n      var activeHeaderHighlight = this.highlight.createOrGetActiveHeader();\n      areaHighlight.clear();\n      headerHighlight.clear();\n      activeHeaderHighlight.clear();\n      if (this.highlight.isEnabledFor(AREA_TYPE, cellRange.highlight) && (this.isMultiple() || layerLevel >= 1)) {\n        areaHighlight.add(cellRange.from).add(cellRange.to).commit();\n        if (layerLevel === 1) {\n          // For single cell selection in the same layer, we do not create area selection to prevent blue background.\n          // When non-consecutive selection is performed we have to add that missing area selection to the previous layer\n          // based on previous coordinates. It only occurs when the previous selection wasn't select multiple cells.\n          var previousRange = this.selectedRange.previous();\n          this.highlight.useLayerLevel(layerLevel - 1).createOrGetArea().add(previousRange.from).commit()\n          // Range may start with hidden indexes. Commit would not found start point (as we add just the `from` coords).\n          .syncWith(previousRange);\n          this.highlight.useLayerLevel(layerLevel);\n        }\n      }\n      if (this.highlight.isEnabledFor(HEADER_TYPE, cellRange.highlight)) {\n        // The header selection generally contains cell selection. In a case when all rows (or columns)\n        // are hidden that visual coordinates are translated to renderable coordinates that do not exist.\n        // Hence no header highlight is generated. In that case, to make a column (or a row) header\n        // highlight, the row and column index has to point to the header (the negative value). See #7052.\n        var areAnyRowsRendered = this.tableProps.countRowsTranslated() === 0;\n        var areAnyColumnsRendered = this.tableProps.countColsTranslated() === 0;\n        var headerCellRange = cellRange;\n        if (areAnyRowsRendered || areAnyColumnsRendered) {\n          headerCellRange = cellRange.clone();\n        }\n        if (areAnyRowsRendered) {\n          headerCellRange.from.row = -1;\n        }\n        if (areAnyColumnsRendered) {\n          headerCellRange.from.col = -1;\n        }\n        if (this.settings.selectionMode === 'single') {\n          if (this.isSelectedByAnyHeader()) {\n            headerCellRange.from.normalize();\n          }\n          headerHighlight.add(headerCellRange.from).commit();\n        } else {\n          headerHighlight.add(headerCellRange.from).add(headerCellRange.to).commit();\n        }\n        if (this.isEntireRowSelected()) {\n          var isRowSelected = this.tableProps.countCols() === cellRange.getWidth();\n\n          // Make sure that the whole row is selected (in case where selectionMode is set to 'single')\n          if (isRowSelected) {\n            activeHeaderHighlight.add(this.tableProps.createCellCoords(cellRange.from.row, -1)).add(this.tableProps.createCellCoords(cellRange.to.row, -1)).commit();\n          }\n        }\n        if (this.isEntireColumnSelected()) {\n          var isColumnSelected = this.tableProps.countRows() === cellRange.getHeight();\n\n          // Make sure that the whole column is selected (in case where selectionMode is set to 'single')\n          if (isColumnSelected) {\n            activeHeaderHighlight.add(this.tableProps.createCellCoords(-1, cellRange.from.col)).add(this.tableProps.createCellCoords(-1, cellRange.to.col)).commit();\n          }\n        }\n      }\n      this.runLocalHooks('afterSetRangeEnd', coords);\n    }\n\n    /**\n     * Returns information if we have a multiselection. This method check multiselection only on the latest layer of\n     * the selection.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isMultiple\",\n    value: function isMultiple() {\n      var isMultipleListener = createObjectPropListener(!this.selectedRange.current().isSingle());\n      this.runLocalHooks('afterIsMultipleSelection', isMultipleListener);\n      return isMultipleListener.value;\n    }\n\n    /**\n     * Selects cell relative to the current cell (if possible).\n     *\n     * @param {number} rowDelta Rows number to move, value can be passed as negative number.\n     * @param {number} colDelta Columns number to move, value can be passed as negative number.\n     * @param {boolean} [force=false] If `true` the new rows/columns will be created if necessary. Otherwise, row/column will\n     *                        be created according to `minSpareRows/minSpareCols` settings of Handsontable.\n     */\n  }, {\n    key: \"transformStart\",\n    value: function transformStart(rowDelta, colDelta) {\n      var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      this.setRangeStart(this.transformation.transformStart(rowDelta, colDelta, force));\n    }\n\n    /**\n     * Sets selection end cell relative to the current selection end cell (if possible).\n     *\n     * @param {number} rowDelta Rows number to move, value can be passed as negative number.\n     * @param {number} colDelta Columns number to move, value can be passed as negative number.\n     */\n  }, {\n    key: \"transformEnd\",\n    value: function transformEnd(rowDelta, colDelta) {\n      this.setRangeEnd(this.transformation.transformEnd(rowDelta, colDelta));\n    }\n\n    /**\n     * Returns currently used layer level.\n     *\n     * @returns {number} Returns layer level starting from 0. If no selection was added to the table -1 is returned.\n     */\n  }, {\n    key: \"getLayerLevel\",\n    value: function getLayerLevel() {\n      return this.selectedRange.size() - 1;\n    }\n\n    /**\n     * Returns `true` if currently there is a selection on the screen, `false` otherwise.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isSelected\",\n    value: function isSelected() {\n      return !this.selectedRange.isEmpty();\n    }\n\n    /**\n     * Returns `true` if the selection was applied by clicking to the row header. If the `layerLevel`\n     * argument is passed then only that layer will be checked. Otherwise, it checks if any row header\n     * was clicked on any selection layer level.\n     *\n     * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isSelectedByRowHeader\",\n    value: function isSelectedByRowHeader() {\n      var layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n      return !this.isSelectedByCorner(layerLevel) && this.isEntireRowSelected(layerLevel);\n    }\n\n    /**\n     * Returns `true` if the selection consists of entire rows (including their headers). If the `layerLevel`\n     * argument is passed then only that layer will be checked. Otherwise, it checks the selection for all layers.\n     *\n     * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isEntireRowSelected\",\n    value: function isEntireRowSelected() {\n      var layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n      return layerLevel === -1 ? this.selectedByRowHeader.size > 0 : this.selectedByRowHeader.has(layerLevel);\n    }\n\n    /**\n     * Returns `true` if the selection was applied by clicking to the column header. If the `layerLevel`\n     * argument is passed then only that layer will be checked. Otherwise, it checks if any column header\n     * was clicked on any selection layer level.\n     *\n     * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isSelectedByColumnHeader\",\n    value: function isSelectedByColumnHeader() {\n      var layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n      return !this.isSelectedByCorner() && this.isEntireColumnSelected(layerLevel);\n    }\n\n    /**\n     * Returns `true` if the selection consists of entire columns (including their headers). If the `layerLevel`\n     * argument is passed then only that layer will be checked. Otherwise, it checks the selection for all layers.\n     *\n     * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isEntireColumnSelected\",\n    value: function isEntireColumnSelected() {\n      var layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n      return layerLevel === -1 ? this.selectedByColumnHeader.size > 0 : this.selectedByColumnHeader.has(layerLevel);\n    }\n\n    /**\n     * Returns `true` if the selection was applied by clicking on the row or column header on any layer level.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isSelectedByAnyHeader\",\n    value: function isSelectedByAnyHeader() {\n      return this.isSelectedByRowHeader(-1) || this.isSelectedByColumnHeader(-1) || this.isSelectedByCorner();\n    }\n\n    /**\n     * Returns `true` if the selection was applied by clicking on the left-top corner overlay.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isSelectedByCorner\",\n    value: function isSelectedByCorner() {\n      return this.selectedByCorner;\n    }\n\n    /**\n     * Returns `true` if coords is within selection coords. This method iterates through all selection layers to check if\n     * the coords object is within selection range.\n     *\n     * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"inInSelection\",\n    value: function inInSelection(coords) {\n      return this.selectedRange.includes(coords);\n    }\n\n    /**\n     * Returns `true` if the cell corner should be visible.\n     *\n     * @private\n     * @returns {boolean} `true` if the corner element has to be visible, `false` otherwise.\n     */\n  }, {\n    key: \"isCellCornerVisible\",\n    value: function isCellCornerVisible() {\n      return this.settings.fillHandle && !this.tableProps.isEditorOpened() && !this.isMultiple();\n    }\n\n    /**\n     * Returns `true` if the area corner should be visible.\n     *\n     * @param {number} layerLevel The layer level.\n     * @returns {boolean} `true` if the corner element has to be visible, `false` otherwise.\n     */\n  }, {\n    key: \"isAreaCornerVisible\",\n    value: function isAreaCornerVisible(layerLevel) {\n      if (Number.isInteger(layerLevel) && layerLevel !== this.getLayerLevel()) {\n        return false;\n      }\n      return this.settings.fillHandle && !this.tableProps.isEditorOpened() && this.isMultiple();\n    }\n\n    /**\n     * Clear the selection by resetting the collected ranges and highlights.\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      // TODO: collections selectedByColumnHeader and selectedByRowHeader should be clear too.\n      this.selectedRange.clear();\n      this.highlight.clear();\n    }\n\n    /**\n     * Deselects all selected cells.\n     */\n  }, {\n    key: \"deselect\",\n    value: function deselect() {\n      if (!this.isSelected()) {\n        return;\n      }\n      this.inProgress = false;\n      this.clear();\n      this.runLocalHooks('afterDeselect');\n    }\n\n    /**\n     * Select all cells.\n     *\n     * @param {boolean} [includeRowHeaders=false] `true` If the selection should include the row headers, `false`\n     * otherwise.\n     * @param {boolean} [includeColumnHeaders=false] `true` If the selection should include the column headers, `false`\n     * otherwise.\n     */\n  }, {\n    key: \"selectAll\",\n    value: function selectAll() {\n      var includeRowHeaders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var includeColumnHeaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var nrOfRows = this.tableProps.countRows();\n      var nrOfColumns = this.tableProps.countCols();\n\n      // We can't select cells when there is no data.\n      if (!includeRowHeaders && !includeColumnHeaders && (nrOfRows === 0 || nrOfColumns === 0)) {\n        return;\n      }\n      var startCoords = this.tableProps.createCellCoords(includeColumnHeaders ? -1 : 0, includeRowHeaders ? -1 : 0);\n      var endCoords = this.tableProps.createCellCoords(nrOfRows - 1, nrOfColumns - 1);\n      this.clear();\n      this.setRangeStartOnly(startCoords);\n      this.selectedByRowHeader.add(this.getLayerLevel());\n      this.selectedByColumnHeader.add(this.getLayerLevel());\n      this.setRangeEnd(endCoords);\n      this.finish();\n    }\n\n    /**\n     * Make multiple, non-contiguous selection specified by `row` and `column` values or a range of cells\n     * finishing at `endRow`, `endColumn`. The method supports two input formats, first as an array of arrays such\n     * as `[[rowStart, columnStart, rowEnd, columnEnd]]` and second format as an array of CellRange objects.\n     * If the passed ranges have another format the exception will be thrown.\n     *\n     * @param {Array[]|CellRange[]} selectionRanges The coordinates which define what the cells should be selected.\n     * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.\n     */\n  }, {\n    key: \"selectCells\",\n    value: function selectCells(selectionRanges) {\n      var _this2 = this;\n      var selectionType = detectSelectionType(selectionRanges);\n      if (selectionType === SELECTION_TYPE_EMPTY) {\n        return false;\n      } else if (selectionType === SELECTION_TYPE_UNRECOGNIZED) {\n        throw new Error(toSingleLine(_templateObject || (_templateObject = _taggedTemplateLiteral([\"Unsupported format of the selection ranges was passed. To select cells pass \\n        the coordinates as an array of arrays ([[rowStart, columnStart/columnPropStart, rowEnd, \\n        columnEnd/columnPropEnd]]) or as an array of CellRange objects.\"], [\"Unsupported format of the selection ranges was passed. To select cells pass\\\\x20\\n        the coordinates as an array of arrays ([[rowStart, columnStart/columnPropStart, rowEnd,\\\\x20\\n        columnEnd/columnPropEnd]]) or as an array of CellRange objects.\"]))));\n      }\n      var selectionSchemaNormalizer = normalizeSelectionFactory(selectionType, {\n        propToCol: function propToCol(prop) {\n          return _this2.tableProps.propToCol(prop);\n        },\n        keepDirection: true\n      });\n      var nrOfRows = this.tableProps.countRows();\n      var nrOfColumns = this.tableProps.countCols();\n\n      // Check if every layer of the coordinates are valid.\n      var isValid = !selectionRanges.some(function (selection) {\n        var _selectionSchemaNorma = selectionSchemaNormalizer(selection),\n          _selectionSchemaNorma2 = _slicedToArray(_selectionSchemaNorma, 4),\n          rowStart = _selectionSchemaNorma2[0],\n          columnStart = _selectionSchemaNorma2[1],\n          rowEnd = _selectionSchemaNorma2[2],\n          columnEnd = _selectionSchemaNorma2[3];\n        var _isValid = isValidCoord(rowStart, nrOfRows) && isValidCoord(columnStart, nrOfColumns) && isValidCoord(rowEnd, nrOfRows) && isValidCoord(columnEnd, nrOfColumns);\n        return !_isValid;\n      });\n      if (isValid) {\n        this.clear();\n        arrayEach(selectionRanges, function (selection) {\n          var _selectionSchemaNorma3 = selectionSchemaNormalizer(selection),\n            _selectionSchemaNorma4 = _slicedToArray(_selectionSchemaNorma3, 4),\n            rowStart = _selectionSchemaNorma4[0],\n            columnStart = _selectionSchemaNorma4[1],\n            rowEnd = _selectionSchemaNorma4[2],\n            columnEnd = _selectionSchemaNorma4[3];\n          _this2.setRangeStartOnly(_this2.tableProps.createCellCoords(rowStart, columnStart), false);\n          _this2.setRangeEnd(_this2.tableProps.createCellCoords(rowEnd, columnEnd));\n          _this2.finish();\n        });\n      }\n      return isValid;\n    }\n\n    /**\n     * Select column specified by `startColumn` visual index or column property or a range of columns finishing at\n     * `endColumn`.\n     *\n     * @param {number|string} startColumn Visual column index or column property from which the selection starts.\n     * @param {number|string} [endColumn] Visual column index or column property from to the selection finishes.\n     * @param {number} [headerLevel=-1] A row header index that triggers the column selection. The value can\n     *                                  take -1 to -N, where -1 means the header closest to the cells.\n     *\n     * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.\n     */\n  }, {\n    key: \"selectColumns\",\n    value: function selectColumns(startColumn) {\n      var endColumn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startColumn;\n      var headerLevel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n      var start = typeof startColumn === 'string' ? this.tableProps.propToCol(startColumn) : startColumn;\n      var end = typeof endColumn === 'string' ? this.tableProps.propToCol(endColumn) : endColumn;\n      var nrOfColumns = this.tableProps.countCols();\n      var nrOfRows = this.tableProps.countRows();\n      var isValid = isValidCoord(start, nrOfColumns) && isValidCoord(end, nrOfColumns);\n      if (isValid) {\n        this.setRangeStartOnly(this.tableProps.createCellCoords(headerLevel, start));\n        this.setRangeEnd(this.tableProps.createCellCoords(nrOfRows - 1, end));\n        this.finish();\n      }\n      return isValid;\n    }\n\n    /**\n     * Select row specified by `startRow` visual index or a range of rows finishing at `endRow`.\n     *\n     * @param {number} startRow Visual row index from which the selection starts.\n     * @param {number} [endRow] Visual row index from to the selection finishes.\n     * @param {number} [headerLevel=-1] A column header index that triggers the row selection.\n     *                                  The value can take -1 to -N, where -1 means the header\n     *                                  closest to the cells.\n     * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.\n     */\n  }, {\n    key: \"selectRows\",\n    value: function selectRows(startRow) {\n      var endRow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startRow;\n      var headerLevel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n      var nrOfRows = this.tableProps.countRows();\n      var nrOfColumns = this.tableProps.countCols();\n      var isValid = isValidCoord(startRow, nrOfRows) && isValidCoord(endRow, nrOfRows);\n      if (isValid) {\n        this.setRangeStartOnly(this.tableProps.createCellCoords(startRow, headerLevel));\n        this.setRangeEnd(this.tableProps.createCellCoords(endRow, nrOfColumns - 1));\n        this.finish();\n      }\n      return isValid;\n    }\n\n    /**\n     * Rewrite the rendered state of the selection as visual selection may have a new representation in the DOM.\n     */\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      var customSelections = this.highlight.getCustomSelections();\n      customSelections.forEach(function (customSelection) {\n        customSelection.commit();\n      });\n      if (!this.isSelected()) {\n        return;\n      }\n      var cellHighlight = this.highlight.getCell();\n      var currentLayer = this.getLayerLevel();\n      cellHighlight.commit().syncWith(this.selectedRange.current());\n\n      // Rewriting rendered ranges going through all layers.\n      for (var layerLevel = 0; layerLevel < this.selectedRange.size(); layerLevel += 1) {\n        this.highlight.useLayerLevel(layerLevel);\n        var areaHighlight = this.highlight.createOrGetArea();\n        var headerHighlight = this.highlight.createOrGetHeader();\n        var activeHeaderHighlight = this.highlight.createOrGetActiveHeader();\n        areaHighlight.commit();\n        headerHighlight.commit();\n        activeHeaderHighlight.commit();\n      }\n\n      // Reverting starting layer for the Highlight.\n      this.highlight.useLayerLevel(currentLayer);\n    }\n  }]);\n  return Selection;\n}();\nmixin(Selection, localHooks);\nexport default Selection;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}