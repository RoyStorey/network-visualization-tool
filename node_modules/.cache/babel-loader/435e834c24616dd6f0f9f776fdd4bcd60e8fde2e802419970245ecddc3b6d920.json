{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nimport { arrayFilter } from \"../../helpers/array.mjs\";\nimport { assert, isUnsignedNumber, isNullish } from \"./utils.mjs\";\n/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * @class LazyFactoryMap\n *\n * The LazyFactoryMap object holds key-value pairs in the structure similar to the\n * regular Map. Once created, items can be moved around a grid depending on the operations\n * performed on that grid - adding or removing rows. The collection requires \"key\"\n * to be a zero-based index.\n *\n * It's essential to notice that the \"key\" index under which the item was created\n * is volatile. After altering the grid, the \"key\" index can change.\n *\n * Having created N items with corresponding example data where the data has 10\n * holes (`undefined` values) within (that's why internal storage index counts from 10).\n * +------+------+------+------+------+.\n * | 0/10 | 1/11 | 2/12 | 3/13 | 4/14 |  Keys (volatile zero-based index / internal storage index)\n * +------+------+------+------+------+.\n *    │      │      │      │      │\n * +------+------+------+------+------+.\n * | AAA  | BBB  | CCC  | DDD  | EEE  |  Data\n * +------+------+------+------+------+.\n *\n * Map.obtain(0) // returns \"AAA\"\n * map.obtain(2) // returns \"CCC\".\n *\n * After inserting 2 new rows, keys that hold the data positioned after the place\n * where the new rows are added are upshifted by 2.\n *               │\n *               │ Insert 2 rows\n *              \\│/\n * +------+------+------+------+------+.\n * | 0/10 | 1/11 | 2/12 | 3/13 | 4/14 |  Keys before\n * +------+------+------+------+------+.\n *\n *                / 2 new rows \\\n * +------+------+------+------+------+------+------+.\n * | 0/10 | 1/11 | 2/15 | 3/16 | 4/12 | 5/13 | 6/14 |  Keys after\n * +------+------+------+------+------+------+------+.\n *    │       │      │      │      │      │     │\n *    │       │      └──────┼──────┼──────┼┐    │\n *    │       │             └──────┼──────┼┼────┼┐\n *    │       │      ┌─────────────┘      ││    ││\n *    │       │      │      ┌─────────────┘│    ││\n *    │       │      │      │      ┌───────┼────┘│\n *    │       │      │      │      │       │     │\n * +------+------+------+------+------+------+------+.\n * | AAA  | BBB  | CCC  | DDD  | EEE  | FFF  | GGG  |  Data\n * +------+------+------+------+------+------+------+\n *\n * Now at index 2 and 3 we have access to new items.\n *\n * map.obtain(2) // returns new value \"FFF\" for newly created row.\n * map.obtain(4) // index shifted by 2 has access to the old \"CCC\" value, as before inserting.\n *\n * after removing 4 rows, keys that hold the data positioned after the place where the\n * rows are removed are downshifted by 4.\n *        │\n *        │ Remove 4 rows\n *        ├───────────────────────────┐\n *       \\│/                          │\n * +------+------+------+------+------+------+------+\n * | 0/10 | 1/11 | 2/15 | 3/16 | 4/12 | 5/13 | 6/14 |  Keys after\n * +------+------+------+------+------+------+------+\n *    │       │      │      │      │      │     │\n *    │       │      └──────┼──────┼──────┼┐    │\n *    │       │             └──────┼──────┼┼────┼┐\n *    │       │      ┌─────────────┘      ││    ││\n *    │       │      │      ┌─────────────┘│    ││\n *    │       │      │      │      ┌───────┼────┘│\n *    │       │      │      │      │       │     │\n * +------+------+------+------+------+------+------+\n * | AAA  | BBB  | CCC  | DDD  | EEE  | FFF  | GGG  |  Data\n * +------+------+------+------+------+------+------+\n *\n * +------+------+------+\n * | 0/10 | 1/13 | 2/14 |  Keys after\n * +------+------+------+\n *    │       │      │\n *    │       │      └─────────────┐\n *    │       └────────────┐       │\n *    │                    │       │\n *    │                    │       │\n *    │                    │       │\n *    │                    │       │\n * +------+------+------+------+------+------+------+\n * | AAA  | BBB  | CCC  | DDD  | EEE  | FFF  | GGG  |  Data\n * +------+------+------+------+------+------+------+\n *           /│\\   /│\\                   /│\\   /│\\\n *            └──┬──┘                     └──┬──┘\n *           This data is marked as \"hole\" which\n *           means that can be replaced by new item\n *           when that will be created.\n *\n * map.obtain(2) // returns the value (\"EEE\") as it should. Access to the value is\n *               // changed (the key was downshifted). However, the internal index has not changed,\n *               // which means that the data does not need to be changed (spliced) too.\n *\n * After previous remove operation which creates some \"holes\" obtaining new\n * items replaces that \"holes\" as follows:\n *\n * // Obtains new item\n * map.obtain(90) // Returns \"NEW\" value\n *\n * +------+------+------+...+------+\n * | 0/10 | 1/13 | 2/14 |   | 90/0 |  Keys after\n * +------+------+------+...+------+\n *    │       │      │          │\n *    │       │      └──────────┼────────────┐\n *    │       └─────────────────┼─────┐      │\n *    └──────────┐              │     │      │\n *               │              │     │      │\n *    ┌──────────┼──────────────┘     │      │\n *    │          │                    │      │\n * +------+...+------+------+------+------+------+-----+\n * | NEW  |   | AAA  | BBB  | CCC  | DDD  | EEE  | FFF |  Data\n * +------+...+------+------+------+------+------+-----+\n *   /│\\\n *    │\n * The first \"hole\" (at index 0) item is permanently removed and replaced by a new item.\n * The hole index is taken from the hole collection which act as FIFO (First In First Out).\n */\n/* eslint-enable jsdoc/require-description-complete-sentence */\nvar LazyFactoryMap = /*#__PURE__*/function (_Symbol$iterator) {\n  function LazyFactoryMap(valueFactory) {\n    _classCallCheck(this, LazyFactoryMap);\n    this.valueFactory = valueFactory;\n    /**\n     * An array which contains data.\n     *\n     * @type {Array}\n     */\n    this.data = [];\n    /**\n     * An array of indexes where the key of the array is mapped to the value which points to the\n     * specific position of the data array.\n     *\n     * @type {number[]}\n     */\n    this.index = [];\n    /**\n     * The collection of indexes that points to the data items which can be replaced by obtaining new\n     * ones. The \"holes\" are an intended effect of deleting entries.\n     *\n     * The idea of \"holes\" generally allows us to not modify the \"data\" structure while removing\n     * items from the collection.\n     *\n     * @type {Set<number>}\n     */\n    this.holes = new Set();\n  }\n\n  /**\n   * Gets or if data not exist creates and returns new data.\n   *\n   * @param {number} key The item key as zero-based index.\n   * @returns {*}\n   */\n  _createClass(LazyFactoryMap, [{\n    key: \"obtain\",\n    value: function obtain(key) {\n      assert(function () {\n        return isUnsignedNumber(key);\n      }, 'Expecting an unsigned number.');\n      var dataIndex = this._getStorageIndexByKey(key);\n      var result;\n      if (dataIndex >= 0) {\n        result = this.data[dataIndex];\n        if (result === void 0) {\n          result = this.valueFactory(key);\n          this.data[dataIndex] = result;\n        }\n      } else {\n        result = this.valueFactory(key);\n        if (this.holes.size > 0) {\n          var reuseIndex = this.holes.values().next().value; // Gets first item from the collection\n\n          this.holes.delete(reuseIndex);\n          this.data[reuseIndex] = result;\n          this.index[key] = reuseIndex;\n        } else {\n          this.data.push(result);\n          this.index[key] = this.data.length - 1;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Inserts an empty data to the map. This method creates an empty space for obtaining\n     * new data.\n     *\n     * @param {number} key The key as volatile zero-based index at which to begin inserting space for new data.\n     * @param {number} [amount=1] Ammount of data to insert.\n     */\n  }, {\n    key: \"insert\",\n    value: function insert(key) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      assert(function () {\n        return isUnsignedNumber(key) || isNullish(key);\n      }, 'Expecting an unsigned number or null/undefined argument.');\n      var newIndexes = [];\n      var dataLength = this.data.length;\n      for (var i = 0; i < amount; i++) {\n        newIndexes.push(dataLength + i);\n        this.data.push(void 0);\n      }\n      var insertionIndex = isNullish(key) ? this.index.length : key;\n      this.index = [].concat(_toConsumableArray(this.index.slice(0, insertionIndex)), newIndexes, _toConsumableArray(this.index.slice(insertionIndex)));\n    }\n\n    /**\n     * Removes (soft remove) data from \"index\" and according to the amount of data.\n     *\n     * @param {number} key The key as volatile zero-based index at which to begin removing the data.\n     * @param {number} [amount=1] Ammount data to remove.\n     */\n  }, {\n    key: \"remove\",\n    value: function remove(key) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      assert(function () {\n        return isUnsignedNumber(key) || isNullish(key);\n      }, 'Expecting an unsigned number or null/undefined argument.');\n      var removed = this.index.splice(isNullish(key) ? this.index.length - amount : key, amount);\n      for (var i = 0; i < removed.length; i++) {\n        var removedIndex = removed[i];\n        if (typeof removedIndex === 'number') {\n          this.holes.add(removedIndex);\n        }\n      }\n    }\n\n    /**\n     * Returns the size of the data which this map holds.\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"size\",\n    value: function size() {\n      return this.data.length - this.holes.size;\n    }\n\n    /**\n     * Returns a new Iterator object that contains the values for each item in the LazyMap object.\n     *\n     * @returns {Iterator}\n     */\n  }, {\n    key: \"values\",\n    value: function values() {\n      var _this = this;\n      return arrayFilter(this.data, function (_, index) {\n        return !_this.holes.has(index);\n      })[Symbol.iterator]();\n    }\n\n    /**\n     * Returns a new Iterator object that contains an array of `[index, value]` for each item in the LazyMap object.\n     *\n     * @returns {Iterator}\n     */\n  }, {\n    key: \"entries\",\n    value: function entries() {\n      var validEntries = [];\n      for (var i = 0; i < this.data.length; i++) {\n        var keyIndex = this._getKeyByStorageIndex(i);\n        if (keyIndex !== -1) {\n          validEntries.push([keyIndex, this.data[i]]);\n        }\n      }\n      var dataIndex = 0;\n      return {\n        next: function next() {\n          if (dataIndex < validEntries.length) {\n            var value = validEntries[dataIndex];\n            dataIndex += 1;\n            return {\n              value: value,\n              done: false\n            };\n          }\n          return {\n            done: true\n          };\n        }\n      };\n    }\n\n    /**\n     * Clears the map.\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.data = [];\n      this.index = [];\n      this.holes.clear();\n    }\n\n    /**\n     * Gets storage index calculated from the key associated with the specified value.\n     *\n     * @param {number} key Volatile zero-based index.\n     * @returns {number} Returns index 0-N or -1 if no storage index found.\n     */\n  }, {\n    key: \"_getStorageIndexByKey\",\n    value: function _getStorageIndexByKey(key) {\n      return this.index.length > key ? this.index[key] : -1;\n    }\n\n    /**\n     * Gets the key associated with the specified value calculated from storage index.\n     *\n     * @param {number} dataIndex Zero-based storage index.\n     * @returns {number} Returns index 0-N or -1 if no key found.\n     */\n  }, {\n    key: \"_getKeyByStorageIndex\",\n    value: function _getKeyByStorageIndex(dataIndex) {\n      return this.index.indexOf(dataIndex);\n    }\n\n    /**\n     * Makes this object iterable.\n     *\n     * @returns {Iterator}\n     */\n  }, {\n    key: _Symbol$iterator,\n    value: function value() {\n      return this.entries();\n    }\n  }]);\n  return LazyFactoryMap;\n}(Symbol.iterator);\nexport { LazyFactoryMap as default };","map":{"version":3,"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","o","minLen","_arrayLikeToArray","n","Object","toString","call","slice","name","Array","from","test","iter","isArray","len","length","i","arr2","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","_toPropertyKey","key","_createClass","protoProps","staticProps","arg","_toPrimitive","String","input","hint","prim","toPrimitive","undefined","res","Number","arrayFilter","assert","isUnsignedNumber","isNullish","LazyFactoryMap","_Symbol$iterator","valueFactory","data","index","holes","Set","value","obtain","dataIndex","_getStorageIndexByKey","result","size","reuseIndex","values","next","delete","push","insert","amount","arguments","newIndexes","dataLength","insertionIndex","concat","remove","removed","splice","removedIndex","add","_this","_","has","entries","validEntries","keyIndex","_getKeyByStorageIndex","done","clear","indexOf","default"],"sources":["/home/rstorey/wwwdev/Blucktool/node_modules/handsontable/dataMap/metaManager/lazyFactoryMap.mjs"],"sourcesContent":["function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.symbol.to-primitive.js\";\nimport \"core-js/modules/es.date.to-primitive.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { arrayFilter } from \"../../helpers/array.mjs\";\nimport { assert, isUnsignedNumber, isNullish } from \"./utils.mjs\";\n/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * @class LazyFactoryMap\n *\n * The LazyFactoryMap object holds key-value pairs in the structure similar to the\n * regular Map. Once created, items can be moved around a grid depending on the operations\n * performed on that grid - adding or removing rows. The collection requires \"key\"\n * to be a zero-based index.\n *\n * It's essential to notice that the \"key\" index under which the item was created\n * is volatile. After altering the grid, the \"key\" index can change.\n *\n * Having created N items with corresponding example data where the data has 10\n * holes (`undefined` values) within (that's why internal storage index counts from 10).\n * +------+------+------+------+------+.\n * | 0/10 | 1/11 | 2/12 | 3/13 | 4/14 |  Keys (volatile zero-based index / internal storage index)\n * +------+------+------+------+------+.\n *    │      │      │      │      │\n * +------+------+------+------+------+.\n * | AAA  | BBB  | CCC  | DDD  | EEE  |  Data\n * +------+------+------+------+------+.\n *\n * Map.obtain(0) // returns \"AAA\"\n * map.obtain(2) // returns \"CCC\".\n *\n * After inserting 2 new rows, keys that hold the data positioned after the place\n * where the new rows are added are upshifted by 2.\n *               │\n *               │ Insert 2 rows\n *              \\│/\n * +------+------+------+------+------+.\n * | 0/10 | 1/11 | 2/12 | 3/13 | 4/14 |  Keys before\n * +------+------+------+------+------+.\n *\n *                / 2 new rows \\\n * +------+------+------+------+------+------+------+.\n * | 0/10 | 1/11 | 2/15 | 3/16 | 4/12 | 5/13 | 6/14 |  Keys after\n * +------+------+------+------+------+------+------+.\n *    │       │      │      │      │      │     │\n *    │       │      └──────┼──────┼──────┼┐    │\n *    │       │             └──────┼──────┼┼────┼┐\n *    │       │      ┌─────────────┘      ││    ││\n *    │       │      │      ┌─────────────┘│    ││\n *    │       │      │      │      ┌───────┼────┘│\n *    │       │      │      │      │       │     │\n * +------+------+------+------+------+------+------+.\n * | AAA  | BBB  | CCC  | DDD  | EEE  | FFF  | GGG  |  Data\n * +------+------+------+------+------+------+------+\n *\n * Now at index 2 and 3 we have access to new items.\n *\n * map.obtain(2) // returns new value \"FFF\" for newly created row.\n * map.obtain(4) // index shifted by 2 has access to the old \"CCC\" value, as before inserting.\n *\n * after removing 4 rows, keys that hold the data positioned after the place where the\n * rows are removed are downshifted by 4.\n *        │\n *        │ Remove 4 rows\n *        ├───────────────────────────┐\n *       \\│/                          │\n * +------+------+------+------+------+------+------+\n * | 0/10 | 1/11 | 2/15 | 3/16 | 4/12 | 5/13 | 6/14 |  Keys after\n * +------+------+------+------+------+------+------+\n *    │       │      │      │      │      │     │\n *    │       │      └──────┼──────┼──────┼┐    │\n *    │       │             └──────┼──────┼┼────┼┐\n *    │       │      ┌─────────────┘      ││    ││\n *    │       │      │      ┌─────────────┘│    ││\n *    │       │      │      │      ┌───────┼────┘│\n *    │       │      │      │      │       │     │\n * +------+------+------+------+------+------+------+\n * | AAA  | BBB  | CCC  | DDD  | EEE  | FFF  | GGG  |  Data\n * +------+------+------+------+------+------+------+\n *\n * +------+------+------+\n * | 0/10 | 1/13 | 2/14 |  Keys after\n * +------+------+------+\n *    │       │      │\n *    │       │      └─────────────┐\n *    │       └────────────┐       │\n *    │                    │       │\n *    │                    │       │\n *    │                    │       │\n *    │                    │       │\n * +------+------+------+------+------+------+------+\n * | AAA  | BBB  | CCC  | DDD  | EEE  | FFF  | GGG  |  Data\n * +------+------+------+------+------+------+------+\n *           /│\\   /│\\                   /│\\   /│\\\n *            └──┬──┘                     └──┬──┘\n *           This data is marked as \"hole\" which\n *           means that can be replaced by new item\n *           when that will be created.\n *\n * map.obtain(2) // returns the value (\"EEE\") as it should. Access to the value is\n *               // changed (the key was downshifted). However, the internal index has not changed,\n *               // which means that the data does not need to be changed (spliced) too.\n *\n * After previous remove operation which creates some \"holes\" obtaining new\n * items replaces that \"holes\" as follows:\n *\n * // Obtains new item\n * map.obtain(90) // Returns \"NEW\" value\n *\n * +------+------+------+...+------+\n * | 0/10 | 1/13 | 2/14 |   | 90/0 |  Keys after\n * +------+------+------+...+------+\n *    │       │      │          │\n *    │       │      └──────────┼────────────┐\n *    │       └─────────────────┼─────┐      │\n *    └──────────┐              │     │      │\n *               │              │     │      │\n *    ┌──────────┼──────────────┘     │      │\n *    │          │                    │      │\n * +------+...+------+------+------+------+------+-----+\n * | NEW  |   | AAA  | BBB  | CCC  | DDD  | EEE  | FFF |  Data\n * +------+...+------+------+------+------+------+-----+\n *   /│\\\n *    │\n * The first \"hole\" (at index 0) item is permanently removed and replaced by a new item.\n * The hole index is taken from the hole collection which act as FIFO (First In First Out).\n */\n/* eslint-enable jsdoc/require-description-complete-sentence */\nvar LazyFactoryMap = /*#__PURE__*/function (_Symbol$iterator) {\n  function LazyFactoryMap(valueFactory) {\n    _classCallCheck(this, LazyFactoryMap);\n    this.valueFactory = valueFactory;\n    /**\n     * An array which contains data.\n     *\n     * @type {Array}\n     */\n    this.data = [];\n    /**\n     * An array of indexes where the key of the array is mapped to the value which points to the\n     * specific position of the data array.\n     *\n     * @type {number[]}\n     */\n    this.index = [];\n    /**\n     * The collection of indexes that points to the data items which can be replaced by obtaining new\n     * ones. The \"holes\" are an intended effect of deleting entries.\n     *\n     * The idea of \"holes\" generally allows us to not modify the \"data\" structure while removing\n     * items from the collection.\n     *\n     * @type {Set<number>}\n     */\n    this.holes = new Set();\n  }\n\n  /**\n   * Gets or if data not exist creates and returns new data.\n   *\n   * @param {number} key The item key as zero-based index.\n   * @returns {*}\n   */\n  _createClass(LazyFactoryMap, [{\n    key: \"obtain\",\n    value: function obtain(key) {\n      assert(function () {\n        return isUnsignedNumber(key);\n      }, 'Expecting an unsigned number.');\n      var dataIndex = this._getStorageIndexByKey(key);\n      var result;\n      if (dataIndex >= 0) {\n        result = this.data[dataIndex];\n        if (result === void 0) {\n          result = this.valueFactory(key);\n          this.data[dataIndex] = result;\n        }\n      } else {\n        result = this.valueFactory(key);\n        if (this.holes.size > 0) {\n          var reuseIndex = this.holes.values().next().value; // Gets first item from the collection\n\n          this.holes.delete(reuseIndex);\n          this.data[reuseIndex] = result;\n          this.index[key] = reuseIndex;\n        } else {\n          this.data.push(result);\n          this.index[key] = this.data.length - 1;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Inserts an empty data to the map. This method creates an empty space for obtaining\n     * new data.\n     *\n     * @param {number} key The key as volatile zero-based index at which to begin inserting space for new data.\n     * @param {number} [amount=1] Ammount of data to insert.\n     */\n  }, {\n    key: \"insert\",\n    value: function insert(key) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      assert(function () {\n        return isUnsignedNumber(key) || isNullish(key);\n      }, 'Expecting an unsigned number or null/undefined argument.');\n      var newIndexes = [];\n      var dataLength = this.data.length;\n      for (var i = 0; i < amount; i++) {\n        newIndexes.push(dataLength + i);\n        this.data.push(void 0);\n      }\n      var insertionIndex = isNullish(key) ? this.index.length : key;\n      this.index = [].concat(_toConsumableArray(this.index.slice(0, insertionIndex)), newIndexes, _toConsumableArray(this.index.slice(insertionIndex)));\n    }\n\n    /**\n     * Removes (soft remove) data from \"index\" and according to the amount of data.\n     *\n     * @param {number} key The key as volatile zero-based index at which to begin removing the data.\n     * @param {number} [amount=1] Ammount data to remove.\n     */\n  }, {\n    key: \"remove\",\n    value: function remove(key) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      assert(function () {\n        return isUnsignedNumber(key) || isNullish(key);\n      }, 'Expecting an unsigned number or null/undefined argument.');\n      var removed = this.index.splice(isNullish(key) ? this.index.length - amount : key, amount);\n      for (var i = 0; i < removed.length; i++) {\n        var removedIndex = removed[i];\n        if (typeof removedIndex === 'number') {\n          this.holes.add(removedIndex);\n        }\n      }\n    }\n\n    /**\n     * Returns the size of the data which this map holds.\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"size\",\n    value: function size() {\n      return this.data.length - this.holes.size;\n    }\n\n    /**\n     * Returns a new Iterator object that contains the values for each item in the LazyMap object.\n     *\n     * @returns {Iterator}\n     */\n  }, {\n    key: \"values\",\n    value: function values() {\n      var _this = this;\n      return arrayFilter(this.data, function (_, index) {\n        return !_this.holes.has(index);\n      })[Symbol.iterator]();\n    }\n\n    /**\n     * Returns a new Iterator object that contains an array of `[index, value]` for each item in the LazyMap object.\n     *\n     * @returns {Iterator}\n     */\n  }, {\n    key: \"entries\",\n    value: function entries() {\n      var validEntries = [];\n      for (var i = 0; i < this.data.length; i++) {\n        var keyIndex = this._getKeyByStorageIndex(i);\n        if (keyIndex !== -1) {\n          validEntries.push([keyIndex, this.data[i]]);\n        }\n      }\n      var dataIndex = 0;\n      return {\n        next: function next() {\n          if (dataIndex < validEntries.length) {\n            var value = validEntries[dataIndex];\n            dataIndex += 1;\n            return {\n              value: value,\n              done: false\n            };\n          }\n          return {\n            done: true\n          };\n        }\n      };\n    }\n\n    /**\n     * Clears the map.\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.data = [];\n      this.index = [];\n      this.holes.clear();\n    }\n\n    /**\n     * Gets storage index calculated from the key associated with the specified value.\n     *\n     * @param {number} key Volatile zero-based index.\n     * @returns {number} Returns index 0-N or -1 if no storage index found.\n     */\n  }, {\n    key: \"_getStorageIndexByKey\",\n    value: function _getStorageIndexByKey(key) {\n      return this.index.length > key ? this.index[key] : -1;\n    }\n\n    /**\n     * Gets the key associated with the specified value calculated from storage index.\n     *\n     * @param {number} dataIndex Zero-based storage index.\n     * @returns {number} Returns index 0-N or -1 if no key found.\n     */\n  }, {\n    key: \"_getKeyByStorageIndex\",\n    value: function _getKeyByStorageIndex(dataIndex) {\n      return this.index.indexOf(dataIndex);\n    }\n\n    /**\n     * Makes this object iterable.\n     *\n     * @returns {Iterator}\n     */\n  }, {\n    key: _Symbol$iterator,\n    value: function value() {\n      return this.entries();\n    }\n  }]);\n  return LazyFactoryMap;\n}(Symbol.iterator);\nexport { LazyFactoryMap as default };"],"mappings":"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CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIC,cAAc,GAAG,aAAa,UAAUC,gBAAgB,EAAE;EAC5D,SAASD,cAAcA,CAACE,YAAY,EAAE;IACpChC,eAAe,CAAC,IAAI,EAAE8B,cAAc,CAAC;IACrC,IAAI,CAACE,YAAY,GAAGA,YAAY;IAChC;AACJ;AACA;AACA;AACA;IACI,IAAI,CAACC,IAAI,GAAG,EAAE;IACd;AACJ;AACA;AACA;AACA;AACA;IACI,IAAI,CAACC,KAAK,GAAG,EAAE;IACf;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI,IAAI,CAACC,KAAK,GAAG,IAAIC,GAAG,EAAE;EACxB;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEvB,YAAY,CAACiB,cAAc,EAAE,CAAC;IAC5BlB,GAAG,EAAE,QAAQ;IACbyB,KAAK,EAAE,SAASC,MAAMA,CAAC1B,GAAG,EAAE;MAC1Be,MAAM,CAAC,YAAY;QACjB,OAAOC,gBAAgB,CAAChB,GAAG,CAAC;MAC9B,CAAC,EAAE,+BAA+B,CAAC;MACnC,IAAI2B,SAAS,GAAG,IAAI,CAACC,qBAAqB,CAAC5B,GAAG,CAAC;MAC/C,IAAI6B,MAAM;MACV,IAAIF,SAAS,IAAI,CAAC,EAAE;QAClBE,MAAM,GAAG,IAAI,CAACR,IAAI,CAACM,SAAS,CAAC;QAC7B,IAAIE,MAAM,KAAK,KAAK,CAAC,EAAE;UACrBA,MAAM,GAAG,IAAI,CAACT,YAAY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"},"metadata":{},"sourceType":"module","externalDependencies":[]}