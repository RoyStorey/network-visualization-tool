{"ast":null,"code":"import { createUniqueMap } from \"../utils/dataStructures/uniqueMap.mjs\";\nimport { createContext } from \"./context.mjs\";\nimport { useRecorder } from \"./recorder.mjs\";\n/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * The `ShortcutManager` API lets you store and manage [keyboard shortcut contexts](@/guides/accessories-and-menus/keyboard-shortcuts.md#keyboard-shortcut-contexts) ([`ShortcutContext`](@/api/shortcutContext.md)).\n *\n * Each `ShortcutManager` object:\n * - Stores and manages its own set of keyboard shortcut contexts.\n * - Listens to the [`KeyboardEvent`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent) events and runs actions for them.\n *\n * @alias ShortcutManager\n * @class ShortcutManager\n * @param {object} options The manager's options\n * @param {EventTarget} options.ownerWindow A starting `window` element\n * @param {Function} options.handleEvent A condition on which `event` is handled.\n * @param {Function} options.beforeKeyDown A hook fired before the `keydown` event is handled. You can use it to [block a keyboard shortcut's actions](@/guides/accessories-and-menus/keyboard-shortcuts.md#block-a-keyboard-shortcut-s-actions).\n * @param {Function} options.afterKeyDown A hook fired after the `keydown` event is handled\n */\nexport var createShortcutManager = function createShortcutManager(_ref) {\n  var ownerWindow = _ref.ownerWindow,\n    handleEvent = _ref.handleEvent,\n    beforeKeyDown = _ref.beforeKeyDown,\n    afterKeyDown = _ref.afterKeyDown;\n  /**\n   * A unique map that stores keyboard shortcut contexts.\n   *\n   * @type {UniqueMap}\n   */\n  var CONTEXTS = createUniqueMap({\n    errorIdExists: function errorIdExists(keys) {\n      return \"The \\\"\".concat(keys, \"\\\" context name is already registered.\");\n    }\n  });\n  /**\n   * The name of the active [`ShortcutContext`](@/api/shortcutContext.md).\n   *\n   * @type {string}\n   */\n  var activeContextName = 'grid';\n\n  /**\n   * Create a new [`ShortcutContext`](@/api/shortcutContext.md) object.\n   *\n   * @memberof ShortcutManager#\n   * @param {string} contextName The name of the new shortcut context\n   * @returns {object}\n   */\n  var addContext = function addContext(contextName) {\n    var context = createContext(contextName);\n    CONTEXTS.addItem(contextName, context);\n    return context;\n  };\n\n  /**\n   * Get the ID of the active [`ShortcutContext`](@/api/shortcutContext.md).\n   *\n   * @memberof ShortcutManager#\n   * @returns {string}\n   */\n  var getActiveContextName = function getActiveContextName() {\n    return activeContextName;\n  };\n\n  /**\n   * Get a keyboard shortcut context by its name.\n   *\n   * @memberof ShortcutManager#\n   * @param {string} contextName The name of the shortcut context\n   * @returns {object|undefined} A [`ShortcutContext`](@/api/shortcutContext.md) object that stores registered shortcuts\n   */\n  var getContext = function getContext(contextName) {\n    return CONTEXTS.getItem(contextName);\n  };\n\n  /**\n   * Start listening to keyboard shortcuts within a given [`ShortcutContext`](@/api/shortcutContext.md).\n   *\n   * @memberof ShortcutManager#\n   * @param {string} contextName The name of the shortcut context\n   */\n  var setActiveContextName = function setActiveContextName(contextName) {\n    activeContextName = contextName;\n  };\n\n  /**\n   * This variable relates to the `captureCtrl` shortcut option,\n   * which allows for capturing the state of the Control/Meta modifier key.\n   * Some of the default keyboard shortcuts related to cell selection need this feature for working properly.\n   *\n   * @type {boolean}\n   */\n  var isCtrlKeySilenced = false;\n\n  /**\n   * Internal key recorder.\n   *\n   * @private\n   */\n  var keyRecorder = useRecorder(ownerWindow, handleEvent, beforeKeyDown, afterKeyDown, function (event, keys) {\n    var activeContext = getContext(getActiveContextName());\n    var isExecutionCancelled = false;\n    if (!activeContext.hasShortcut(keys)) {\n      return isExecutionCancelled;\n    }\n\n    // Processing just actions being in stack at the moment of shortcut pressing (without respecting additions/removals performed dynamically).\n    var shortcuts = activeContext.getShortcuts(keys);\n    for (var index = 0; index < shortcuts.length; index++) {\n      var _shortcuts$index = shortcuts[index],\n        callback = _shortcuts$index.callback,\n        runOnlyIf = _shortcuts$index.runOnlyIf,\n        preventDefault = _shortcuts$index.preventDefault,\n        stopPropagation = _shortcuts$index.stopPropagation,\n        captureCtrl = _shortcuts$index.captureCtrl;\n      if (runOnlyIf(event) !== false) {\n        isCtrlKeySilenced = captureCtrl;\n        isExecutionCancelled = callback(event, keys) === false;\n        isCtrlKeySilenced = false;\n        if (preventDefault) {\n          event.preventDefault();\n        }\n        if (stopPropagation) {\n          event.stopPropagation();\n        }\n        if (isExecutionCancelled) {\n          break;\n        }\n      }\n    }\n    return isExecutionCancelled;\n  });\n  keyRecorder.mount();\n  return {\n    addContext: addContext,\n    getActiveContextName: getActiveContextName,\n    getContext: getContext,\n    setActiveContextName: setActiveContextName,\n    /**\n     * Returns whether `control` or `meta` keys are pressed.\n     *\n     * @memberof ShortcutManager#\n     * @type {Function}\n     * @returns {boolean}\n     */\n    isCtrlPressed: function isCtrlPressed() {\n      return !isCtrlKeySilenced && (keyRecorder.isPressed('control') || keyRecorder.isPressed('meta'));\n    },\n    /**\n     * Release every previously pressed key.\n     *\n     * @type {Function}\n     * @memberof ShortcutManager#\n     */\n    releasePressedKeys: function releasePressedKeys() {\n      return keyRecorder.releasePressedKeys();\n    },\n    /**\n     * Destroy a context manager instance.\n     *\n     * @type {Function}\n     * @memberof ShortcutManager#\n     */\n    destroy: function destroy() {\n      return keyRecorder.unmount();\n    }\n  };\n};","map":{"version":3,"names":["createUniqueMap","createContext","useRecorder","createShortcutManager","_ref","ownerWindow","handleEvent","beforeKeyDown","afterKeyDown","CONTEXTS","errorIdExists","keys","concat","activeContextName","addContext","contextName","context","addItem","getActiveContextName","getContext","getItem","setActiveContextName","isCtrlKeySilenced","keyRecorder","event","activeContext","isExecutionCancelled","hasShortcut","shortcuts","getShortcuts","index","length","_shortcuts$index","callback","runOnlyIf","preventDefault","stopPropagation","captureCtrl","mount","isCtrlPressed","isPressed","releasePressedKeys","destroy","unmount"],"sources":["/home/rstorey/wwwdev/Blucktool/node_modules/handsontable/shortcuts/manager.mjs"],"sourcesContent":["import { createUniqueMap } from \"../utils/dataStructures/uniqueMap.mjs\";\nimport { createContext } from \"./context.mjs\";\nimport { useRecorder } from \"./recorder.mjs\";\n/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * The `ShortcutManager` API lets you store and manage [keyboard shortcut contexts](@/guides/accessories-and-menus/keyboard-shortcuts.md#keyboard-shortcut-contexts) ([`ShortcutContext`](@/api/shortcutContext.md)).\n *\n * Each `ShortcutManager` object:\n * - Stores and manages its own set of keyboard shortcut contexts.\n * - Listens to the [`KeyboardEvent`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent) events and runs actions for them.\n *\n * @alias ShortcutManager\n * @class ShortcutManager\n * @param {object} options The manager's options\n * @param {EventTarget} options.ownerWindow A starting `window` element\n * @param {Function} options.handleEvent A condition on which `event` is handled.\n * @param {Function} options.beforeKeyDown A hook fired before the `keydown` event is handled. You can use it to [block a keyboard shortcut's actions](@/guides/accessories-and-menus/keyboard-shortcuts.md#block-a-keyboard-shortcut-s-actions).\n * @param {Function} options.afterKeyDown A hook fired after the `keydown` event is handled\n */\nexport var createShortcutManager = function createShortcutManager(_ref) {\n  var ownerWindow = _ref.ownerWindow,\n    handleEvent = _ref.handleEvent,\n    beforeKeyDown = _ref.beforeKeyDown,\n    afterKeyDown = _ref.afterKeyDown;\n  /**\n   * A unique map that stores keyboard shortcut contexts.\n   *\n   * @type {UniqueMap}\n   */\n  var CONTEXTS = createUniqueMap({\n    errorIdExists: function errorIdExists(keys) {\n      return \"The \\\"\".concat(keys, \"\\\" context name is already registered.\");\n    }\n  });\n  /**\n   * The name of the active [`ShortcutContext`](@/api/shortcutContext.md).\n   *\n   * @type {string}\n   */\n  var activeContextName = 'grid';\n\n  /**\n   * Create a new [`ShortcutContext`](@/api/shortcutContext.md) object.\n   *\n   * @memberof ShortcutManager#\n   * @param {string} contextName The name of the new shortcut context\n   * @returns {object}\n   */\n  var addContext = function addContext(contextName) {\n    var context = createContext(contextName);\n    CONTEXTS.addItem(contextName, context);\n    return context;\n  };\n\n  /**\n   * Get the ID of the active [`ShortcutContext`](@/api/shortcutContext.md).\n   *\n   * @memberof ShortcutManager#\n   * @returns {string}\n   */\n  var getActiveContextName = function getActiveContextName() {\n    return activeContextName;\n  };\n\n  /**\n   * Get a keyboard shortcut context by its name.\n   *\n   * @memberof ShortcutManager#\n   * @param {string} contextName The name of the shortcut context\n   * @returns {object|undefined} A [`ShortcutContext`](@/api/shortcutContext.md) object that stores registered shortcuts\n   */\n  var getContext = function getContext(contextName) {\n    return CONTEXTS.getItem(contextName);\n  };\n\n  /**\n   * Start listening to keyboard shortcuts within a given [`ShortcutContext`](@/api/shortcutContext.md).\n   *\n   * @memberof ShortcutManager#\n   * @param {string} contextName The name of the shortcut context\n   */\n  var setActiveContextName = function setActiveContextName(contextName) {\n    activeContextName = contextName;\n  };\n\n  /**\n   * This variable relates to the `captureCtrl` shortcut option,\n   * which allows for capturing the state of the Control/Meta modifier key.\n   * Some of the default keyboard shortcuts related to cell selection need this feature for working properly.\n   *\n   * @type {boolean}\n   */\n  var isCtrlKeySilenced = false;\n\n  /**\n   * Internal key recorder.\n   *\n   * @private\n   */\n  var keyRecorder = useRecorder(ownerWindow, handleEvent, beforeKeyDown, afterKeyDown, function (event, keys) {\n    var activeContext = getContext(getActiveContextName());\n    var isExecutionCancelled = false;\n    if (!activeContext.hasShortcut(keys)) {\n      return isExecutionCancelled;\n    }\n\n    // Processing just actions being in stack at the moment of shortcut pressing (without respecting additions/removals performed dynamically).\n    var shortcuts = activeContext.getShortcuts(keys);\n    for (var index = 0; index < shortcuts.length; index++) {\n      var _shortcuts$index = shortcuts[index],\n        callback = _shortcuts$index.callback,\n        runOnlyIf = _shortcuts$index.runOnlyIf,\n        preventDefault = _shortcuts$index.preventDefault,\n        stopPropagation = _shortcuts$index.stopPropagation,\n        captureCtrl = _shortcuts$index.captureCtrl;\n      if (runOnlyIf(event) !== false) {\n        isCtrlKeySilenced = captureCtrl;\n        isExecutionCancelled = callback(event, keys) === false;\n        isCtrlKeySilenced = false;\n        if (preventDefault) {\n          event.preventDefault();\n        }\n        if (stopPropagation) {\n          event.stopPropagation();\n        }\n        if (isExecutionCancelled) {\n          break;\n        }\n      }\n    }\n    return isExecutionCancelled;\n  });\n  keyRecorder.mount();\n  return {\n    addContext: addContext,\n    getActiveContextName: getActiveContextName,\n    getContext: getContext,\n    setActiveContextName: setActiveContextName,\n    /**\n     * Returns whether `control` or `meta` keys are pressed.\n     *\n     * @memberof ShortcutManager#\n     * @type {Function}\n     * @returns {boolean}\n     */\n    isCtrlPressed: function isCtrlPressed() {\n      return !isCtrlKeySilenced && (keyRecorder.isPressed('control') || keyRecorder.isPressed('meta'));\n    },\n    /**\n     * Release every previously pressed key.\n     *\n     * @type {Function}\n     * @memberof ShortcutManager#\n     */\n    releasePressedKeys: function releasePressedKeys() {\n      return keyRecorder.releasePressedKeys();\n    },\n    /**\n     * Destroy a context manager instance.\n     *\n     * @type {Function}\n     * @memberof ShortcutManager#\n     */\n    destroy: function destroy() {\n      return keyRecorder.unmount();\n    }\n  };\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}