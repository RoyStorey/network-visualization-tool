{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) {\n  _checkPrivateRedeclaration(obj, privateMap);\n  privateMap.set(obj, value);\n}\nfunction _checkPrivateRedeclaration(obj, privateCollection) {\n  if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n  }\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nfunction _classPrivateFieldGet(receiver, privateMap) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\");\n  return _classApplyDescriptorGet(receiver, descriptor);\n}\nfunction _classApplyDescriptorGet(receiver, descriptor) {\n  if (descriptor.get) {\n    return descriptor.get.call(receiver);\n  }\n  return descriptor.value;\n}\nfunction _classPrivateFieldSet(receiver, privateMap, value) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\");\n  _classApplyDescriptorSet(receiver, descriptor, value);\n  return value;\n}\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to \" + action + \" private field on non-instance\");\n  }\n  return privateMap.get(receiver);\n}\nfunction _classApplyDescriptorSet(receiver, descriptor, value) {\n  if (descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } else {\n    if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set read only private field\");\n    }\n    descriptor.value = value;\n  }\n}\nimport CellCoords from \"./../cell/coords.mjs\";\n/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * @description\n *\n * The `CellRange` class holds a set of cell coordinates ([`CellCoords`](@/api/cellCoords.md) instances)\n * that form a [selection range](@/guides/cell-features/selection.md#select-ranges).\n *\n * A single `CellRange` instance represents a single unit of selection\n * that contains either a single cell or multiple adjacent cells.\n *\n * To import the `CellRange` class:\n *\n * ```js\n * import Handsontable, { CellRange } from '/handsontable';\n *\n * // or, using modules\n * import Handsontable, { CellRange } from '/handsontable/base';\n * ```\n */\nvar _isRtl = /*#__PURE__*/new WeakMap();\nvar CellRange = /*#__PURE__*/function () {\n  /**\n   * Used to draw bold border around a cell where selection was started and to edit the cell\n   * when you press Enter. The highlight cannot point to headers (negative values) so its\n   * coordinates object is normalized while assigning.\n   *\n   * @private\n   * @type {CellCoords}\n   */\n\n  /**\n   * Usually the same as highlight, but in Excel there is distinction - one can change\n   * highlight within a selection.\n   *\n   * @private\n   * @type {CellCoords}\n   */\n\n  /**\n   * End selection.\n   *\n   * @private\n   * @type {CellCoords}\n   */\n\n  /**\n   * @type {boolean}\n   */\n\n  function CellRange(highlight) {\n    var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : highlight;\n    var to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : highlight;\n    var isRtl = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    _classCallCheck(this, CellRange);\n    _defineProperty(this, \"highlight\", null);\n    _defineProperty(this, \"from\", null);\n    _defineProperty(this, \"to\", null);\n    _classPrivateFieldInitSpec(this, _isRtl, {\n      writable: true,\n      value: false\n    });\n    this.highlight = highlight.clone().normalize();\n    this.from = from.clone();\n    this.to = to.clone();\n    _classPrivateFieldSet(this, _isRtl, isRtl);\n  }\n\n  /**\n   * Highlights cell selection at the `coords` coordinates.\n   *\n   * @param {CellCoords} coords Coordinates to use.\n   * @returns {CellRange}\n   */\n  _createClass(CellRange, [{\n    key: \"setHighlight\",\n    value: function setHighlight(coords) {\n      this.highlight = coords.clone().normalize();\n      return this;\n    }\n\n    /**\n     * Sets the `coords` coordinates as the start of your range.\n     *\n     * @param {CellCoords} coords Coordinates to use.\n     * @returns {CellRange}\n     */\n  }, {\n    key: \"setFrom\",\n    value: function setFrom(coords) {\n      this.from = coords.clone();\n      return this;\n    }\n\n    /**\n     * Sets the `coords` coordinates as the end of your range.\n     *\n     * @param {CellCoords} coords Coordinates to use.\n     * @returns {CellRange}\n     */\n  }, {\n    key: \"setTo\",\n    value: function setTo(coords) {\n      this.to = coords.clone();\n      return this;\n    }\n\n    /**\n     * Checks if the coordinates in your `CellRange` instance are valid\n     * in the context of a given Walkontable instance.\n     *\n     * See the [`isValid()`](@/api/cellCoords.md#isvalid) method of the [`CellCoords`](@/api/cellCoords.md) class.\n     *\n     * @param {Walkontable} wot A Walkontable instance.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isValid\",\n    value: function isValid(wot) {\n      return this.from.isValid(wot) && this.to.isValid(wot);\n    }\n\n    /**\n     * Checks if your range is just a single cell.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isSingle\",\n    value: function isSingle() {\n      return this.from.row >= 0 && this.from.row === this.to.row && this.from.col >= 0 && this.from.col === this.to.col;\n    }\n\n    /**\n     * Returns the height of your range (as a number of rows, including row headers).\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getOuterHeight\",\n    value: function getOuterHeight() {\n      return Math.max(this.from.row, this.to.row) - Math.min(this.from.row, this.to.row) + 1;\n    }\n\n    /**\n     * Returns the width of your range (as a number of columns, including column headers).\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getOuterWidth\",\n    value: function getOuterWidth() {\n      return Math.max(this.from.col, this.to.col) - Math.min(this.from.col, this.to.col) + 1;\n    }\n\n    /**\n     * Returns the height of your range (as a number of rows, excluding row headers).\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getHeight\",\n    value: function getHeight() {\n      // if the selection contains only row headers, return 0\n      if (this.from.row < 0 && this.to.row < 0) {\n        return 0;\n      }\n      var fromRow = Math.max(this.from.row, 0);\n      var toRow = Math.max(this.to.row, 0);\n      return Math.max(fromRow, toRow) - Math.min(fromRow, toRow) + 1;\n    }\n\n    /**\n     * Returns the width of your range (as a number of columns, excluding column headers).\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getWidth\",\n    value: function getWidth() {\n      // if the selection contains only column headers, return 0\n      if (this.from.col < 0 && this.to.col < 0) {\n        return 0;\n      }\n      var fromCol = Math.max(this.from.col, 0);\n      var toCol = Math.max(this.to.col, 0);\n      return Math.max(fromCol, toCol) - Math.min(fromCol, toCol) + 1;\n    }\n\n    /**\n     * Returns the number of cells within your range (excluding column and row headers).\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getCellsCount\",\n    value: function getCellsCount() {\n      return this.getWidth() * this.getHeight();\n    }\n\n    /**\n     * Checks if another set of coordinates (`cellCoords`)\n     * is within the `from` and `to` coordinates of your range.\n     *\n     * @param {CellCoords} cellCoords Coordinates to check.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"includes\",\n    value: function includes(cellCoords) {\n      var row = cellCoords.row,\n        col = cellCoords.col;\n      var topStart = this.getOuterTopStartCorner();\n      var bottomEnd = this.getOuterBottomEndCorner();\n      return topStart.row <= row && bottomEnd.row >= row && topStart.col <= col && bottomEnd.col >= col;\n    }\n\n    /**\n     * Checks if another range (`cellRange`) is within your range.\n     *\n     * @param {CellRange} cellRange A range to check.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"includesRange\",\n    value: function includesRange(cellRange) {\n      return this.includes(cellRange.getOuterTopStartCorner()) && this.includes(cellRange.getOuterBottomEndCorner());\n    }\n\n    /**\n     * Checks if another range (`cellRange`) is equal to your range.\n     *\n     * @param {CellRange} cellRange A range to check.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(cellRange) {\n      return Math.min(this.from.row, this.to.row) === Math.min(cellRange.from.row, cellRange.to.row) && Math.max(this.from.row, this.to.row) === Math.max(cellRange.from.row, cellRange.to.row) && Math.min(this.from.col, this.to.col) === Math.min(cellRange.from.col, cellRange.to.col) && Math.max(this.from.col, this.to.col) === Math.max(cellRange.from.col, cellRange.to.col);\n    }\n\n    /**\n     * Checks if another range (`cellRange`) overlaps your range.\n     *\n     * Range A overlaps range B if the intersection of A and B (or B and A) is not empty.\n     *\n     * @param {CellRange} cellRange A range to check.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"overlaps\",\n    value: function overlaps(cellRange) {\n      return cellRange.isSouthEastOf(this.getOuterTopLeftCorner()) && cellRange.isNorthWestOf(this.getOuterBottomRightCorner());\n    }\n\n    /**\n     * Checks if another range (`cellRange`) is south-east of your range.\n     *\n     * @param {CellRange} cellRange A range to check.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isSouthEastOf\",\n    value: function isSouthEastOf(cellRange) {\n      return this.getOuterTopLeftCorner().isSouthEastOf(cellRange) || this.getOuterBottomRightCorner().isSouthEastOf(cellRange);\n    }\n\n    /**\n     * Checks if another range (`cellRange`) is north-west of your range.\n     *\n     * @param {CellRange} cellRange A range to check.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isNorthWestOf\",\n    value: function isNorthWestOf(cellRange) {\n      return this.getOuterTopLeftCorner().isNorthWestOf(cellRange) || this.getOuterBottomRightCorner().isNorthWestOf(cellRange);\n    }\n\n    /**\n     * Checks if another range (`cellRange`) overlaps your range horizontally.\n     *\n     * For example: returns `true` if the last column of your range is `5`\n     * and the first column of the `cellRange` range is `3`.\n     *\n     * @param {CellRange} cellRange A range to check.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isOverlappingHorizontally\",\n    value: function isOverlappingHorizontally(cellRange) {\n      return this.getOuterTopRightCorner().col >= cellRange.getOuterTopLeftCorner().col && this.getOuterTopRightCorner().col <= cellRange.getOuterTopRightCorner().col || this.getOuterTopLeftCorner().col <= cellRange.getOuterTopRightCorner().col && this.getOuterTopLeftCorner().col >= cellRange.getOuterTopLeftCorner().col;\n    }\n\n    /**\n     * Checks if another range (`cellRange`) overlaps your range vertically.\n     *\n     * For example: returns `true` if the last row of your range is `5`\n     * and the first row of the `cellRange` range is `3`.\n     *\n     * @param {CellRange} cellRange A range to check.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isOverlappingVertically\",\n    value: function isOverlappingVertically(cellRange) {\n      return this.getOuterBottomRightCorner().row >= cellRange.getOuterTopRightCorner().row && this.getOuterBottomRightCorner().row <= cellRange.getOuterBottomRightCorner().row || this.getOuterTopRightCorner().row <= cellRange.getOuterBottomRightCorner().row && this.getOuterTopRightCorner().row >= cellRange.getOuterTopRightCorner().row;\n    }\n\n    /**\n     * Adds a cell to your range, at `cellCoords` coordinates.\n     *\n     * The `cellCoords` coordinates must exceed a corner of your range.\n     *\n     * @param {CellCoords} cellCoords A new cell's coordinates.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"expand\",\n    value: function expand(cellCoords) {\n      var topStart = this.getOuterTopStartCorner();\n      var bottomEnd = this.getOuterBottomEndCorner();\n      if (cellCoords.row < topStart.row || cellCoords.col < topStart.col || cellCoords.row > bottomEnd.row || cellCoords.col > bottomEnd.col) {\n        this.from = this._createCellCoords(Math.min(topStart.row, cellCoords.row), Math.min(topStart.col, cellCoords.col));\n        this.to = this._createCellCoords(Math.max(bottomEnd.row, cellCoords.row), Math.max(bottomEnd.col, cellCoords.col));\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * Expand your range with another range (`expandingRange`).\n     *\n     * @param {CellRange} expandingRange A new range.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"expandByRange\",\n    value: function expandByRange(expandingRange) {\n      if (this.includesRange(expandingRange) || !this.overlaps(expandingRange)) {\n        return false;\n      }\n      var topStart = this.getOuterTopStartCorner();\n      var bottomEnd = this.getOuterBottomEndCorner();\n      var initialDirection = this.getDirection();\n      var expandingTopStart = expandingRange.getOuterTopStartCorner();\n      var expandingBottomEnd = expandingRange.getOuterBottomEndCorner();\n      var resultTopRow = Math.min(topStart.row, expandingTopStart.row);\n      var resultTopCol = Math.min(topStart.col, expandingTopStart.col);\n      var resultBottomRow = Math.max(bottomEnd.row, expandingBottomEnd.row);\n      var resultBottomCol = Math.max(bottomEnd.col, expandingBottomEnd.col);\n      var finalFrom = this._createCellCoords(resultTopRow, resultTopCol);\n      var finalTo = this._createCellCoords(resultBottomRow, resultBottomCol);\n      this.from = finalFrom;\n      this.to = finalTo;\n      this.setDirection(initialDirection);\n      if (this.highlight.row === this.getOuterBottomRightCorner().row && this.getVerticalDirection() === 'N-S') {\n        this.flipDirectionVertically();\n      }\n      if (this.highlight.col === this.getOuterTopRightCorner().col && this.getHorizontalDirection() === 'W-E') {\n        this.flipDirectionHorizontally();\n      }\n      return true;\n    }\n\n    /**\n     * Gets the direction of the selection.\n     *\n     * @returns {string} Returns one of the values: `'NW-SE'`, `'NE-SW'`, `'SE-NW'`, `'SW-NE'`.\n     */\n  }, {\n    key: \"getDirection\",\n    value: function getDirection() {\n      if (this.from.isNorthWestOf(this.to)) {\n        // NorthWest - SouthEast\n        return 'NW-SE';\n      } else if (this.from.isNorthEastOf(this.to)) {\n        // NorthEast - SouthWest\n        return 'NE-SW';\n      } else if (this.from.isSouthEastOf(this.to)) {\n        // SouthEast - NorthWest\n        return 'SE-NW';\n      } else if (this.from.isSouthWestOf(this.to)) {\n        // SouthWest - NorthEast\n        return 'SW-NE';\n      }\n    }\n\n    /**\n     * Sets the direction of the selection.\n     *\n     * @param {string} direction One of the values: `'NW-SE'`, `'NE-SW'`, `'SE-NW'`, `'SW-NE'`.\n     */\n  }, {\n    key: \"setDirection\",\n    value: function setDirection(direction) {\n      switch (direction) {\n        case 'NW-SE':\n          var _ref = [this.getOuterTopLeftCorner(), this.getOuterBottomRightCorner()];\n          this.from = _ref[0];\n          this.to = _ref[1];\n          break;\n        case 'NE-SW':\n          var _ref2 = [this.getOuterTopRightCorner(), this.getOuterBottomLeftCorner()];\n          this.from = _ref2[0];\n          this.to = _ref2[1];\n          break;\n        case 'SE-NW':\n          var _ref3 = [this.getOuterBottomRightCorner(), this.getOuterTopLeftCorner()];\n          this.from = _ref3[0];\n          this.to = _ref3[1];\n          break;\n        case 'SW-NE':\n          var _ref4 = [this.getOuterBottomLeftCorner(), this.getOuterTopRightCorner()];\n          this.from = _ref4[0];\n          this.to = _ref4[1];\n          break;\n        default:\n          break;\n      }\n    }\n\n    /**\n     * Gets the vertical direction of the selection.\n     *\n     * @returns {string} Returns one of the values: `N-S` (north->south), `S-N` (south->north).\n     */\n  }, {\n    key: \"getVerticalDirection\",\n    value: function getVerticalDirection() {\n      return ['NE-SW', 'NW-SE'].indexOf(this.getDirection()) > -1 ? 'N-S' : 'S-N';\n    }\n\n    /**\n     * Gets the horizontal direction of the selection.\n     *\n     * @returns {string} Returns one of the values: `W-E` (west->east), `E-W` (east->west).\n     */\n  }, {\n    key: \"getHorizontalDirection\",\n    value: function getHorizontalDirection() {\n      return ['NW-SE', 'SW-NE'].indexOf(this.getDirection()) > -1 ? 'W-E' : 'E-W';\n    }\n\n    /**\n     * Flips the direction of your range vertically (e.g., `NW-SE` changes to `SW-NE`).\n     */\n  }, {\n    key: \"flipDirectionVertically\",\n    value: function flipDirectionVertically() {\n      var direction = this.getDirection();\n      switch (direction) {\n        case 'NW-SE':\n          this.setDirection('SW-NE');\n          break;\n        case 'NE-SW':\n          this.setDirection('SE-NW');\n          break;\n        case 'SE-NW':\n          this.setDirection('NE-SW');\n          break;\n        case 'SW-NE':\n          this.setDirection('NW-SE');\n          break;\n        default:\n          break;\n      }\n    }\n\n    /**\n     * Flips the direction of your range horizontally (e.g., `NW-SE` changes to `NE-SW`).\n     */\n  }, {\n    key: \"flipDirectionHorizontally\",\n    value: function flipDirectionHorizontally() {\n      var direction = this.getDirection();\n      switch (direction) {\n        case 'NW-SE':\n          this.setDirection('NE-SW');\n          break;\n        case 'NE-SW':\n          this.setDirection('NW-SE');\n          break;\n        case 'SE-NW':\n          this.setDirection('SW-NE');\n          break;\n        case 'SW-NE':\n          this.setDirection('SE-NW');\n          break;\n        default:\n          break;\n      }\n    }\n\n    /**\n     * Gets the top-left (in LTR) or top-right (in RTL) corner coordinates of your range.\n     *\n     * If the corner contains header coordinates (negative values),\n     * the corner coordinates are normalized to `0`.\n     *\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getTopStartCorner\",\n    value: function getTopStartCorner() {\n      return this._createCellCoords(Math.min(this.from.row, this.to.row), Math.min(this.from.col, this.to.col)).normalize();\n    }\n\n    /**\n     * Gets the top-left corner coordinates of your range,\n     * both in the LTR and RTL layout direction.\n     *\n     * If the corner contains header coordinates (negative values),\n     * the corner coordinates are normalized to `0`.\n     *\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getTopLeftCorner\",\n    value: function getTopLeftCorner() {\n      return _classPrivateFieldGet(this, _isRtl) ? this.getTopEndCorner() : this.getTopStartCorner();\n    }\n\n    /**\n     * Gets the bottom right (in LTR) or bottom left (in RTL) corner coordinates of your range.\n     *\n     * If the corner contains header coordinates (negative values),\n     * the corner coordinates are normalized to `0`.\n     *\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getBottomEndCorner\",\n    value: function getBottomEndCorner() {\n      return this._createCellCoords(Math.max(this.from.row, this.to.row), Math.max(this.from.col, this.to.col)).normalize();\n    }\n\n    /**\n     * Gets the bottom right corner coordinates of your range,\n     * both in the LTR and RTL layout direction.\n     *\n     * If the corner contains header coordinates (negative values),\n     * the corner coordinates are normalized to `0`.\n     *\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getBottomRightCorner\",\n    value: function getBottomRightCorner() {\n      return _classPrivateFieldGet(this, _isRtl) ? this.getBottomStartCorner() : this.getBottomEndCorner();\n    }\n\n    /**\n     * Gets the top right (in LTR) or top left (in RTL) corner coordinates of your range.\n     *\n     * If the corner contains header coordinates (negative values),\n     * the corner coordinates are normalized to `0`.\n     *\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getTopEndCorner\",\n    value: function getTopEndCorner() {\n      return this._createCellCoords(Math.min(this.from.row, this.to.row), Math.max(this.from.col, this.to.col)).normalize();\n    }\n\n    /**\n     * Gets the top right corner coordinates of your range,\n     * both in the LTR and RTL layout direction.\n     *\n     * If the corner contains header coordinates (negative values),\n     * the corner coordinates are normalized to `0`.\n     *\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getTopRightCorner\",\n    value: function getTopRightCorner() {\n      return _classPrivateFieldGet(this, _isRtl) ? this.getTopStartCorner() : this.getTopEndCorner();\n    }\n\n    /**\n     * Gets the bottom left (in LTR) or bottom right (in RTL) corner coordinates of your range.\n     *\n     * If the corner contains header coordinates (negative values),\n     * the corner coordinates are normalized to `0`.\n     *\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getBottomStartCorner\",\n    value: function getBottomStartCorner() {\n      return this._createCellCoords(Math.max(this.from.row, this.to.row), Math.min(this.from.col, this.to.col)).normalize();\n    }\n\n    /**\n     * Gets the bottom left corner coordinates of your range,\n     * both in the LTR and RTL layout direction.\n     *\n     * If the corner contains header coordinates (negative values),\n     * the corner coordinates are normalized to `0`.\n     *\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getBottomLeftCorner\",\n    value: function getBottomLeftCorner() {\n      return _classPrivateFieldGet(this, _isRtl) ? this.getBottomEndCorner() : this.getBottomStartCorner();\n    }\n\n    /**\n     * Gets the top left (in LTR) or top right (in RTL) corner coordinates of your range.\n     *\n     * If the corner contains header coordinates (negative values),\n     * the top and start coordinates are pointed to that header.\n     *\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getOuterTopStartCorner\",\n    value: function getOuterTopStartCorner() {\n      return this._createCellCoords(Math.min(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));\n    }\n\n    /**\n     * Gets the top left corner coordinates of your range,\n     * both in the LTR and RTL layout direction.\n     *\n     * If the corner contains header coordinates (negative values),\n     * the top and left coordinates are pointed to that header.\n     *\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getOuterTopLeftCorner\",\n    value: function getOuterTopLeftCorner() {\n      return _classPrivateFieldGet(this, _isRtl) ? this.getOuterTopEndCorner() : this.getOuterTopStartCorner();\n    }\n\n    /**\n     * Gets the bottom right (in LTR) or bottom left (in RTL) corner coordinates of your range.\n     *\n     * If the corner contains header coordinates (negative values),\n     * the top and start coordinates are pointed to that header.\n     *\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getOuterBottomEndCorner\",\n    value: function getOuterBottomEndCorner() {\n      return this._createCellCoords(Math.max(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));\n    }\n\n    /**\n     * Gets the bottom right corner coordinates of your range,\n     * both in the LTR and RTL layout direction.\n     *\n     * If the corner contains header coordinates (negative values),\n     * the top and left coordinates are pointed to that header.\n     *\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getOuterBottomRightCorner\",\n    value: function getOuterBottomRightCorner() {\n      return _classPrivateFieldGet(this, _isRtl) ? this.getOuterBottomStartCorner() : this.getOuterBottomEndCorner();\n    }\n\n    /**\n     * Gets the top right (in LTR) or top left (in RTL) corner coordinates of your range.\n     *\n     * If the corner contains header coordinates (negative values),\n     * the top and start coordinates are pointed to that header.\n     *\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getOuterTopEndCorner\",\n    value: function getOuterTopEndCorner() {\n      return this._createCellCoords(Math.min(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));\n    }\n\n    /**\n     * Gets the top right corner coordinates of your range,\n     * both in the LTR and RTL layout direction.\n     *\n     * If the corner contains header coordinates (negative values),\n     * the top and left coordinates are pointed to that header.\n     *\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getOuterTopRightCorner\",\n    value: function getOuterTopRightCorner() {\n      return _classPrivateFieldGet(this, _isRtl) ? this.getOuterTopStartCorner() : this.getOuterTopEndCorner();\n    }\n\n    /**\n     * Gets the bottom left (in LTR) or bottom right (in RTL) corner coordinates of your range.\n     *\n     * If the corner contains header coordinates (negative values),\n     * the top and start coordinates are pointed to that header.\n     *\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getOuterBottomStartCorner\",\n    value: function getOuterBottomStartCorner() {\n      return this._createCellCoords(Math.max(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));\n    }\n\n    /**\n     * Gets the bottom left corner coordinates of your range,\n     * both in the LTR and RTL layout direction.\n     *\n     * If the corner contains header coordinates (negative values),\n     * the top and left coordinates are pointed to that header.\n     *\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getOuterBottomLeftCorner\",\n    value: function getOuterBottomLeftCorner() {\n      return _classPrivateFieldGet(this, _isRtl) ? this.getOuterBottomEndCorner() : this.getOuterBottomStartCorner();\n    }\n\n    /**\n     * Checks if a set of coordinates (`coords`) matches one of the 4 corners of your range.\n     *\n     * @param {CellCoords} coords Coordinates to check.\n     * @param {CellRange} [expandedRange] A range to compare with.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isCorner\",\n    value: function isCorner(coords, expandedRange) {\n      if (expandedRange && expandedRange.includes(coords) && (this.getOuterTopLeftCorner().isEqual(this._createCellCoords(expandedRange.from.row, expandedRange.from.col)) || this.getOuterTopRightCorner().isEqual(this._createCellCoords(expandedRange.from.row, expandedRange.to.col)) || this.getOuterBottomLeftCorner().isEqual(this._createCellCoords(expandedRange.to.row, expandedRange.from.col)) || this.getOuterBottomRightCorner().isEqual(this._createCellCoords(expandedRange.to.row, expandedRange.to.col)))) {\n        return true;\n      }\n      return coords.isEqual(this.getOuterTopLeftCorner()) || coords.isEqual(this.getOuterTopRightCorner()) || coords.isEqual(this.getOuterBottomLeftCorner()) || coords.isEqual(this.getOuterBottomRightCorner());\n    }\n\n    /**\n     * Gets the coordinates of a range corner opposite to the provided `coords`.\n     *\n     * For example: if the `coords` coordinates match the bottom-right corner of your range,\n     * the coordinates of the top-left corner of your range are returned.\n     *\n     * @param {CellCoords} coords Coordinates to check.\n     * @param {CellRange} [expandedRange] A range to compare with.\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getOppositeCorner\",\n    value: function getOppositeCorner(coords, expandedRange) {\n      if (!(coords instanceof CellCoords)) {\n        return false;\n      }\n      if (expandedRange) {\n        var from = expandedRange.from,\n          to = expandedRange.to;\n        if (expandedRange.includes(coords)) {\n          if (this.getOuterTopStartCorner().isEqual(this._createCellCoords(from.row, from.col))) {\n            return this.getOuterBottomEndCorner();\n          }\n          if (this.getOuterTopEndCorner().isEqual(this._createCellCoords(from.row, to.col))) {\n            return this.getOuterBottomStartCorner();\n          }\n          if (this.getOuterBottomStartCorner().isEqual(this._createCellCoords(to.row, from.col))) {\n            return this.getOuterTopEndCorner();\n          }\n          if (this.getOuterBottomEndCorner().isEqual(this._createCellCoords(to.row, to.col))) {\n            return this.getOuterTopStartCorner();\n          }\n        }\n      }\n      if (coords.isEqual(this.getOuterBottomEndCorner())) {\n        return this.getOuterTopStartCorner();\n      } else if (coords.isEqual(this.getOuterTopStartCorner())) {\n        return this.getOuterBottomEndCorner();\n      } else if (coords.isEqual(this.getOuterTopEndCorner())) {\n        return this.getOuterBottomStartCorner();\n      } else if (coords.isEqual(this.getOuterBottomStartCorner())) {\n        return this.getOuterTopEndCorner();\n      }\n    }\n\n    /**\n     * Indicates which borders (top, right, bottom, left) are shared between\n     * your `CellRange`instance and another `range` that's within your range.\n     *\n     * @param {CellRange} range A range to compare with.\n     * @returns {Array<'top' | 'right' | 'bottom' | 'left'>}\n     */\n  }, {\n    key: \"getBordersSharedWith\",\n    value: function getBordersSharedWith(range) {\n      if (!this.includesRange(range)) {\n        return [];\n      }\n      var thisBorders = {\n        top: Math.min(this.from.row, this.to.row),\n        bottom: Math.max(this.from.row, this.to.row),\n        left: Math.min(this.from.col, this.to.col),\n        right: Math.max(this.from.col, this.to.col)\n      };\n      var rangeBorders = {\n        top: Math.min(range.from.row, range.to.row),\n        bottom: Math.max(range.from.row, range.to.row),\n        left: Math.min(range.from.col, range.to.col),\n        right: Math.max(range.from.col, range.to.col)\n      };\n      var result = [];\n      if (thisBorders.top === rangeBorders.top) {\n        result.push('top');\n      }\n      if (thisBorders.right === rangeBorders.right) {\n        result.push('right');\n      }\n      if (thisBorders.bottom === rangeBorders.bottom) {\n        result.push('bottom');\n      }\n      if (thisBorders.left === rangeBorders.left) {\n        result.push('left');\n      }\n      return result;\n    }\n\n    /**\n     * Gets the coordinates of the inner cells of your range.\n     *\n     * @returns {CellCoords[]}\n     */\n  }, {\n    key: \"getInner\",\n    value: function getInner() {\n      var topStart = this.getOuterTopStartCorner();\n      var bottomEnd = this.getOuterBottomEndCorner();\n      var out = [];\n      for (var r = topStart.row; r <= bottomEnd.row; r++) {\n        for (var c = topStart.col; c <= bottomEnd.col; c++) {\n          if (!(this.from.row === r && this.from.col === c) && !(this.to.row === r && this.to.col === c)) {\n            out.push(this._createCellCoords(r, c));\n          }\n        }\n      }\n      return out;\n    }\n\n    /**\n     * Gets the coordinates of all cells of your range.\n     *\n     * @returns {CellCoords[]}\n     */\n  }, {\n    key: \"getAll\",\n    value: function getAll() {\n      var topStart = this.getOuterTopStartCorner();\n      var bottomEnd = this.getOuterBottomEndCorner();\n      var out = [];\n      for (var r = topStart.row; r <= bottomEnd.row; r++) {\n        for (var c = topStart.col; c <= bottomEnd.col; c++) {\n          if (topStart.row === r && topStart.col === c) {\n            out.push(topStart);\n          } else if (bottomEnd.row === r && bottomEnd.col === c) {\n            out.push(bottomEnd);\n          } else {\n            out.push(this._createCellCoords(r, c));\n          }\n        }\n      }\n      return out;\n    }\n\n    /**\n     * Runs a callback function on all cells within your range.\n     *\n     * You can break the iteration by returning `false` in the callback function.\n     *\n     * @param {function(number, number): boolean} callback A callback function.\n     */\n  }, {\n    key: \"forAll\",\n    value: function forAll(callback) {\n      var topStart = this.getOuterTopStartCorner();\n      var bottomEnd = this.getOuterBottomEndCorner();\n      for (var r = topStart.row; r <= bottomEnd.row; r++) {\n        for (var c = topStart.col; c <= bottomEnd.col; c++) {\n          var breakIteration = callback(r, c);\n          if (breakIteration === false) {\n            return;\n          }\n        }\n      }\n    }\n\n    /**\n     * Clones your `CellRange` instance.\n     *\n     * @returns {CellRange}\n     */\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new CellRange(this.highlight, this.from, this.to, _classPrivateFieldGet(this, _isRtl));\n    }\n\n    /**\n     * Converts your `CellRange` instance into an object literal with the following properties:\n     *\n     * - `from`\n     *    - `row`\n     *    - `col`\n     * - `to`\n     *    - `row`\n     *    - `col`\n     *\n     * @returns {{from: {row: number, col: number}, to: {row: number, col: number}}} An object literal with `from` and `to` properties.\n     */\n  }, {\n    key: \"toObject\",\n    value: function toObject() {\n      return {\n        from: this.from.toObject(),\n        to: this.to.toObject()\n      };\n    }\n\n    /**\n     * Creates and returns a new instance of the `CellCoords` class.\n     *\n     * The new `CellCoords` instance automatically inherits the LTR/RTL flag\n     * from your `CellRange` instance.\n     *\n     * @private\n     * @param {number} row A row index.\n     * @param {number} column A column index.\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"_createCellCoords\",\n    value: function _createCellCoords(row, column) {\n      return new CellCoords(row, column, _classPrivateFieldGet(this, _isRtl));\n    }\n  }]);\n  return CellRange;\n}();\nexport default CellRange;","map":{"version":3,"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","_toPropertyKey","key","_createClass","protoProps","staticProps","_classPrivateFieldInitSpec","privateMap","value","_checkPrivateRedeclaration","set","privateCollection","has","_defineProperty","arg","_toPrimitive","String","input","hint","prim","toPrimitive","undefined","res","call","Number","_classPrivateFieldGet","receiver","_classExtractFieldDescriptor","_classApplyDescriptorGet","get","_classPrivateFieldSet","_classApplyDescriptorSet","action","CellCoords","_isRtl","WeakMap","CellRange","highlight","from","arguments","to","isRtl","clone","normalize","setHighlight","coords","setFrom","setTo","isValid","wot","isSingle","row","col","getOuterHeight","Math","max","min","getOuterWidth","getHeight","fromRow","toRow","getWidth","fromCol","toCol","getCellsCount","includes","cellCoords","topStart","getOuterTopStartCorner","bottomEnd","getOuterBottomEndCorner","includesRange","cellRange","isEqual","overlaps","isSouthEastOf","getOuterTopLeftCorner","isNorthWestOf","getOuterBottomRightCorner","isOverlappingHorizontally","getOuterTopRightCorner","isOverlappingVertically","expand","_createCellCoords","expandByRange","expandingRange","initialDirection","getDirection","expandingTopStart","expandingBottomEnd","resultTopRow","resultTopCol","resultBottomRow","resultBottomCol","finalFrom","finalTo","setDirection","getVerticalDirection","flipDirectionVertically","getHorizontalDirection","flipDirectionHorizontally","isNorthEastOf","isSouthWestOf","direction","_ref","_ref2","getOuterBottomLeftCorner","_ref3","_ref4","indexOf","getTopStartCorner","getTopLeftCorner","getTopEndCorner","getBottomEndCorner","getBottomRightCorner","getBottomStartCorner","getTopRightCorner","getBottomLeftCorner","getOuterTopEndCorner","getOuterBottomStartCorner","isCorner","expandedRange","getOppositeCorner","getBordersSharedWith","range","thisBorders","top","bottom","left","right","rangeBorders","result","push","getInner","out","r","c","getAll","forAll","callback","breakIteration","toObject","column"],"sources":["/home/rstorey/wwwdev/Blucktool/node_modules/handsontable/3rdparty/walkontable/src/cell/range.mjs"],"sourcesContent":["function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.weak-map.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.symbol.to-primitive.js\";\nimport \"core-js/modules/es.date.to-primitive.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); } }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\"); return _classApplyDescriptorGet(receiver, descriptor); }\nfunction _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\nfunction _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to \" + action + \" private field on non-instance\"); } return privateMap.get(receiver); }\nfunction _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } }\nimport CellCoords from \"./../cell/coords.mjs\";\n/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * @description\n *\n * The `CellRange` class holds a set of cell coordinates ([`CellCoords`](@/api/cellCoords.md) instances)\n * that form a [selection range](@/guides/cell-features/selection.md#select-ranges).\n *\n * A single `CellRange` instance represents a single unit of selection\n * that contains either a single cell or multiple adjacent cells.\n *\n * To import the `CellRange` class:\n *\n * ```js\n * import Handsontable, { CellRange } from '/handsontable';\n *\n * // or, using modules\n * import Handsontable, { CellRange } from '/handsontable/base';\n * ```\n */\nvar _isRtl = /*#__PURE__*/new WeakMap();\nvar CellRange = /*#__PURE__*/function () {\n  /**\n   * Used to draw bold border around a cell where selection was started and to edit the cell\n   * when you press Enter. The highlight cannot point to headers (negative values) so its\n   * coordinates object is normalized while assigning.\n   *\n   * @private\n   * @type {CellCoords}\n   */\n\n  /**\n   * Usually the same as highlight, but in Excel there is distinction - one can change\n   * highlight within a selection.\n   *\n   * @private\n   * @type {CellCoords}\n   */\n\n  /**\n   * End selection.\n   *\n   * @private\n   * @type {CellCoords}\n   */\n\n  /**\n   * @type {boolean}\n   */\n\n  function CellRange(highlight) {\n    var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : highlight;\n    var to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : highlight;\n    var isRtl = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    _classCallCheck(this, CellRange);\n    _defineProperty(this, \"highlight\", null);\n    _defineProperty(this, \"from\", null);\n    _defineProperty(this, \"to\", null);\n    _classPrivateFieldInitSpec(this, _isRtl, {\n      writable: true,\n      value: false\n    });\n    this.highlight = highlight.clone().normalize();\n    this.from = from.clone();\n    this.to = to.clone();\n    _classPrivateFieldSet(this, _isRtl, isRtl);\n  }\n\n  /**\n   * Highlights cell selection at the `coords` coordinates.\n   *\n   * @param {CellCoords} coords Coordinates to use.\n   * @returns {CellRange}\n   */\n  _createClass(CellRange, [{\n    key: \"setHighlight\",\n    value: function setHighlight(coords) {\n      this.highlight = coords.clone().normalize();\n      return this;\n    }\n\n    /**\n     * Sets the `coords` coordinates as the start of your range.\n     *\n     * @param {CellCoords} coords Coordinates to use.\n     * @returns {CellRange}\n     */\n  }, {\n    key: \"setFrom\",\n    value: function setFrom(coords) {\n      this.from = coords.clone();\n      return this;\n    }\n\n    /**\n     * Sets the `coords` coordinates as the end of your range.\n     *\n     * @param {CellCoords} coords Coordinates to use.\n     * @returns {CellRange}\n     */\n  }, {\n    key: \"setTo\",\n    value: function setTo(coords) {\n      this.to = coords.clone();\n      return this;\n    }\n\n    /**\n     * Checks if the coordinates in your `CellRange` instance are valid\n     * in the context of a given Walkontable instance.\n     *\n     * See the [`isValid()`](@/api/cellCoords.md#isvalid) method of the [`CellCoords`](@/api/cellCoords.md) class.\n     *\n     * @param {Walkontable} wot A Walkontable instance.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isValid\",\n    value: function isValid(wot) {\n      return this.from.isValid(wot) && this.to.isValid(wot);\n    }\n\n    /**\n     * Checks if your range is just a single cell.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isSingle\",\n    value: function isSingle() {\n      return this.from.row >= 0 && this.from.row === this.to.row && this.from.col >= 0 && this.from.col === this.to.col;\n    }\n\n    /**\n     * Returns the height of your range (as a number of rows, including row headers).\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getOuterHeight\",\n    value: function getOuterHeight() {\n      return Math.max(this.from.row, this.to.row) - Math.min(this.from.row, this.to.row) + 1;\n    }\n\n    /**\n     * Returns the width of your range (as a number of columns, including column headers).\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getOuterWidth\",\n    value: function getOuterWidth() {\n      return Math.max(this.from.col, this.to.col) - Math.min(this.from.col, this.to.col) + 1;\n    }\n\n    /**\n     * Returns the height of your range (as a number of rows, excluding row headers).\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getHeight\",\n    value: function getHeight() {\n      // if the selection contains only row headers, return 0\n      if (this.from.row < 0 && this.to.row < 0) {\n        return 0;\n      }\n      var fromRow = Math.max(this.from.row, 0);\n      var toRow = Math.max(this.to.row, 0);\n      return Math.max(fromRow, toRow) - Math.min(fromRow, toRow) + 1;\n    }\n\n    /**\n     * Returns the width of your range (as a number of columns, excluding column headers).\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getWidth\",\n    value: function getWidth() {\n      // if the selection contains only column headers, return 0\n      if (this.from.col < 0 && this.to.col < 0) {\n        return 0;\n      }\n      var fromCol = Math.max(this.from.col, 0);\n      var toCol = Math.max(this.to.col, 0);\n      return Math.max(fromCol, toCol) - Math.min(fromCol, toCol) + 1;\n    }\n\n    /**\n     * Returns the number of cells within your range (excluding column and row headers).\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getCellsCount\",\n    value: function getCellsCount() {\n      return this.getWidth() * this.getHeight();\n    }\n\n    /**\n     * Checks if another set of coordinates (`cellCoords`)\n     * is within the `from` and `to` coordinates of your range.\n     *\n     * @param {CellCoords} cellCoords Coordinates to check.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"includes\",\n    value: function includes(cellCoords) {\n      var row = cellCoords.row,\n        col = cellCoords.col;\n      var topStart = this.getOuterTopStartCorner();\n      var bottomEnd = this.getOuterBottomEndCorner();\n      return topStart.row <= row && bottomEnd.row >= row && topStart.col <= col && bottomEnd.col >= col;\n    }\n\n    /**\n     * Checks if another range (`cellRange`) is within your range.\n     *\n     * @param {CellRange} cellRange A range to check.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"includesRange\",\n    value: function includesRange(cellRange) {\n      return this.includes(cellRange.getOuterTopStartCorner()) && this.includes(cellRange.getOuterBottomEndCorner());\n    }\n\n    /**\n     * Checks if another range (`cellRange`) is equal to your range.\n     *\n     * @param {CellRange} cellRange A range to check.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(cellRange) {\n      return Math.min(this.from.row, this.to.row) === Math.min(cellRange.from.row, cellRange.to.row) && Math.max(this.from.row, this.to.row) === Math.max(cellRange.from.row, cellRange.to.row) && Math.min(this.from.col, this.to.col) === Math.min(cellRange.from.col, cellRange.to.col) && Math.max(this.from.col, this.to.col) === Math.max(cellRange.from.col, cellRange.to.col);\n    }\n\n    /**\n     * Checks if another range (`cellRange`) overlaps your range.\n     *\n     * Range A overlaps range B if the intersection of A and B (or B and A) is not empty.\n     *\n     * @param {CellRange} cellRange A range to check.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"overlaps\",\n    value: function overlaps(cellRange) {\n      return cellRange.isSouthEastOf(this.getOuterTopLeftCorner()) && cellRange.isNorthWestOf(this.getOuterBottomRightCorner());\n    }\n\n    /**\n     * Checks if another range (`cellRange`) is south-east of your range.\n     *\n     * @param {CellRange} cellRange A range to check.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isSouthEastOf\",\n    value: function isSouthEastOf(cellRange) {\n      return this.getOuterTopLeftCorner().isSouthEastOf(cellRange) || this.getOuterBottomRightCorner().isSouthEastOf(cellRange);\n    }\n\n    /**\n     * Checks if another range (`cellRange`) is north-west of your range.\n     *\n     * @param {CellRange} cellRange A range to check.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isNorthWestOf\",\n    value: function isNorthWestOf(cellRange) {\n      return this.getOuterTopLeftCorner().isNorthWestOf(cellRange) || this.getOuterBottomRightCorner().isNorthWestOf(cellRange);\n    }\n\n    /**\n     * Checks if another range (`cellRange`) overlaps your range horizontally.\n     *\n     * For example: returns `true` if the last column of your range is `5`\n     * and the first column of the `cellRange` range is `3`.\n     *\n     * @param {CellRange} cellRange A range to check.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isOverlappingHorizontally\",\n    value: function isOverlappingHorizontally(cellRange) {\n      return this.getOuterTopRightCorner().col >= cellRange.getOuterTopLeftCorner().col && this.getOuterTopRightCorner().col <= cellRange.getOuterTopRightCorner().col || this.getOuterTopLeftCorner().col <= cellRange.getOuterTopRightCorner().col && this.getOuterTopLeftCorner().col >= cellRange.getOuterTopLeftCorner().col;\n    }\n\n    /**\n     * Checks if another range (`cellRange`) overlaps your range vertically.\n     *\n     * For example: returns `true` if the last row of your range is `5`\n     * and the first row of the `cellRange` range is `3`.\n     *\n     * @param {CellRange} cellRange A range to check.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isOverlappingVertically\",\n    value: function isOverlappingVertically(cellRange) {\n      return this.getOuterBottomRightCorner().row >= cellRange.getOuterTopRightCorner().row && this.getOuterBottomRightCorner().row <= cellRange.getOuterBottomRightCorner().row || this.getOuterTopRightCorner().row <= cellRange.getOuterBottomRightCorner().row && this.getOuterTopRightCorner().row >= cellRange.getOuterTopRightCorner().row;\n    }\n\n    /**\n     * Adds a cell to your range, at `cellCoords` coordinates.\n     *\n     * The `cellCoords` coordinates must exceed a corner of your range.\n     *\n     * @param {CellCoords} cellCoords A new cell's coordinates.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"expand\",\n    value: function expand(cellCoords) {\n      var topStart = this.getOuterTopStartCorner();\n      var bottomEnd = this.getOuterBottomEndCorner();\n      if (cellCoords.row < topStart.row || cellCoords.col < topStart.col || cellCoords.row > bottomEnd.row || cellCoords.col > bottomEnd.col) {\n        this.from = this._createCellCoords(Math.min(topStart.row, cellCoords.row), Math.min(topStart.col, cellCoords.col));\n        this.to = this._createCellCoords(Math.max(bottomEnd.row, cellCoords.row), Math.max(bottomEnd.col, cellCoords.col));\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * Expand your range with another range (`expandingRange`).\n     *\n     * @param {CellRange} expandingRange A new range.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"expandByRange\",\n    value: function expandByRange(expandingRange) {\n      if (this.includesRange(expandingRange) || !this.overlaps(expandingRange)) {\n        return false;\n      }\n      var topStart = this.getOuterTopStartCorner();\n      var bottomEnd = this.getOuterBottomEndCorner();\n      var initialDirection = this.getDirection();\n      var expandingTopStart = expandingRange.getOuterTopStartCorner();\n      var expandingBottomEnd = expandingRange.getOuterBottomEndCorner();\n      var resultTopRow = Math.min(topStart.row, expandingTopStart.row);\n      var resultTopCol = Math.min(topStart.col, expandingTopStart.col);\n      var resultBottomRow = Math.max(bottomEnd.row, expandingBottomEnd.row);\n      var resultBottomCol = Math.max(bottomEnd.col, expandingBottomEnd.col);\n      var finalFrom = this._createCellCoords(resultTopRow, resultTopCol);\n      var finalTo = this._createCellCoords(resultBottomRow, resultBottomCol);\n      this.from = finalFrom;\n      this.to = finalTo;\n      this.setDirection(initialDirection);\n      if (this.highlight.row === this.getOuterBottomRightCorner().row && this.getVerticalDirection() === 'N-S') {\n        this.flipDirectionVertically();\n      }\n      if (this.highlight.col === this.getOuterTopRightCorner().col && this.getHorizontalDirection() === 'W-E') {\n        this.flipDirectionHorizontally();\n      }\n      return true;\n    }\n\n    /**\n     * Gets the direction of the selection.\n     *\n     * @returns {string} Returns one of the values: `'NW-SE'`, `'NE-SW'`, `'SE-NW'`, `'SW-NE'`.\n     */\n  }, {\n    key: \"getDirection\",\n    value: function getDirection() {\n      if (this.from.isNorthWestOf(this.to)) {\n        // NorthWest - SouthEast\n        return 'NW-SE';\n      } else if (this.from.isNorthEastOf(this.to)) {\n        // NorthEast - SouthWest\n        return 'NE-SW';\n      } else if (this.from.isSouthEastOf(this.to)) {\n        // SouthEast - NorthWest\n        return 'SE-NW';\n      } else if (this.from.isSouthWestOf(this.to)) {\n        // SouthWest - NorthEast\n        return 'SW-NE';\n      }\n    }\n\n    /**\n     * Sets the direction of the selection.\n     *\n     * @param {string} direction One of the values: `'NW-SE'`, `'NE-SW'`, `'SE-NW'`, `'SW-NE'`.\n     */\n  }, {\n    key: \"setDirection\",\n    value: function setDirection(direction) {\n      switch (direction) {\n        case 'NW-SE':\n          var _ref = [this.getOuterTopLeftCorner(), this.getOuterBottomRightCorner()];\n          this.from = _ref[0];\n          this.to = _ref[1];\n          break;\n        case 'NE-SW':\n          var _ref2 = [this.getOuterTopRightCorner(), this.getOuterBottomLeftCorner()];\n          this.from = _ref2[0];\n          this.to = _ref2[1];\n          break;\n        case 'SE-NW':\n          var _ref3 = [this.getOuterBottomRightCorner(), this.getOuterTopLeftCorner()];\n          this.from = _ref3[0];\n          this.to = _ref3[1];\n          break;\n        case 'SW-NE':\n          var _ref4 = [this.getOuterBottomLeftCorner(), this.getOuterTopRightCorner()];\n          this.from = _ref4[0];\n          this.to = _ref4[1];\n          break;\n        default:\n          break;\n      }\n    }\n\n    /**\n     * Gets the vertical direction of the selection.\n     *\n     * @returns {string} Returns one of the values: `N-S` (north->south), `S-N` (south->north).\n     */\n  }, {\n    key: \"getVerticalDirection\",\n    value: function getVerticalDirection() {\n      return ['NE-SW', 'NW-SE'].indexOf(this.getDirection()) > -1 ? 'N-S' : 'S-N';\n    }\n\n    /**\n     * Gets the horizontal direction of the selection.\n     *\n     * @returns {string} Returns one of the values: `W-E` (west->east), `E-W` (east->west).\n     */\n  }, {\n    key: \"getHorizontalDirection\",\n    value: function getHorizontalDirection() {\n      return ['NW-SE', 'SW-NE'].indexOf(this.getDirection()) > -1 ? 'W-E' : 'E-W';\n    }\n\n    /**\n     * Flips the direction of your range vertically (e.g., `NW-SE` changes to `SW-NE`).\n     */\n  }, {\n    key: \"flipDirectionVertically\",\n    value: function flipDirectionVertically() {\n      var direction = this.getDirection();\n      switch (direction) {\n        case 'NW-SE':\n          this.setDirection('SW-NE');\n          break;\n        case 'NE-SW':\n          this.setDirection('SE-NW');\n          break;\n        case 'SE-NW':\n          this.setDirection('NE-SW');\n          break;\n        case 'SW-NE':\n          this.setDirection('NW-SE');\n          break;\n        default:\n          break;\n      }\n    }\n\n    /**\n     * Flips the direction of your range horizontally (e.g., `NW-SE` changes to `NE-SW`).\n     */\n  }, {\n    key: \"flipDirectionHorizontally\",\n    value: function flipDirectionHorizontally() {\n      var direction = this.getDirection();\n      switch (direction) {\n        case 'NW-SE':\n          this.setDirection('NE-SW');\n          break;\n        case 'NE-SW':\n          this.setDirection('NW-SE');\n          break;\n        case 'SE-NW':\n          this.setDirection('SW-NE');\n          break;\n        case 'SW-NE':\n          this.setDirection('SE-NW');\n          break;\n        default:\n          break;\n      }\n    }\n\n    /**\n     * Gets the top-left (in LTR) or top-right (in RTL) corner coordinates of your range.\n     *\n     * If the corner contains header coordinates (negative values),\n     * the corner coordinates are normalized to `0`.\n     *\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getTopStartCorner\",\n    value: function getTopStartCorner() {\n      return this._createCellCoords(Math.min(this.from.row, this.to.row), Math.min(this.from.col, this.to.col)).normalize();\n    }\n\n    /**\n     * Gets the top-left corner coordinates of your range,\n     * both in the LTR and RTL layout direction.\n     *\n     * If the corner contains header coordinates (negative values),\n     * the corner coordinates are normalized to `0`.\n     *\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getTopLeftCorner\",\n    value: function getTopLeftCorner() {\n      return _classPrivateFieldGet(this, _isRtl) ? this.getTopEndCorner() : this.getTopStartCorner();\n    }\n\n    /**\n     * Gets the bottom right (in LTR) or bottom left (in RTL) corner coordinates of your range.\n     *\n     * If the corner contains header coordinates (negative values),\n     * the corner coordinates are normalized to `0`.\n     *\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getBottomEndCorner\",\n    value: function getBottomEndCorner() {\n      return this._createCellCoords(Math.max(this.from.row, this.to.row), Math.max(this.from.col, this.to.col)).normalize();\n    }\n\n    /**\n     * Gets the bottom right corner coordinates of your range,\n     * both in the LTR and RTL layout direction.\n     *\n     * If the corner contains header coordinates (negative values),\n     * the corner coordinates are normalized to `0`.\n     *\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getBottomRightCorner\",\n    value: function getBottomRightCorner() {\n      return _classPrivateFieldGet(this, _isRtl) ? this.getBottomStartCorner() : this.getBottomEndCorner();\n    }\n\n    /**\n     * Gets the top right (in LTR) or top left (in RTL) corner coordinates of your range.\n     *\n     * If the corner contains header coordinates (negative values),\n     * the corner coordinates are normalized to `0`.\n     *\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getTopEndCorner\",\n    value: function getTopEndCorner() {\n      return this._createCellCoords(Math.min(this.from.row, this.to.row), Math.max(this.from.col, this.to.col)).normalize();\n    }\n\n    /**\n     * Gets the top right corner coordinates of your range,\n     * both in the LTR and RTL layout direction.\n     *\n     * If the corner contains header coordinates (negative values),\n     * the corner coordinates are normalized to `0`.\n     *\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getTopRightCorner\",\n    value: function getTopRightCorner() {\n      return _classPrivateFieldGet(this, _isRtl) ? this.getTopStartCorner() : this.getTopEndCorner();\n    }\n\n    /**\n     * Gets the bottom left (in LTR) or bottom right (in RTL) corner coordinates of your range.\n     *\n     * If the corner contains header coordinates (negative values),\n     * the corner coordinates are normalized to `0`.\n     *\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getBottomStartCorner\",\n    value: function getBottomStartCorner() {\n      return this._createCellCoords(Math.max(this.from.row, this.to.row), Math.min(this.from.col, this.to.col)).normalize();\n    }\n\n    /**\n     * Gets the bottom left corner coordinates of your range,\n     * both in the LTR and RTL layout direction.\n     *\n     * If the corner contains header coordinates (negative values),\n     * the corner coordinates are normalized to `0`.\n     *\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getBottomLeftCorner\",\n    value: function getBottomLeftCorner() {\n      return _classPrivateFieldGet(this, _isRtl) ? this.getBottomEndCorner() : this.getBottomStartCorner();\n    }\n\n    /**\n     * Gets the top left (in LTR) or top right (in RTL) corner coordinates of your range.\n     *\n     * If the corner contains header coordinates (negative values),\n     * the top and start coordinates are pointed to that header.\n     *\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getOuterTopStartCorner\",\n    value: function getOuterTopStartCorner() {\n      return this._createCellCoords(Math.min(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));\n    }\n\n    /**\n     * Gets the top left corner coordinates of your range,\n     * both in the LTR and RTL layout direction.\n     *\n     * If the corner contains header coordinates (negative values),\n     * the top and left coordinates are pointed to that header.\n     *\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getOuterTopLeftCorner\",\n    value: function getOuterTopLeftCorner() {\n      return _classPrivateFieldGet(this, _isRtl) ? this.getOuterTopEndCorner() : this.getOuterTopStartCorner();\n    }\n\n    /**\n     * Gets the bottom right (in LTR) or bottom left (in RTL) corner coordinates of your range.\n     *\n     * If the corner contains header coordinates (negative values),\n     * the top and start coordinates are pointed to that header.\n     *\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getOuterBottomEndCorner\",\n    value: function getOuterBottomEndCorner() {\n      return this._createCellCoords(Math.max(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));\n    }\n\n    /**\n     * Gets the bottom right corner coordinates of your range,\n     * both in the LTR and RTL layout direction.\n     *\n     * If the corner contains header coordinates (negative values),\n     * the top and left coordinates are pointed to that header.\n     *\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getOuterBottomRightCorner\",\n    value: function getOuterBottomRightCorner() {\n      return _classPrivateFieldGet(this, _isRtl) ? this.getOuterBottomStartCorner() : this.getOuterBottomEndCorner();\n    }\n\n    /**\n     * Gets the top right (in LTR) or top left (in RTL) corner coordinates of your range.\n     *\n     * If the corner contains header coordinates (negative values),\n     * the top and start coordinates are pointed to that header.\n     *\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getOuterTopEndCorner\",\n    value: function getOuterTopEndCorner() {\n      return this._createCellCoords(Math.min(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));\n    }\n\n    /**\n     * Gets the top right corner coordinates of your range,\n     * both in the LTR and RTL layout direction.\n     *\n     * If the corner contains header coordinates (negative values),\n     * the top and left coordinates are pointed to that header.\n     *\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getOuterTopRightCorner\",\n    value: function getOuterTopRightCorner() {\n      return _classPrivateFieldGet(this, _isRtl) ? this.getOuterTopStartCorner() : this.getOuterTopEndCorner();\n    }\n\n    /**\n     * Gets the bottom left (in LTR) or bottom right (in RTL) corner coordinates of your range.\n     *\n     * If the corner contains header coordinates (negative values),\n     * the top and start coordinates are pointed to that header.\n     *\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getOuterBottomStartCorner\",\n    value: function getOuterBottomStartCorner() {\n      return this._createCellCoords(Math.max(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));\n    }\n\n    /**\n     * Gets the bottom left corner coordinates of your range,\n     * both in the LTR and RTL layout direction.\n     *\n     * If the corner contains header coordinates (negative values),\n     * the top and left coordinates are pointed to that header.\n     *\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getOuterBottomLeftCorner\",\n    value: function getOuterBottomLeftCorner() {\n      return _classPrivateFieldGet(this, _isRtl) ? this.getOuterBottomEndCorner() : this.getOuterBottomStartCorner();\n    }\n\n    /**\n     * Checks if a set of coordinates (`coords`) matches one of the 4 corners of your range.\n     *\n     * @param {CellCoords} coords Coordinates to check.\n     * @param {CellRange} [expandedRange] A range to compare with.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isCorner\",\n    value: function isCorner(coords, expandedRange) {\n      if (expandedRange && expandedRange.includes(coords) && (this.getOuterTopLeftCorner().isEqual(this._createCellCoords(expandedRange.from.row, expandedRange.from.col)) || this.getOuterTopRightCorner().isEqual(this._createCellCoords(expandedRange.from.row, expandedRange.to.col)) || this.getOuterBottomLeftCorner().isEqual(this._createCellCoords(expandedRange.to.row, expandedRange.from.col)) || this.getOuterBottomRightCorner().isEqual(this._createCellCoords(expandedRange.to.row, expandedRange.to.col)))) {\n        return true;\n      }\n      return coords.isEqual(this.getOuterTopLeftCorner()) || coords.isEqual(this.getOuterTopRightCorner()) || coords.isEqual(this.getOuterBottomLeftCorner()) || coords.isEqual(this.getOuterBottomRightCorner());\n    }\n\n    /**\n     * Gets the coordinates of a range corner opposite to the provided `coords`.\n     *\n     * For example: if the `coords` coordinates match the bottom-right corner of your range,\n     * the coordinates of the top-left corner of your range are returned.\n     *\n     * @param {CellCoords} coords Coordinates to check.\n     * @param {CellRange} [expandedRange] A range to compare with.\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getOppositeCorner\",\n    value: function getOppositeCorner(coords, expandedRange) {\n      if (!(coords instanceof CellCoords)) {\n        return false;\n      }\n      if (expandedRange) {\n        var from = expandedRange.from,\n          to = expandedRange.to;\n        if (expandedRange.includes(coords)) {\n          if (this.getOuterTopStartCorner().isEqual(this._createCellCoords(from.row, from.col))) {\n            return this.getOuterBottomEndCorner();\n          }\n          if (this.getOuterTopEndCorner().isEqual(this._createCellCoords(from.row, to.col))) {\n            return this.getOuterBottomStartCorner();\n          }\n          if (this.getOuterBottomStartCorner().isEqual(this._createCellCoords(to.row, from.col))) {\n            return this.getOuterTopEndCorner();\n          }\n          if (this.getOuterBottomEndCorner().isEqual(this._createCellCoords(to.row, to.col))) {\n            return this.getOuterTopStartCorner();\n          }\n        }\n      }\n      if (coords.isEqual(this.getOuterBottomEndCorner())) {\n        return this.getOuterTopStartCorner();\n      } else if (coords.isEqual(this.getOuterTopStartCorner())) {\n        return this.getOuterBottomEndCorner();\n      } else if (coords.isEqual(this.getOuterTopEndCorner())) {\n        return this.getOuterBottomStartCorner();\n      } else if (coords.isEqual(this.getOuterBottomStartCorner())) {\n        return this.getOuterTopEndCorner();\n      }\n    }\n\n    /**\n     * Indicates which borders (top, right, bottom, left) are shared between\n     * your `CellRange`instance and another `range` that's within your range.\n     *\n     * @param {CellRange} range A range to compare with.\n     * @returns {Array<'top' | 'right' | 'bottom' | 'left'>}\n     */\n  }, {\n    key: \"getBordersSharedWith\",\n    value: function getBordersSharedWith(range) {\n      if (!this.includesRange(range)) {\n        return [];\n      }\n      var thisBorders = {\n        top: Math.min(this.from.row, this.to.row),\n        bottom: Math.max(this.from.row, this.to.row),\n        left: Math.min(this.from.col, this.to.col),\n        right: Math.max(this.from.col, this.to.col)\n      };\n      var rangeBorders = {\n        top: Math.min(range.from.row, range.to.row),\n        bottom: Math.max(range.from.row, range.to.row),\n        left: Math.min(range.from.col, range.to.col),\n        right: Math.max(range.from.col, range.to.col)\n      };\n      var result = [];\n      if (thisBorders.top === rangeBorders.top) {\n        result.push('top');\n      }\n      if (thisBorders.right === rangeBorders.right) {\n        result.push('right');\n      }\n      if (thisBorders.bottom === rangeBorders.bottom) {\n        result.push('bottom');\n      }\n      if (thisBorders.left === rangeBorders.left) {\n        result.push('left');\n      }\n      return result;\n    }\n\n    /**\n     * Gets the coordinates of the inner cells of your range.\n     *\n     * @returns {CellCoords[]}\n     */\n  }, {\n    key: \"getInner\",\n    value: function getInner() {\n      var topStart = this.getOuterTopStartCorner();\n      var bottomEnd = this.getOuterBottomEndCorner();\n      var out = [];\n      for (var r = topStart.row; r <= bottomEnd.row; r++) {\n        for (var c = topStart.col; c <= bottomEnd.col; c++) {\n          if (!(this.from.row === r && this.from.col === c) && !(this.to.row === r && this.to.col === c)) {\n            out.push(this._createCellCoords(r, c));\n          }\n        }\n      }\n      return out;\n    }\n\n    /**\n     * Gets the coordinates of all cells of your range.\n     *\n     * @returns {CellCoords[]}\n     */\n  }, {\n    key: \"getAll\",\n    value: function getAll() {\n      var topStart = this.getOuterTopStartCorner();\n      var bottomEnd = this.getOuterBottomEndCorner();\n      var out = [];\n      for (var r = topStart.row; r <= bottomEnd.row; r++) {\n        for (var c = topStart.col; c <= bottomEnd.col; c++) {\n          if (topStart.row === r && topStart.col === c) {\n            out.push(topStart);\n          } else if (bottomEnd.row === r && bottomEnd.col === c) {\n            out.push(bottomEnd);\n          } else {\n            out.push(this._createCellCoords(r, c));\n          }\n        }\n      }\n      return out;\n    }\n\n    /**\n     * Runs a callback function on all cells within your range.\n     *\n     * You can break the iteration by returning `false` in the callback function.\n     *\n     * @param {function(number, number): boolean} callback A callback function.\n     */\n  }, {\n    key: \"forAll\",\n    value: function forAll(callback) {\n      var topStart = this.getOuterTopStartCorner();\n      var bottomEnd = this.getOuterBottomEndCorner();\n      for (var r = topStart.row; r <= bottomEnd.row; r++) {\n        for (var c = topStart.col; c <= bottomEnd.col; c++) {\n          var breakIteration = callback(r, c);\n          if (breakIteration === false) {\n            return;\n          }\n        }\n      }\n    }\n\n    /**\n     * Clones your `CellRange` instance.\n     *\n     * @returns {CellRange}\n     */\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new CellRange(this.highlight, this.from, this.to, _classPrivateFieldGet(this, _isRtl));\n    }\n\n    /**\n     * Converts your `CellRange` instance into an object literal with the following properties:\n     *\n     * - `from`\n     *    - `row`\n     *    - `col`\n     * - `to`\n     *    - `row`\n     *    - `col`\n     *\n     * @returns {{from: {row: number, col: number}, to: {row: number, col: number}}} An object literal with `from` and `to` properties.\n     */\n  }, {\n    key: \"toObject\",\n    value: function toObject() {\n      return {\n        from: this.from.toObject(),\n        to: this.to.toObject()\n      };\n    }\n\n    /**\n     * Creates and returns a new instance of the `CellCoords` class.\n     *\n     * The new `CellCoords` instance automatically inherits the LTR/RTL flag\n     * from your `CellRange` instance.\n     *\n     * @private\n     * @param {number} row A row index.\n     * @param {number} column A column index.\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"_createCellCoords\",\n    value: function _createCellCoords(row, column) {\n      return new CellCoords(row, column, _classPrivateFieldGet(this, _isRtl));\n    }\n  }]);\n  return CellRange;\n}();\nexport default CellRange;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}