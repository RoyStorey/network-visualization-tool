{"ast":null,"code":"import { isObject } from \"../../helpers/object.mjs\";\nimport { isDefined } from \"../../helpers/mixed.mjs\";\nexport var DIRECTIONS = {\n  horizontal: 'horizontal',\n  vertical: 'vertical'\n};\n\n/**\n * Get deltas array.\n *\n * @param {CellCoords} start The point in the grid where the selection starts.\n * @param {CellCoords} end The point in the grid where the selection ends.\n * @param {Array} data The chunk of the data which belongs to the selected box.\n * @param {string} direction The selection direction.\n * @returns {Array}\n */\nexport function getDeltas(start, end, data, direction) {\n  var rowsLength = data.length;\n  var columnsLength = data ? data[0].length : 0;\n  var deltas = [];\n  var diffRow = end.row - start.row;\n  var diffCol = end.col - start.col;\n  if (['down', 'up'].indexOf(direction) !== -1) {\n    var arr = [];\n    for (var col = 0; col < diffCol; col++) {\n      var startValue = parseInt(data[0][col], 10);\n      var endValue = parseInt(data[rowsLength - 1][col], 10);\n      var delta = (direction === 'down' ? endValue - startValue : startValue - endValue) / (rowsLength - 1) || 0;\n      arr.push(delta);\n    }\n    deltas.push(arr);\n  }\n  if (['right', 'left'].indexOf(direction) !== -1) {\n    for (var row = 0; row < diffRow; row++) {\n      var _startValue = parseInt(data[row][0], 10);\n      var _endValue = parseInt(data[row][columnsLength - 1], 10);\n      var _delta = (direction === 'right' ? _endValue - _startValue : _startValue - _endValue) / (columnsLength - 1) || 0;\n      deltas.push([_delta]);\n    }\n  }\n  return deltas;\n}\n\n/**\n * Get direction between positions and cords of selections difference (drag area).\n *\n * @param {Array} startSelection The coordinates where the selection starts.\n * @param {Array} endSelection The coordinates where the selection ends.\n * @param {Function} cellCoordsFactory The function factory for CellCoords objects.\n * @returns {{direction: string, start: CellCoords, end: CellCoords}}\n */\nexport function getDragDirectionAndRange(startSelection, endSelection, cellCoordsFactory) {\n  var startOfDragCoords;\n  var endOfDragCoords;\n  var directionOfDrag;\n  if (endSelection[0] === startSelection[0] && endSelection[1] < startSelection[1]) {\n    directionOfDrag = 'left';\n    startOfDragCoords = cellCoordsFactory(endSelection[0], endSelection[1]);\n    endOfDragCoords = cellCoordsFactory(endSelection[2], startSelection[1] - 1);\n  } else if (endSelection[2] === startSelection[2] && endSelection[0] === startSelection[0] && endSelection[3] > startSelection[3]) {\n    directionOfDrag = 'right';\n    startOfDragCoords = cellCoordsFactory(endSelection[0], startSelection[3] + 1);\n    endOfDragCoords = cellCoordsFactory(endSelection[2], endSelection[3]);\n  } else if (endSelection[0] < startSelection[0] && endSelection[1] === startSelection[1]) {\n    directionOfDrag = 'up';\n    startOfDragCoords = cellCoordsFactory(endSelection[0], endSelection[1]);\n    endOfDragCoords = cellCoordsFactory(startSelection[0] - 1, endSelection[3]);\n  } else if (endSelection[2] > startSelection[2] && endSelection[1] === startSelection[1]) {\n    directionOfDrag = 'down';\n    startOfDragCoords = cellCoordsFactory(startSelection[2] + 1, endSelection[1]);\n    endOfDragCoords = cellCoordsFactory(endSelection[2], endSelection[3]);\n  }\n  if (startOfDragCoords) {\n    startOfDragCoords.normalize();\n  }\n  if (endOfDragCoords) {\n    endOfDragCoords.normalize();\n  }\n  return {\n    directionOfDrag: directionOfDrag,\n    startOfDragCoords: startOfDragCoords,\n    endOfDragCoords: endOfDragCoords\n  };\n}\n\n/**\n * Get mapped FillHandle setting containing information about\n * allowed FillHandle directions and if allowed is automatic insertion of rows on drag.\n *\n * @param {boolean|object} fillHandle Property of Handsontable settings.\n * @returns {{directions: Array, autoInsertRow: boolean}} Object allowing access to information\n * about FillHandle in more useful way.\n */\nexport function getMappedFillHandleSetting(fillHandle) {\n  var mappedSettings = {};\n  if (fillHandle === true) {\n    mappedSettings.directions = Object.keys(DIRECTIONS);\n    mappedSettings.autoInsertRow = true;\n  } else if (isObject(fillHandle)) {\n    if (isDefined(fillHandle.autoInsertRow)) {\n      // autoInsertRow for horizontal direction will be always false\n\n      if (fillHandle.direction === DIRECTIONS.horizontal) {\n        mappedSettings.autoInsertRow = false;\n      } else {\n        mappedSettings.autoInsertRow = fillHandle.autoInsertRow;\n      }\n    } else {\n      mappedSettings.autoInsertRow = false;\n    }\n    if (isDefined(fillHandle.direction)) {\n      mappedSettings.directions = [fillHandle.direction];\n    } else {\n      mappedSettings.directions = Object.keys(DIRECTIONS);\n    }\n  } else if (typeof fillHandle === 'string') {\n    mappedSettings.directions = [fillHandle];\n    mappedSettings.autoInsertRow = true;\n  } else {\n    mappedSettings.directions = [];\n    mappedSettings.autoInsertRow = false;\n  }\n  return mappedSettings;\n}","map":{"version":3,"names":["isObject","isDefined","DIRECTIONS","horizontal","vertical","getDeltas","start","end","data","direction","rowsLength","length","columnsLength","deltas","diffRow","row","diffCol","col","indexOf","arr","startValue","parseInt","endValue","delta","push","_startValue","_endValue","_delta","getDragDirectionAndRange","startSelection","endSelection","cellCoordsFactory","startOfDragCoords","endOfDragCoords","directionOfDrag","normalize","getMappedFillHandleSetting","fillHandle","mappedSettings","directions","Object","keys","autoInsertRow"],"sources":["/home/rstorey/wwwdev/Blucktool/node_modules/handsontable/plugins/autofill/utils.mjs"],"sourcesContent":["import \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport { isObject } from \"../../helpers/object.mjs\";\nimport { isDefined } from \"../../helpers/mixed.mjs\";\nexport var DIRECTIONS = {\n  horizontal: 'horizontal',\n  vertical: 'vertical'\n};\n\n/**\n * Get deltas array.\n *\n * @param {CellCoords} start The point in the grid where the selection starts.\n * @param {CellCoords} end The point in the grid where the selection ends.\n * @param {Array} data The chunk of the data which belongs to the selected box.\n * @param {string} direction The selection direction.\n * @returns {Array}\n */\nexport function getDeltas(start, end, data, direction) {\n  var rowsLength = data.length;\n  var columnsLength = data ? data[0].length : 0;\n  var deltas = [];\n  var diffRow = end.row - start.row;\n  var diffCol = end.col - start.col;\n  if (['down', 'up'].indexOf(direction) !== -1) {\n    var arr = [];\n    for (var col = 0; col < diffCol; col++) {\n      var startValue = parseInt(data[0][col], 10);\n      var endValue = parseInt(data[rowsLength - 1][col], 10);\n      var delta = (direction === 'down' ? endValue - startValue : startValue - endValue) / (rowsLength - 1) || 0;\n      arr.push(delta);\n    }\n    deltas.push(arr);\n  }\n  if (['right', 'left'].indexOf(direction) !== -1) {\n    for (var row = 0; row < diffRow; row++) {\n      var _startValue = parseInt(data[row][0], 10);\n      var _endValue = parseInt(data[row][columnsLength - 1], 10);\n      var _delta = (direction === 'right' ? _endValue - _startValue : _startValue - _endValue) / (columnsLength - 1) || 0;\n      deltas.push([_delta]);\n    }\n  }\n  return deltas;\n}\n\n/**\n * Get direction between positions and cords of selections difference (drag area).\n *\n * @param {Array} startSelection The coordinates where the selection starts.\n * @param {Array} endSelection The coordinates where the selection ends.\n * @param {Function} cellCoordsFactory The function factory for CellCoords objects.\n * @returns {{direction: string, start: CellCoords, end: CellCoords}}\n */\nexport function getDragDirectionAndRange(startSelection, endSelection, cellCoordsFactory) {\n  var startOfDragCoords;\n  var endOfDragCoords;\n  var directionOfDrag;\n  if (endSelection[0] === startSelection[0] && endSelection[1] < startSelection[1]) {\n    directionOfDrag = 'left';\n    startOfDragCoords = cellCoordsFactory(endSelection[0], endSelection[1]);\n    endOfDragCoords = cellCoordsFactory(endSelection[2], startSelection[1] - 1);\n  } else if (endSelection[2] === startSelection[2] && endSelection[0] === startSelection[0] && endSelection[3] > startSelection[3]) {\n    directionOfDrag = 'right';\n    startOfDragCoords = cellCoordsFactory(endSelection[0], startSelection[3] + 1);\n    endOfDragCoords = cellCoordsFactory(endSelection[2], endSelection[3]);\n  } else if (endSelection[0] < startSelection[0] && endSelection[1] === startSelection[1]) {\n    directionOfDrag = 'up';\n    startOfDragCoords = cellCoordsFactory(endSelection[0], endSelection[1]);\n    endOfDragCoords = cellCoordsFactory(startSelection[0] - 1, endSelection[3]);\n  } else if (endSelection[2] > startSelection[2] && endSelection[1] === startSelection[1]) {\n    directionOfDrag = 'down';\n    startOfDragCoords = cellCoordsFactory(startSelection[2] + 1, endSelection[1]);\n    endOfDragCoords = cellCoordsFactory(endSelection[2], endSelection[3]);\n  }\n  if (startOfDragCoords) {\n    startOfDragCoords.normalize();\n  }\n  if (endOfDragCoords) {\n    endOfDragCoords.normalize();\n  }\n  return {\n    directionOfDrag: directionOfDrag,\n    startOfDragCoords: startOfDragCoords,\n    endOfDragCoords: endOfDragCoords\n  };\n}\n\n/**\n * Get mapped FillHandle setting containing information about\n * allowed FillHandle directions and if allowed is automatic insertion of rows on drag.\n *\n * @param {boolean|object} fillHandle Property of Handsontable settings.\n * @returns {{directions: Array, autoInsertRow: boolean}} Object allowing access to information\n * about FillHandle in more useful way.\n */\nexport function getMappedFillHandleSetting(fillHandle) {\n  var mappedSettings = {};\n  if (fillHandle === true) {\n    mappedSettings.directions = Object.keys(DIRECTIONS);\n    mappedSettings.autoInsertRow = true;\n  } else if (isObject(fillHandle)) {\n    if (isDefined(fillHandle.autoInsertRow)) {\n      // autoInsertRow for horizontal direction will be always false\n\n      if (fillHandle.direction === DIRECTIONS.horizontal) {\n        mappedSettings.autoInsertRow = false;\n      } else {\n        mappedSettings.autoInsertRow = fillHandle.autoInsertRow;\n      }\n    } else {\n      mappedSettings.autoInsertRow = false;\n    }\n    if (isDefined(fillHandle.direction)) {\n      mappedSettings.directions = [fillHandle.direction];\n    } else {\n      mappedSettings.directions = Object.keys(DIRECTIONS);\n    }\n  } else if (typeof fillHandle === 'string') {\n    mappedSettings.directions = [fillHandle];\n    mappedSettings.autoInsertRow = true;\n  } else {\n    mappedSettings.directions = [];\n    mappedSettings.autoInsertRow = false;\n  }\n  return mappedSettings;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}