{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nvar _templateObject;\nfunction _taggedTemplateLiteral(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nimport MergedCellCoords from \"./cellCoords.mjs\";\nimport { rangeEach, rangeEachReverse } from \"../../helpers/number.mjs\";\nimport { warn } from \"../../helpers/console.mjs\";\nimport { arrayEach } from \"../../helpers/array.mjs\";\nimport { applySpanProperties } from \"./utils.mjs\";\nimport { toSingleLine } from \"../../helpers/templateLiteralTag.mjs\";\n/**\n * Defines a container object for the merged cells.\n *\n * @private\n * @class MergedCellsCollection\n */\nvar MergedCellsCollection = /*#__PURE__*/function () {\n  function MergedCellsCollection(plugin) {\n    _classCallCheck(this, MergedCellsCollection);\n    /**\n     * Reference to the Merge Cells plugin.\n     *\n     * @type {MergeCells}\n     */\n    this.plugin = plugin;\n    /**\n     * Array of merged cells.\n     *\n     * @type {Array}\n     */\n    this.mergedCells = [];\n    /**\n     * The Handsontable instance.\n     *\n     * @type {Handsontable}\n     */\n    this.hot = plugin.hot;\n  }\n\n  /**\n   * Get a warning message for when the declared merged cell data overlaps already existing merged cells.\n   *\n   * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.\n   * @returns {string}\n   */\n  _createClass(MergedCellsCollection, [{\n    key: \"get\",\n    value:\n    /**\n     * Get a merged cell from the container, based on the provided arguments. You can provide either the \"starting coordinates\"\n     * of a merged cell, or any coordinates from the body of the merged cell.\n     *\n     * @param {number} row Row index.\n     * @param {number} column Column index.\n     * @returns {MergedCellCoords|boolean} Returns a wanted merged cell on success and `false` on failure.\n     */\n    function get(row, column) {\n      var mergedCells = this.mergedCells;\n      var result = false;\n      arrayEach(mergedCells, function (mergedCell) {\n        if (mergedCell.row <= row && mergedCell.row + mergedCell.rowspan - 1 >= row && mergedCell.col <= column && mergedCell.col + mergedCell.colspan - 1 >= column) {\n          result = mergedCell;\n          return false;\n        }\n        return true;\n      });\n      return result;\n    }\n\n    /**\n     * Get a merged cell containing the provided range.\n     *\n     * @param {CellRange|object} range The range to search merged cells for.\n     * @returns {MergedCellCoords|boolean}\n     */\n  }, {\n    key: \"getByRange\",\n    value: function getByRange(range) {\n      var mergedCells = this.mergedCells;\n      var result = false;\n      arrayEach(mergedCells, function (mergedCell) {\n        if (mergedCell.row <= range.from.row && mergedCell.row + mergedCell.rowspan - 1 >= range.to.row && mergedCell.col <= range.from.col && mergedCell.col + mergedCell.colspan - 1 >= range.to.col) {\n          result = mergedCell;\n          return result;\n        }\n        return true;\n      });\n      return result;\n    }\n\n    /**\n     * Get a merged cell contained in the provided range.\n     *\n     * @param {CellRange|object} range The range to search merged cells in.\n     * @param {boolean} [countPartials=false] If set to `true`, all the merged cells overlapping the range will be taken into calculation.\n     * @returns {Array|boolean} Array of found merged cells of `false` if none were found.\n     */\n  }, {\n    key: \"getWithinRange\",\n    value: function getWithinRange(range) {\n      var _this = this;\n      var countPartials = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var mergedCells = this.mergedCells;\n      var foundMergedCells = [];\n      var testedRange = range;\n      if (!testedRange.includesRange) {\n        var from = this.hot._createCellCoords(testedRange.from.row, testedRange.from.col);\n        var to = this.hot._createCellCoords(testedRange.to.row, testedRange.to.col);\n        testedRange = this.hot._createCellRange(from, from, to);\n      }\n      arrayEach(mergedCells, function (mergedCell) {\n        var mergedCellTopLeft = _this.hot._createCellCoords(mergedCell.row, mergedCell.col);\n        var mergedCellBottomRight = _this.hot._createCellCoords(mergedCell.row + mergedCell.rowspan - 1, mergedCell.col + mergedCell.colspan - 1);\n        var mergedCellRange = _this.hot._createCellRange(mergedCellTopLeft, mergedCellTopLeft, mergedCellBottomRight);\n        if (countPartials) {\n          if (testedRange.overlaps(mergedCellRange)) {\n            foundMergedCells.push(mergedCell);\n          }\n        } else if (testedRange.includesRange(mergedCellRange)) {\n          foundMergedCells.push(mergedCell);\n        }\n      });\n      return foundMergedCells.length ? foundMergedCells : false;\n    }\n\n    /**\n     * Add a merged cell to the container.\n     *\n     * @param {object} mergedCellInfo The merged cell information object. Has to contain `row`, `col`, `colspan` and `rowspan` properties.\n     * @returns {MergedCellCoords|boolean} Returns the new merged cell on success and `false` on failure.\n     */\n  }, {\n    key: \"add\",\n    value: function add(mergedCellInfo) {\n      var mergedCells = this.mergedCells;\n      var row = mergedCellInfo.row;\n      var column = mergedCellInfo.col;\n      var rowspan = mergedCellInfo.rowspan;\n      var colspan = mergedCellInfo.colspan;\n      var newMergedCell = new MergedCellCoords(row, column, rowspan, colspan, this.hot._createCellCoords, this.hot._createCellRange);\n      var alreadyExists = this.get(row, column);\n      var isOverlapping = this.isOverlapping(newMergedCell);\n      if (!alreadyExists && !isOverlapping) {\n        if (this.hot) {\n          newMergedCell.normalize(this.hot);\n        }\n        mergedCells.push(newMergedCell);\n        return newMergedCell;\n      }\n      warn(MergedCellsCollection.IS_OVERLAPPING_WARNING(newMergedCell));\n      return false;\n    }\n\n    /**\n     * Remove a merged cell from the container. You can provide either the \"starting coordinates\"\n     * of a merged cell, or any coordinates from the body of the merged cell.\n     *\n     * @param {number} row Row index.\n     * @param {number} column Column index.\n     * @returns {MergedCellCoords|boolean} Returns the removed merged cell on success and `false` on failure.\n     */\n  }, {\n    key: \"remove\",\n    value: function remove(row, column) {\n      var mergedCells = this.mergedCells;\n      var wantedCollection = this.get(row, column);\n      var wantedCollectionIndex = wantedCollection ? this.mergedCells.indexOf(wantedCollection) : -1;\n      if (wantedCollection && wantedCollectionIndex !== -1) {\n        mergedCells.splice(wantedCollectionIndex, 1);\n        return wantedCollection;\n      }\n      return false;\n    }\n\n    /**\n     * Clear all the merged cells.\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var _this2 = this;\n      var mergedCells = this.mergedCells;\n      var mergedCellParentsToClear = [];\n      var hiddenCollectionElements = [];\n      arrayEach(mergedCells, function (mergedCell) {\n        var TD = _this2.hot.getCell(mergedCell.row, mergedCell.col);\n        if (TD) {\n          mergedCellParentsToClear.push([TD, _this2.get(mergedCell.row, mergedCell.col), mergedCell.row, mergedCell.col]);\n        }\n      });\n      this.mergedCells.length = 0;\n      arrayEach(mergedCellParentsToClear, function (mergedCell, i) {\n        rangeEach(0, mergedCell.rowspan - 1, function (j) {\n          rangeEach(0, mergedCell.colspan - 1, function (k) {\n            if (k !== 0 || j !== 0) {\n              var TD = _this2.hot.getCell(mergedCell.row + j, mergedCell.col + k);\n              if (TD) {\n                hiddenCollectionElements.push([TD, null, null, null]);\n              }\n            }\n          });\n        });\n        mergedCellParentsToClear[i][1] = null;\n      });\n      arrayEach(mergedCellParentsToClear, function (mergedCellParents) {\n        applySpanProperties.apply(void 0, _toConsumableArray(mergedCellParents));\n      });\n      arrayEach(hiddenCollectionElements, function (hiddenCollectionElement) {\n        applySpanProperties.apply(void 0, _toConsumableArray(hiddenCollectionElement));\n      });\n    }\n\n    /**\n     * Check if the provided merged cell overlaps with the others in the container.\n     *\n     * @param {MergedCellCoords} mergedCell The merged cell to check against all others in the container.\n     * @returns {boolean} `true` if the provided merged cell overlaps with the others, `false` otherwise.\n     */\n  }, {\n    key: \"isOverlapping\",\n    value: function isOverlapping(mergedCell) {\n      var _this3 = this;\n      var mergedCellRange = this.hot._createCellRange(this.hot._createCellCoords(0, 0), this.hot._createCellCoords(mergedCell.row, mergedCell.col), this.hot._createCellCoords(mergedCell.row + mergedCell.rowspan - 1, mergedCell.col + mergedCell.colspan - 1));\n      var result = false;\n      arrayEach(this.mergedCells, function (col) {\n        var currentRange = _this3.hot._createCellRange(_this3.hot._createCellCoords(0, 0), _this3.hot._createCellCoords(col.row, col.col), _this3.hot._createCellCoords(col.row + col.rowspan - 1, col.col + col.colspan - 1));\n        if (currentRange.overlaps(mergedCellRange)) {\n          result = true;\n          return false;\n        }\n        return true;\n      });\n      return result;\n    }\n\n    /**\n     * Check whether the provided row/col coordinates direct to a first not hidden cell within merge area.\n     *\n     * @param {number} row Visual row index.\n     * @param {number} column Visual column index.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isFirstRenderableMergedCell\",\n    value: function isFirstRenderableMergedCell(row, column) {\n      var mergeParent = this.get(row, column);\n\n      // Return if row and column indexes are within merge area and if they are first rendered indexes within the area.\n      return mergeParent && this.hot.rowIndexMapper.getNearestNotHiddenIndex(mergeParent.row, 1) === row && this.hot.columnIndexMapper.getNearestNotHiddenIndex(mergeParent.col, 1) === column;\n    }\n\n    /**\n     * Get the first renderable coords of the merged cell at the provided coordinates.\n     *\n     * @param {number} row Visual row index.\n     * @param {number} column Visual column index.\n     * @returns {CellCoords} A `CellCoords` object with the coordinates to the first renderable cell within the\n     *                        merged cell.\n     */\n  }, {\n    key: \"getFirstRenderableCoords\",\n    value: function getFirstRenderableCoords(row, column) {\n      var mergeParent = this.get(row, column);\n      if (!mergeParent || this.isFirstRenderableMergedCell(row, column)) {\n        return this.hot._createCellCoords(row, column);\n      }\n      var firstRenderableRow = this.hot.rowIndexMapper.getNearestNotHiddenIndex(mergeParent.row, 1);\n      var firstRenderableColumn = this.hot.columnIndexMapper.getNearestNotHiddenIndex(mergeParent.col, 1);\n      return this.hot._createCellCoords(firstRenderableRow, firstRenderableColumn);\n    }\n\n    /**\n     * Shift the merged cell in the direction and by an offset defined in the arguments.\n     *\n     * @param {string} direction `right`, `left`, `up` or `down`.\n     * @param {number} index Index where the change, which caused the shifting took place.\n     * @param {number} count Number of rows/columns added/removed in the preceding action.\n     */\n  }, {\n    key: \"shiftCollections\",\n    value: function shiftCollections(direction, index, count) {\n      var _this4 = this;\n      var shiftVector = [0, 0];\n      switch (direction) {\n        case 'right':\n          shiftVector[0] += count;\n          break;\n        case 'left':\n          shiftVector[0] -= count;\n          break;\n        case 'down':\n          shiftVector[1] += count;\n          break;\n        case 'up':\n          shiftVector[1] -= count;\n          break;\n        default:\n      }\n      arrayEach(this.mergedCells, function (currentMerge) {\n        currentMerge.shift(shiftVector, index);\n      });\n      rangeEachReverse(this.mergedCells.length - 1, 0, function (i) {\n        var currentMerge = _this4.mergedCells[i];\n        if (currentMerge && currentMerge.removed) {\n          _this4.mergedCells.splice(_this4.mergedCells.indexOf(currentMerge), 1);\n        }\n      });\n    }\n  }], [{\n    key: \"IS_OVERLAPPING_WARNING\",\n    value: function IS_OVERLAPPING_WARNING(newMergedCell) {\n      return toSingleLine(_templateObject || (_templateObject = _taggedTemplateLiteral([\"The merged cell declared at [\", \", \", \"], overlaps \\n      with the other declared merged cell. The overlapping merged cell was not added to the table, please \\n      fix your setup.\"], [\"The merged cell declared at [\", \", \", \"], overlaps\\\\x20\\n      with the other declared merged cell. The overlapping merged cell was not added to the table, please\\\\x20\\n      fix your setup.\"])), newMergedCell.row, newMergedCell.col);\n    }\n  }]);\n  return MergedCellsCollection;\n}();\nexport default MergedCellsCollection;","map":{"version":3,"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_templateObject","_taggedTemplateLiteral","strings","raw","slice","Object","freeze","defineProperties","value","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","o","minLen","_arrayLikeToArray","n","toString","call","name","Array","from","test","iter","isArray","len","length","i","arr2","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","_toPropertyKey","key","_createClass","protoProps","staticProps","arg","_toPrimitive","String","input","hint","prim","toPrimitive","undefined","res","Number","MergedCellCoords","rangeEach","rangeEachReverse","warn","arrayEach","applySpanProperties","toSingleLine","MergedCellsCollection","plugin","mergedCells","hot","get","row","column","result","mergedCell","rowspan","col","colspan","getByRange","range","to","getWithinRange","_this","countPartials","arguments","foundMergedCells","testedRange","includesRange","_createCellCoords","_createCellRange","mergedCellTopLeft","mergedCellBottomRight","mergedCellRange","overlaps","push","add","mergedCellInfo","newMergedCell","alreadyExists","isOverlapping","normalize","IS_OVERLAPPING_WARNING","remove","wantedCollection","wantedCollectionIndex","indexOf","splice","clear","_this2","mergedCellParentsToClear","hiddenCollectionElements","TD","getCell","j","k","mergedCellParents","apply","hiddenCollectionElement","_this3","currentRange","isFirstRenderableMergedCell","mergeParent","rowIndexMapper","getNearestNotHiddenIndex","columnIndexMapper","getFirstRenderableCoords","firstRenderableRow","firstRenderableColumn","shiftCollections","direction","index","count","_this4","shiftVector","currentMerge","shift","removed"],"sources":["/home/rstorey/wwwdev/Blucktool/node_modules/handsontable/plugins/mergeCells/cellsCollection.mjs"],"sourcesContent":["function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nvar _templateObject;\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.symbol.to-primitive.js\";\nimport \"core-js/modules/es.date.to-primitive.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.object.freeze.js\";\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport MergedCellCoords from \"./cellCoords.mjs\";\nimport { rangeEach, rangeEachReverse } from \"../../helpers/number.mjs\";\nimport { warn } from \"../../helpers/console.mjs\";\nimport { arrayEach } from \"../../helpers/array.mjs\";\nimport { applySpanProperties } from \"./utils.mjs\";\nimport { toSingleLine } from \"../../helpers/templateLiteralTag.mjs\";\n/**\n * Defines a container object for the merged cells.\n *\n * @private\n * @class MergedCellsCollection\n */\nvar MergedCellsCollection = /*#__PURE__*/function () {\n  function MergedCellsCollection(plugin) {\n    _classCallCheck(this, MergedCellsCollection);\n    /**\n     * Reference to the Merge Cells plugin.\n     *\n     * @type {MergeCells}\n     */\n    this.plugin = plugin;\n    /**\n     * Array of merged cells.\n     *\n     * @type {Array}\n     */\n    this.mergedCells = [];\n    /**\n     * The Handsontable instance.\n     *\n     * @type {Handsontable}\n     */\n    this.hot = plugin.hot;\n  }\n\n  /**\n   * Get a warning message for when the declared merged cell data overlaps already existing merged cells.\n   *\n   * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.\n   * @returns {string}\n   */\n  _createClass(MergedCellsCollection, [{\n    key: \"get\",\n    value:\n    /**\n     * Get a merged cell from the container, based on the provided arguments. You can provide either the \"starting coordinates\"\n     * of a merged cell, or any coordinates from the body of the merged cell.\n     *\n     * @param {number} row Row index.\n     * @param {number} column Column index.\n     * @returns {MergedCellCoords|boolean} Returns a wanted merged cell on success and `false` on failure.\n     */\n    function get(row, column) {\n      var mergedCells = this.mergedCells;\n      var result = false;\n      arrayEach(mergedCells, function (mergedCell) {\n        if (mergedCell.row <= row && mergedCell.row + mergedCell.rowspan - 1 >= row && mergedCell.col <= column && mergedCell.col + mergedCell.colspan - 1 >= column) {\n          result = mergedCell;\n          return false;\n        }\n        return true;\n      });\n      return result;\n    }\n\n    /**\n     * Get a merged cell containing the provided range.\n     *\n     * @param {CellRange|object} range The range to search merged cells for.\n     * @returns {MergedCellCoords|boolean}\n     */\n  }, {\n    key: \"getByRange\",\n    value: function getByRange(range) {\n      var mergedCells = this.mergedCells;\n      var result = false;\n      arrayEach(mergedCells, function (mergedCell) {\n        if (mergedCell.row <= range.from.row && mergedCell.row + mergedCell.rowspan - 1 >= range.to.row && mergedCell.col <= range.from.col && mergedCell.col + mergedCell.colspan - 1 >= range.to.col) {\n          result = mergedCell;\n          return result;\n        }\n        return true;\n      });\n      return result;\n    }\n\n    /**\n     * Get a merged cell contained in the provided range.\n     *\n     * @param {CellRange|object} range The range to search merged cells in.\n     * @param {boolean} [countPartials=false] If set to `true`, all the merged cells overlapping the range will be taken into calculation.\n     * @returns {Array|boolean} Array of found merged cells of `false` if none were found.\n     */\n  }, {\n    key: \"getWithinRange\",\n    value: function getWithinRange(range) {\n      var _this = this;\n      var countPartials = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var mergedCells = this.mergedCells;\n      var foundMergedCells = [];\n      var testedRange = range;\n      if (!testedRange.includesRange) {\n        var from = this.hot._createCellCoords(testedRange.from.row, testedRange.from.col);\n        var to = this.hot._createCellCoords(testedRange.to.row, testedRange.to.col);\n        testedRange = this.hot._createCellRange(from, from, to);\n      }\n      arrayEach(mergedCells, function (mergedCell) {\n        var mergedCellTopLeft = _this.hot._createCellCoords(mergedCell.row, mergedCell.col);\n        var mergedCellBottomRight = _this.hot._createCellCoords(mergedCell.row + mergedCell.rowspan - 1, mergedCell.col + mergedCell.colspan - 1);\n        var mergedCellRange = _this.hot._createCellRange(mergedCellTopLeft, mergedCellTopLeft, mergedCellBottomRight);\n        if (countPartials) {\n          if (testedRange.overlaps(mergedCellRange)) {\n            foundMergedCells.push(mergedCell);\n          }\n        } else if (testedRange.includesRange(mergedCellRange)) {\n          foundMergedCells.push(mergedCell);\n        }\n      });\n      return foundMergedCells.length ? foundMergedCells : false;\n    }\n\n    /**\n     * Add a merged cell to the container.\n     *\n     * @param {object} mergedCellInfo The merged cell information object. Has to contain `row`, `col`, `colspan` and `rowspan` properties.\n     * @returns {MergedCellCoords|boolean} Returns the new merged cell on success and `false` on failure.\n     */\n  }, {\n    key: \"add\",\n    value: function add(mergedCellInfo) {\n      var mergedCells = this.mergedCells;\n      var row = mergedCellInfo.row;\n      var column = mergedCellInfo.col;\n      var rowspan = mergedCellInfo.rowspan;\n      var colspan = mergedCellInfo.colspan;\n      var newMergedCell = new MergedCellCoords(row, column, rowspan, colspan, this.hot._createCellCoords, this.hot._createCellRange);\n      var alreadyExists = this.get(row, column);\n      var isOverlapping = this.isOverlapping(newMergedCell);\n      if (!alreadyExists && !isOverlapping) {\n        if (this.hot) {\n          newMergedCell.normalize(this.hot);\n        }\n        mergedCells.push(newMergedCell);\n        return newMergedCell;\n      }\n      warn(MergedCellsCollection.IS_OVERLAPPING_WARNING(newMergedCell));\n      return false;\n    }\n\n    /**\n     * Remove a merged cell from the container. You can provide either the \"starting coordinates\"\n     * of a merged cell, or any coordinates from the body of the merged cell.\n     *\n     * @param {number} row Row index.\n     * @param {number} column Column index.\n     * @returns {MergedCellCoords|boolean} Returns the removed merged cell on success and `false` on failure.\n     */\n  }, {\n    key: \"remove\",\n    value: function remove(row, column) {\n      var mergedCells = this.mergedCells;\n      var wantedCollection = this.get(row, column);\n      var wantedCollectionIndex = wantedCollection ? this.mergedCells.indexOf(wantedCollection) : -1;\n      if (wantedCollection && wantedCollectionIndex !== -1) {\n        mergedCells.splice(wantedCollectionIndex, 1);\n        return wantedCollection;\n      }\n      return false;\n    }\n\n    /**\n     * Clear all the merged cells.\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var _this2 = this;\n      var mergedCells = this.mergedCells;\n      var mergedCellParentsToClear = [];\n      var hiddenCollectionElements = [];\n      arrayEach(mergedCells, function (mergedCell) {\n        var TD = _this2.hot.getCell(mergedCell.row, mergedCell.col);\n        if (TD) {\n          mergedCellParentsToClear.push([TD, _this2.get(mergedCell.row, mergedCell.col), mergedCell.row, mergedCell.col]);\n        }\n      });\n      this.mergedCells.length = 0;\n      arrayEach(mergedCellParentsToClear, function (mergedCell, i) {\n        rangeEach(0, mergedCell.rowspan - 1, function (j) {\n          rangeEach(0, mergedCell.colspan - 1, function (k) {\n            if (k !== 0 || j !== 0) {\n              var TD = _this2.hot.getCell(mergedCell.row + j, mergedCell.col + k);\n              if (TD) {\n                hiddenCollectionElements.push([TD, null, null, null]);\n              }\n            }\n          });\n        });\n        mergedCellParentsToClear[i][1] = null;\n      });\n      arrayEach(mergedCellParentsToClear, function (mergedCellParents) {\n        applySpanProperties.apply(void 0, _toConsumableArray(mergedCellParents));\n      });\n      arrayEach(hiddenCollectionElements, function (hiddenCollectionElement) {\n        applySpanProperties.apply(void 0, _toConsumableArray(hiddenCollectionElement));\n      });\n    }\n\n    /**\n     * Check if the provided merged cell overlaps with the others in the container.\n     *\n     * @param {MergedCellCoords} mergedCell The merged cell to check against all others in the container.\n     * @returns {boolean} `true` if the provided merged cell overlaps with the others, `false` otherwise.\n     */\n  }, {\n    key: \"isOverlapping\",\n    value: function isOverlapping(mergedCell) {\n      var _this3 = this;\n      var mergedCellRange = this.hot._createCellRange(this.hot._createCellCoords(0, 0), this.hot._createCellCoords(mergedCell.row, mergedCell.col), this.hot._createCellCoords(mergedCell.row + mergedCell.rowspan - 1, mergedCell.col + mergedCell.colspan - 1));\n      var result = false;\n      arrayEach(this.mergedCells, function (col) {\n        var currentRange = _this3.hot._createCellRange(_this3.hot._createCellCoords(0, 0), _this3.hot._createCellCoords(col.row, col.col), _this3.hot._createCellCoords(col.row + col.rowspan - 1, col.col + col.colspan - 1));\n        if (currentRange.overlaps(mergedCellRange)) {\n          result = true;\n          return false;\n        }\n        return true;\n      });\n      return result;\n    }\n\n    /**\n     * Check whether the provided row/col coordinates direct to a first not hidden cell within merge area.\n     *\n     * @param {number} row Visual row index.\n     * @param {number} column Visual column index.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isFirstRenderableMergedCell\",\n    value: function isFirstRenderableMergedCell(row, column) {\n      var mergeParent = this.get(row, column);\n\n      // Return if row and column indexes are within merge area and if they are first rendered indexes within the area.\n      return mergeParent && this.hot.rowIndexMapper.getNearestNotHiddenIndex(mergeParent.row, 1) === row && this.hot.columnIndexMapper.getNearestNotHiddenIndex(mergeParent.col, 1) === column;\n    }\n\n    /**\n     * Get the first renderable coords of the merged cell at the provided coordinates.\n     *\n     * @param {number} row Visual row index.\n     * @param {number} column Visual column index.\n     * @returns {CellCoords} A `CellCoords` object with the coordinates to the first renderable cell within the\n     *                        merged cell.\n     */\n  }, {\n    key: \"getFirstRenderableCoords\",\n    value: function getFirstRenderableCoords(row, column) {\n      var mergeParent = this.get(row, column);\n      if (!mergeParent || this.isFirstRenderableMergedCell(row, column)) {\n        return this.hot._createCellCoords(row, column);\n      }\n      var firstRenderableRow = this.hot.rowIndexMapper.getNearestNotHiddenIndex(mergeParent.row, 1);\n      var firstRenderableColumn = this.hot.columnIndexMapper.getNearestNotHiddenIndex(mergeParent.col, 1);\n      return this.hot._createCellCoords(firstRenderableRow, firstRenderableColumn);\n    }\n\n    /**\n     * Shift the merged cell in the direction and by an offset defined in the arguments.\n     *\n     * @param {string} direction `right`, `left`, `up` or `down`.\n     * @param {number} index Index where the change, which caused the shifting took place.\n     * @param {number} count Number of rows/columns added/removed in the preceding action.\n     */\n  }, {\n    key: \"shiftCollections\",\n    value: function shiftCollections(direction, index, count) {\n      var _this4 = this;\n      var shiftVector = [0, 0];\n      switch (direction) {\n        case 'right':\n          shiftVector[0] += count;\n          break;\n        case 'left':\n          shiftVector[0] -= count;\n          break;\n        case 'down':\n          shiftVector[1] += count;\n          break;\n        case 'up':\n          shiftVector[1] -= count;\n          break;\n        default:\n      }\n      arrayEach(this.mergedCells, function (currentMerge) {\n        currentMerge.shift(shiftVector, index);\n      });\n      rangeEachReverse(this.mergedCells.length - 1, 0, function (i) {\n        var currentMerge = _this4.mergedCells[i];\n        if (currentMerge && currentMerge.removed) {\n          _this4.mergedCells.splice(_this4.mergedCells.indexOf(currentMerge), 1);\n        }\n      });\n    }\n  }], [{\n    key: \"IS_OVERLAPPING_WARNING\",\n    value: function IS_OVERLAPPING_WARNING(newMergedCell) {\n      return toSingleLine(_templateObject || (_templateObject = _taggedTemplateLiteral([\"The merged cell declared at [\", \", \", \"], overlaps \\n      with the other declared merged cell. The overlapping merged cell was not added to the table, please \\n      fix your setup.\"], [\"The merged cell declared at [\", \", \", \"], overlaps\\\\x20\\n      with the other declared merged cell. The overlapping merged cell was not added to the table, please\\\\x20\\n      fix your setup.\"])), newMergedCell.row, newMergedCell.col);\n    }\n  }]);\n  return MergedCellsCollection;\n}();\nexport default MergedCellsCollection;"],"mappings":"AAAA,SAASA,OAAOA,CAACC,GAAG,EAAE;EAAE,yBAAyB;;EAAE,OAAOD,OAAO,GAAG,UAAU,IAAI,OAAOE,MAAM,IAAI,QAAQ,IAAI,OAAOA,MAAM,CAACC,QAAQ,GAAG,UAAUF,GAAG,EAAE;IAAE,OAAO,OAAOA,GAAG;EAAE,CAAC,GAAG,UAAUA,GAAG,EAAE;IAAE,OAAOA,GAAG,IAAI,UAAU,IAAI,OAAOC,MAAM,IAAID,GAAG,CAACG,WAAW,KAAKF,MAAM,IAAID,GAAG,KAAKC,MAAM,CAACG,SAAS,GAAG,QAAQ,GAAG,OAAOJ,GAAG;EAAE,CAAC,EAAED,OAAO,CAACC,GAAG,CAAC;AAAE;AAC/U,IAAIK,eAAe;AACnB,SAASC,sBAAsBA,CAACC,OAAO,EAAEC,GAAG,EAAE;EAAE,IAAI,CAACA,GAAG,EAAE;IAAEA,GAAG,GAAGD,OAAO,CAACE,KAAK,CAAC,CAAC,CAAC;EAAE;EAAE,OAAOC,MAAM,CAACC,MAAM,CAACD,MAAM,CAACE,gBAAgB,CAACL,OAAO,EAAE;IAAEC,GAAG,EAAE;MAAEK,KAAK,EAAEH,MAAM,CAACC,MAAM,CAACH,GAAG;IAAE;EAAE,CAAC,CAAC,CAAC;AAAE;AACtL,SAASM,kBAAkBA,CAACC,GAAG,EAAE;EAAE,OAAOC,kBAAkB,CAACD,GAAG,CAAC,IAAIE,gBAAgB,CAACF,GAAG,CAAC,IAAIG,2BAA2B,CAACH,GAAG,CAAC,IAAII,kBAAkB,EAAE;AAAE;AACxJ,SAASA,kBAAkBA,CAAA,EAAG;EAAE,MAAM,IAAIC,SAAS,CAAC,sIAAsI,CAAC;AAAE;AAC7L,SAASF,2BAA2BA,CAACG,CAAC,EAAEC,MAAM,EAAE;EAAE,IAAI,CAACD,CAAC,EAAE;EAAQ,IAAI,OAAOA,CAAC,KAAK,QAAQ,EAAE,OAAOE,iBAAiB,CAACF,CAAC,EAAEC,MAAM,CAAC;EAAE,IAAIE,CAAC,GAAGd,MAAM,CAACN,SAAS,CAACqB,QAAQ,CAACC,IAAI,CAACL,CAAC,CAAC,CAACZ,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;EAAE,IAAIe,CAAC,KAAK,QAAQ,IAAIH,CAAC,CAAClB,WAAW,EAAEqB,CAAC,GAAGH,CAAC,CAAClB,WAAW,CAACwB,IAAI;EAAE,IAAIH,CAAC,KAAK,KAAK,IAAIA,CAAC,KAAK,KAAK,EAAE,OAAOI,KAAK,CAACC,IAAI,CAACR,CAAC,CAAC;EAAE,IAAIG,CAAC,KAAK,WAAW,IAAI,0CAA0C,CAACM,IAAI,CAACN,CAAC,CAAC,EAAE,OAAOD,iBAAiB,CAACF,CAAC,EAAEC,MAAM,CAAC;AAAE;AAC/Z,SAASL,gBAAgBA,CAACc,IAAI,EAAE;EAAE,IAAI,OAAO9B,MAAM,KAAK,WAAW,IAAI8B,IAAI,CAAC9B,MAAM,CAACC,QAAQ,CAAC,IAAI,IAAI,IAAI6B,IAAI,CAAC,YAAY,CAAC,IAAI,IAAI,EAAE,OAAOH,KAAK,CAACC,IAAI,CAACE,IAAI,CAAC;AAAE;AAC7J,SAASf,kBAAkBA,CAACD,GAAG,EAAE;EAAE,IAAIa,KAAK,CAACI,OAAO,CAACjB,GAAG,CAAC,EAAE,OAAOQ,iBAAiB,CAACR,GAAG,CAAC;AAAE;AAC1F,SAASQ,iBAAiBA,CAACR,GAAG,EAAEkB,GAAG,EAAE;EAAE,IAAIA,GAAG,IAAI,IAAI,IAAIA,GAAG,GAAGlB,GAAG,CAACmB,MAAM,EAAED,GAAG,GAAGlB,GAAG,CAACmB,MAAM;EAAE,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,IAAI,GAAG,IAAIR,KAAK,CAACK,GAAG,CAAC,EAAEE,CAAC,GAAGF,GAAG,EAAEE,CAAC,EAAE,EAAEC,IAAI,CAACD,CAAC,CAAC,GAAGpB,GAAG,CAACoB,CAAC,CAAC;EAAE,OAAOC,IAAI;AAAE;AAkBlL,SAASC,eAAeA,CAACC,QAAQ,EAAEC,WAAW,EAAE;EAAE,IAAI,EAAED,QAAQ,YAAYC,WAAW,CAAC,EAAE;IAAE,MAAM,IAAInB,SAAS,CAAC,mCAAmC,CAAC;EAAE;AAAE;AACxJ,SAASoB,iBAAiBA,CAACC,MAAM,EAAEC,KAAK,EAAE;EAAE,KAAK,IAAIP,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGO,KAAK,CAACR,MAAM,EAAEC,CAAC,EAAE,EAAE;IAAE,IAAIQ,UAAU,GAAGD,KAAK,CAACP,CAAC,CAAC;IAAEQ,UAAU,CAACC,UAAU,GAAGD,UAAU,CAACC,UAAU,IAAI,KAAK;IAAED,UAAU,CAACE,YAAY,GAAG,IAAI;IAAE,IAAI,OAAO,IAAIF,UAAU,EAAEA,UAAU,CAACG,QAAQ,GAAG,IAAI;IAAEpC,MAAM,CAACqC,cAAc,CAACN,MAAM,EAAEO,cAAc,CAACL,UAAU,CAACM,GAAG,CAAC,EAAEN,UAAU,CAAC;EAAE;AAAE;AAC5U,SAASO,YAAYA,CAACX,WAAW,EAAEY,UAAU,EAAEC,WAAW,EAAE;EAAE,IAAID,UAAU,EAAEX,iBAAiB,CAACD,WAAW,CAACnC,SAAS,EAAE+C,UAAU,CAAC;EAAE,IAAIC,WAAW,EAAEZ,iBAAiB,CAACD,WAAW,EAAEa,WAAW,CAAC;EAAE1C,MAAM,CAACqC,cAAc,CAACR,WAAW,EAAE,WAAW,EAAE;IAAEO,QAAQ,EAAE;EAAM,CAAC,CAAC;EAAE,OAAOP,WAAW;AAAE;AAC5R,SAASS,cAAcA,CAACK,GAAG,EAAE;EAAE,IAAIJ,GAAG,GAAGK,YAAY,CAACD,GAAG,EAAE,QAAQ,CAAC;EAAE,OAAOtD,OAAO,CAACkD,GAAG,CAAC,KAAK,QAAQ,GAAGA,GAAG,GAAGM,MAAM,CAACN,GAAG,CAAC;AAAE;AAC5H,SAASK,YAAYA,CAACE,KAAK,EAAEC,IAAI,EAAE;EAAE,IAAI1D,OAAO,CAACyD,KAAK,CAAC,KAAK,QAAQ,IAAIA,KAAK,KAAK,IAAI,EAAE,OAAOA,KAAK;EAAE,IAAIE,IAAI,GAAGF,KAAK,CAACvD,MAAM,CAAC0D,WAAW,CAAC;EAAE,IAAID,IAAI,KAAKE,SAAS,EAAE;IAAE,IAAIC,GAAG,GAAGH,IAAI,CAAChC,IAAI,CAAC8B,KAAK,EAAEC,IAAI,IAAI,SAAS,CAAC;IAAE,IAAI1D,OAAO,CAAC8D,GAAG,CAAC,KAAK,QAAQ,EAAE,OAAOA,GAAG;IAAE,MAAM,IAAIzC,SAAS,CAAC,8CAA8C,CAAC;EAAE;EAAE,OAAO,CAACqC,IAAI,KAAK,QAAQ,GAAGF,MAAM,GAAGO,MAAM,EAAEN,KAAK,CAAC;AAAE;AAC5X,OAAOO,gBAAgB,MAAM,kBAAkB;AAC/C,SAASC,SAAS,EAAEC,gBAAgB,QAAQ,0BAA0B;AACtE,SAASC,IAAI,QAAQ,2BAA2B;AAChD,SAASC,SAAS,QAAQ,yBAAyB;AACnD,SAASC,mBAAmB,QAAQ,aAAa;AACjD,SAASC,YAAY,QAAQ,sCAAsC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,IAAIC,qBAAqB,GAAG,aAAa,YAAY;EACnD,SAASA,qBAAqBA,CAACC,MAAM,EAAE;IACrClC,eAAe,CAAC,IAAI,EAAEiC,qBAAqB,CAAC;IAC5C;AACJ;AACA;AACA;AACA;IACI,IAAI,CAACC,MAAM,GAAGA,MAAM;IACpB;AACJ;AACA;AACA;AACA;IACI,IAAI,CAACC,WAAW,GAAG,EAAE;IACrB;AACJ;AACA;AACA;AACA;IACI,IAAI,CAACC,GAAG,GAAGF,MAAM,CAACE,GAAG;EACvB;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEvB,YAAY,CAACoB,qBAAqB,EAAE,CAAC;IACnCrB,GAAG,EAAE,KAAK;IACVpC,KAAK;IACL;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;IACI,SAAS6D,GAAGA,CAACC,GAAG,EAAEC,MAAM,EAAE;MACxB,IAAIJ,WAAW,GAAG,IAAI,CAACA,WAAW;MAClC,IAAIK,MAAM,GAAG,KAAK;MAClBV,SAAS,CAACK,WAAW,EAAE,UAAUM,UAAU,EAAE;QAC3C,IAAIA,UAAU,CAACH,GAAG,IAAIA,GAAG,IAAIG,UAAU,CAACH,GAAG,GAAGG,UAAU,CAACC,OAAO,GAAG,CAAC,IAAIJ,GAAG,IAAIG,UAAU,CAACE,GAAG,IAAIJ,MAAM,IAAIE,UAAU,CAACE,GAAG,GAAGF,UAAU,CAACG,OAAO,GAAG,CAAC,IAAIL,MAAM,EAAE;UAC5JC,MAAM,GAAGC,UAAU;UACnB,OAAO,KAAK;QACd;QACA,OAAO,IAAI;MACb,CAAC,CAAC;MACF,OAAOD,MAAM;IACf;;IAEA;AACJ;AACA;AACA;AACA;AACA;EACE,CAAC,EAAE;IACD5B,GAAG,EAAE,YAAY;IACjBpC,KAAK,EAAE,SAASqE,UAAUA,CAACC,KAAK,EAAE;MAChC,IAAIX,WAAW,GAAG,IAAI,CAACA,WAAW;MAClC,IAAIK,MAAM,GAAG,KAAK;MAClBV,SAAS,CAACK,WAAW,EAAE,UAAUM,UAAU,EAAE;QAC3C,IAAIA,UAAU,CAACH,GAAG,IAAIQ,KAAK,CAACtD,IAAI,CAAC8C,GAAG,IAAIG,UAAU,CAACH,GAAG,GAAGG,UAAU,CAACC,OAAO,GAAG,CAAC,IAAII,KAAK,CAACC,EAAE,CAACT,GAAG,IAAIG,UAAU,CAACE,GAAG,IAAIG,KAAK,CAACtD,IAAI,CAACmD,GAAG,IAAIF,UAAU,CAACE,GAAG,GAAGF,UAAU,CAACG,OAAO,GAAG,CAAC,IAAIE,KAAK,CAACC,EAAE,CAACJ,GAAG,EAAE;UAC9LH,MAAM,GAAGC,UAAU;UACnB,OAAOD,MAAM;QACf;QACA,OAAO,IAAI;MACb,CAAC,CAAC;MACF,OAAOA,MAAM;IACf;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;EACE,CAAC,EAAE;IACD5B,GAAG,EAAE,gBAAgB;IACrBpC,KAAK,EAAE,SAASwE,cAAcA,CAACF,KAAK,EAAE;MACpC,IAAIG,KAAK,GAAG,IAAI;MAChB,IAAIC,aAAa,GAAGC,SAAS,CAACtD,MAAM,GAAG,CAAC,IAAIsD,SAAS,CAAC,CAAC,CAAC,KAAK5B,SAAS,GAAG4B,SAAS,CAAC,CAAC,CAAC,GAAG,KAAK;MAC7F,IAAIhB,WAAW,GAAG,IAAI,CAACA,WAAW;MAClC,IAAIiB,gBAAgB,GAAG,EAAE;MACzB,IAAIC,WAAW,GAAGP,KAAK;MACvB,IAAI,CAACO,WAAW,CAACC,aAAa,EAAE;QAC9B,IAAI9D,IAAI,GAAG,IAAI,CAAC4C,GAAG,CAACmB,iBAAiB,CAACF,WAAW,CAAC7D,IAAI,CAAC8C,GAAG,EAAEe,WAAW,CAAC7D,IAAI,CAACmD,GAAG,CAAC;QACjF,IAAII,EAAE,GAAG,IAAI,CAACX,GAAG,CAACmB,iBAAiB,CAACF,WAAW,CAACN,EAAE,CAACT,GAAG,EAAEe,WAAW,CAACN,EAAE,CAACJ,GAAG,CAAC;QAC3EU,WAAW,GAAG,IAAI,CAACjB,GAAG,CAACoB,gBAAgB,CAAChE,IAAI,EAAEA,IAAI,EAAEuD,EAAE,CAAC;MACzD;MACAjB,SAAS,CAACK,WAAW,EAAE,UAAUM,UAAU,EAAE;QAC3C,IAAIgB,iBAAiB,GAAGR,KAAK,CAACb,GAAG,CAACmB,iBAAiB,CAACd,UAAU,CAACH,GAAG,EAAEG,UAAU,CAACE,GAAG,CAAC;QACnF,IAAIe,qBAAqB,GAAGT,KAAK,CAACb,GAAG,CAACmB,iBAAiB,CAACd,UAAU,CAACH,GAAG,GAAGG,UAAU,CAACC,OAAO,GAAG,CAAC,EAAED,UAAU,CAACE,GAAG,GAAGF,UAAU,CAACG,OAAO,GAAG,CAAC,CAAC;QACzI,IAAIe,eAAe,GAAGV,KAAK,CAACb,GAAG,CAACoB,gBAAgB,CAACC,iBAAiB,EAAEA,iBAAiB,EAAEC,qBAAqB,CAAC;QAC7G,IAAIR,aAAa,EAAE;UACjB,IAAIG,WAAW,CAACO,QAAQ,CAACD,eAAe,CAAC,EAAE;YACzCP,gBAAgB,CAACS,IAAI,CAACpB,UAAU,CAAC;UACnC;QACF,CAAC,MAAM,IAAIY,WAAW,CAACC,aAAa,CAACK,eAAe,CAAC,EAAE;UACrDP,gBAAgB,CAACS,IAAI,CAACpB,UAAU,CAAC;QACnC;MACF,CAAC,CAAC;MACF,OAAOW,gBAAgB,CAACvD,MAAM,GAAGuD,gBAAgB,GAAG,KAAK;IAC3D;;IAEA;AACJ;AACA;AACA;AACA;AACA;EACE,CAAC,EAAE;IACDxC,GAAG,EAAE,KAAK;IACVpC,KAAK,EAAE,SAASsF,GAAGA,CAACC,cAAc,EAAE;MAClC,IAAI5B,WAAW,GAAG,IAAI,CAACA,WAAW;MAClC,IAAIG,GAAG,GAAGyB,cAAc,CAACzB,GAAG;MAC5B,IAAIC,MAAM,GAAGwB,cAAc,CAACpB,GAAG;MAC/B,IAAID,OAAO,GAAGqB,cAAc,CAACrB,OAAO;MACpC,IAAIE,OAAO,GAAGmB,cAAc,CAACnB,OAAO;MACpC,IAAIoB,aAAa,GAAG,IAAItC,gBAAgB,CAACY,GAAG,EAAEC,MAAM,EAAEG,OAAO,EAAEE,OAAO,EAAE,IAAI,CAACR,GAAG,CAACmB,iBAAiB,EAAE,IAAI,CAACnB,GAAG,CAACoB,gBAAgB,CAAC;MAC9H,IAAIS,aAAa,GAAG,IAAI,CAAC5B,GAAG,CAACC,GAAG,EAAEC,MAAM,CAAC;MACzC,IAAI2B,aAAa,GAAG,IAAI,CAACA,aAAa,CAACF,aAAa,CAAC;MACrD,IAAI,CAACC,aAAa,IAAI,CAACC,aAAa,EAAE;QACpC,IAAI,IAAI,CAAC9B,GAAG,EAAE;UACZ4B,aAAa,CAACG,SAAS,CAAC,IAAI,CAAC/B,GAAG,CAAC;QACnC;QACAD,WAAW,CAAC0B,IAAI,CAACG,aAAa,CAAC;QAC/B,OAAOA,aAAa;MACtB;MACAnC,IAAI,CAACI,qBAAqB,CAACmC,sBAAsB,CAACJ,aAAa,CAAC,CAAC;MACjE,OAAO,KAAK;IACd;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACE,CAAC,EAAE;IACDpD,GAAG,EAAE,QAAQ;IACbpC,KAAK,EAAE,SAAS6F,MAAMA,CAAC/B,GAAG,EAAEC,MAAM,EAAE;MAClC,IAAIJ,WAAW,GAAG,IAAI,CAACA,WAAW;MAClC,IAAImC,gBAAgB,GAAG,IAAI,CAACjC,GAAG,CAACC,GAAG,EAAEC,MAAM,CAAC;MAC5C,IAAIgC,qBAAqB,GAAGD,gBAAgB,GAAG,IAAI,CAACnC,WAAW,CAACqC,OAAO,CAACF,gBAAgB,CAAC,GAAG,CAAC,CAAC;MAC9F,IAAIA,gBAAgB,IAAIC,qBAAqB,KAAK,CAAC,CAAC,EAAE;QACpDpC,WAAW,CAACsC,MAAM,CAACF,qBAAqB,EAAE,CAAC,CAAC;QAC5C,OAAOD,gBAAgB;MACzB;MACA,OAAO,KAAK;IACd;;IAEA;AACJ;AACA;EACE,CAAC,EAAE;IACD1D,GAAG,EAAE,OAAO;IACZpC,KAAK,EAAE,SAASkG,KAAKA,CAAA,EAAG;MACtB,IAAIC,MAAM,GAAG,IAAI;MACjB,IAAIxC,WAAW,GAAG,IAAI,CAACA,WAAW;MAClC,IAAIyC,wBAAwB,GAAG,EAAE;MACjC,IAAIC,wBAAwB,GAAG,EAAE;MACjC/C,SAAS,CAACK,WAAW,EAAE,UAAUM,UAAU,EAAE;QAC3C,IAAIqC,EAAE,GAAGH,MAAM,CAACvC,GAAG,CAAC2C,OAAO,CAACtC,UAAU,CAACH,GAAG,EAAEG,UAAU,CAACE,GAAG,CAAC;QAC3D,IAAImC,EAAE,EAAE;UACNF,wBAAwB,CAACf,IAAI,CAAC,CAACiB,EAAE,EAAEH,MAAM,CAACtC,GAAG,CAACI,UAAU,CAACH,GAAG,EAAEG,UAAU,CAACE,GAAG,CAAC,EAAEF,UAAU,CAACH,GAAG,EAAEG,UAAU,CAACE,GAAG,CAAC,CAAC;QACjH;MACF,CAAC,CAAC;MACF,IAAI,CAACR,WAAW,CAACtC,MAAM,GAAG,CAAC;MAC3BiC,SAAS,CAAC8C,wBAAwB,EAAE,UAAUnC,UAAU,EAAE3C,CAAC,EAAE;QAC3D6B,SAAS,CAAC,CAAC,EAAEc,UAAU,CAACC,OAAO,GAAG,CAAC,EAAE,UAAUsC,CAAC,EAAE;UAChDrD,SAAS,CAAC,CAAC,EAAEc,UAAU,CAACG,OAAO,GAAG,CAAC,EAAE,UAAUqC,CAAC,EAAE;YAChD,IAAIA,CAAC,KAAK,CAAC,IAAID,CAAC,KAAK,CAAC,EAAE;cACtB,IAAIF,EAAE,GAAGH,MAAM,CAACvC,GAAG,CAAC2C,OAAO,CAACtC,UAAU,CAACH,GAAG,GAAG0C,CAAC,EAAEvC,UAAU,CAACE,GAAG,GAAGsC,CAAC,CAAC;cACnE,IAAIH,EAAE,EAAE;gBACND,wBAAwB,CAAChB,IAAI,CAAC,CAACiB,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;cACvD;YACF;UACF,CAAC,CAAC;QACJ,CAAC,CAAC;QACFF,wBAAwB,CAAC9E,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI;MACvC,CAAC,CAAC;MACFgC,SAAS,CAAC8C,wBAAwB,EAAE,UAAUM,iBAAiB,EAAE;QAC/DnD,mBAAmB,CAACoD,KAAK,CAAC,KAAK,CAAC,EAAE1G,kBAAkB,CAACyG,iBAAiB,CAAC,CAAC;MAC1E,CAAC,CAAC;MACFpD,SAAS,CAAC+C,wBAAwB,EAAE,UAAUO,uBAAuB,EAAE;QACrErD,mBAAmB,CAACoD,KAAK,CAAC,KAAK,CAAC,EAAE1G,kBAAkB,CAAC2G,uBAAuB,CAAC,CAAC;MAChF,CAAC,CAAC;IACJ;;IAEA;AACJ;AACA;AACA;AACA;AACA;EACE,CAAC,EAAE;IACDxE,GAAG,EAAE,eAAe;IACpBpC,KAAK,EAAE,SAAS0F,aAAaA,CAACzB,UAAU,EAAE;MACxC,IAAI4C,MAAM,GAAG,IAAI;MACjB,IAAI1B,eAAe,GAAG,IAAI,CAACvB,GAAG,CAACoB,gBAAgB,CAAC,IAAI,CAACpB,GAAG,CAACmB,iBAAiB,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,IAAI,CAACnB,GAAG,CAACmB,iBAAiB,CAACd,UAAU,CAACH,GAAG,EAAEG,UAAU,CAACE,GAAG,CAAC,EAAE,IAAI,CAACP,GAAG,CAACmB,iBAAiB,CAACd,UAAU,CAACH,GAAG,GAAGG,UAAU,CAACC,OAAO,GAAG,CAAC,EAAED,UAAU,CAACE,GAAG,GAAGF,UAAU,CAACG,OAAO,GAAG,CAAC,CAAC,CAAC;MAC3P,IAAIJ,MAAM,GAAG,KAAK;MAClBV,SAAS,CAAC,IAAI,CAACK,WAAW,EAAE,UAAUQ,GAAG,EAAE;QACzC,IAAI2C,YAAY,GAAGD,MAAM,CAACjD,GAAG,CAACoB,gBAAgB,CAAC6B,MAAM,CAACjD,GAAG,CAACmB,iBAAiB,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE8B,MAAM,CAACjD,GAAG,CAACmB,iBAAiB,CAACZ,GAAG,CAACL,GAAG,EAAEK,GAAG,CAACA,GAAG,CAAC,EAAE0C,MAAM,CAACjD,GAAG,CAACmB,iBAAiB,CAACZ,GAAG,CAACL,GAAG,GAAGK,GAAG,CAACD,OAAO,GAAG,CAAC,EAAEC,GAAG,CAACA,GAAG,GAAGA,GAAG,CAACC,OAAO,GAAG,CAAC,CAAC,CAAC;QACtN,IAAI0C,YAAY,CAAC1B,QAAQ,CAACD,eAAe,CAAC,EAAE;UAC1CnB,MAAM,GAAG,IAAI;UACb,OAAO,KAAK;QACd;QACA,OAAO,IAAI;MACb,CAAC,CAAC;MACF,OAAOA,MAAM;IACf;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;EACE,CAAC,EAAE;IACD5B,GAAG,EAAE,6BAA6B;IAClCpC,KAAK,EAAE,SAAS+G,2BAA2BA,CAACjD,GAAG,EAAEC,MAAM,EAAE;MACvD,IAAIiD,WAAW,GAAG,IAAI,CAACnD,GAAG,CAACC,GAAG,EAAEC,MAAM,CAAC;;MAEvC;MACA,OAAOiD,WAAW,IAAI,IAAI,CAACpD,GAAG,CAACqD,cAAc,CAACC,wBAAwB,CAACF,WAAW,CAAClD,GAAG,EAAE,CAAC,CAAC,KAAKA,GAAG,IAAI,IAAI,CAACF,GAAG,CAACuD,iBAAiB,CAACD,wBAAwB,CAACF,WAAW,CAAC7C,GAAG,EAAE,CAAC,CAAC,KAAKJ,MAAM;IAC1L;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACE,CAAC,EAAE;IACD3B,GAAG,EAAE,0BAA0B;IAC/BpC,KAAK,EAAE,SAASoH,wBAAwBA,CAACtD,GAAG,EAAEC,MAAM,EAAE;MACpD,IAAIiD,WAAW,GAAG,IAAI,CAACnD,GAAG,CAACC,GAAG,EAAEC,MAAM,CAAC;MACvC,IAAI,CAACiD,WAAW,IAAI,IAAI,CAACD,2BAA2B,CAACjD,GAAG,EAAEC,MAAM,CAAC,EAAE;QACjE,OAAO,IAAI,CAACH,GAAG,CAACmB,iBAAiB,CAACjB,GAAG,EAAEC,MAAM,CAAC;MAChD;MACA,IAAIsD,kBAAkB,GAAG,IAAI,CAACzD,GAAG,CAACqD,cAAc,CAACC,wBAAwB,CAACF,WAAW,CAAClD,GAAG,EAAE,CAAC,CAAC;MAC7F,IAAIwD,qBAAqB,GAAG,IAAI,CAAC1D,GAAG,CAACuD,iBAAiB,CAACD,wBAAwB,CAACF,WAAW,CAAC7C,GAAG,EAAE,CAAC,CAAC;MACnG,OAAO,IAAI,CAACP,GAAG,CAACmB,iBAAiB,CAACsC,kBAAkB,EAAEC,qBAAqB,CAAC;IAC9E;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;EACE,CAAC,EAAE;IACDlF,GAAG,EAAE,kBAAkB;IACvBpC,KAAK,EAAE,SAASuH,gBAAgBA,CAACC,SAAS,EAAEC,KAAK,EAAEC,KAAK,EAAE;MACxD,IAAIC,MAAM,GAAG,IAAI;MACjB,IAAIC,WAAW,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;MACxB,QAAQJ,SAAS;QACf,KAAK,OAAO;UACVI,WAAW,CAAC,CAAC,CAAC,IAAIF,KAAK;UACvB;QACF,KAAK,MAAM;UACTE,WAAW,CAAC,CAAC,CAAC,IAAIF,KAAK;UACvB;QACF,KAAK,MAAM;UACTE,WAAW,CAAC,CAAC,CAAC,IAAIF,KAAK;UACvB;QACF,KAAK,IAAI;UACPE,WAAW,CAAC,CAAC,CAAC,IAAIF,KAAK;UACvB;QACF;MAAQ;MAEVpE,SAAS,CAAC,IAAI,CAACK,WAAW,EAAE,UAAUkE,YAAY,EAAE;QAClDA,YAAY,CAACC,KAAK,CAACF,WAAW,EAAEH,KAAK,CAAC;MACxC,CAAC,CAAC;MACFrE,gBAAgB,CAAC,IAAI,CAACO,WAAW,CAACtC,MAAM,GAAG,CAAC,EAAE,CAAC,EAAE,UAAUC,CAAC,EAAE;QAC5D,IAAIuG,YAAY,GAAGF,MAAM,CAAChE,WAAW,CAACrC,CAAC,CAAC;QACxC,IAAIuG,YAAY,IAAIA,YAAY,CAACE,OAAO,EAAE;UACxCJ,MAAM,CAAChE,WAAW,CAACsC,MAAM,CAAC0B,MAAM,CAAChE,WAAW,CAACqC,OAAO,CAAC6B,YAAY,CAAC,EAAE,CAAC,CAAC;QACxE;MACF,CAAC,CAAC;IACJ;EACF,CAAC,CAAC,EAAE,CAAC;IACHzF,GAAG,EAAE,wBAAwB;IAC7BpC,KAAK,EAAE,SAAS4F,sBAAsBA,CAACJ,aAAa,EAAE;MACpD,OAAOhC,YAAY,CAAChE,eAAe,KAAKA,eAAe,GAAGC,sBAAsB,CAAC,CAAC,+BAA+B,EAAE,IAAI,EAAE,iJAAiJ,CAAC,EAAE,CAAC,+BAA+B,EAAE,IAAI,EAAE,yJAAyJ,CAAC,CAAC,CAAC,EAAE+F,aAAa,CAAC1B,GAAG,EAAE0B,aAAa,CAACrB,GAAG,CAAC;IAC1f;EACF,CAAC,CAAC,CAAC;EACH,OAAOV,qBAAqB;AAC9B,CAAC,EAAE;AACH,eAAeA,qBAAqB"},"metadata":{},"sourceType":"module","externalDependencies":[]}