{"ast":null,"code":"import { hasOwnProperty, isObject, objectEach, inherit, extend } from \"../../helpers/object.mjs\";\nimport { getCellType } from \"../../cellTypes/registry.mjs\";\n/**\n * Checks if the given property can be overwritten.\n *\n * @param {string} propertyName The property name to check.\n * @param {object} metaObject The current object meta settings.\n * @returns {boolean}\n */\nfunction canBeOverwritten(propertyName, metaObject) {\n  var _metaObject$_automati;\n  if (propertyName === 'CELL_TYPE') {\n    return false;\n  }\n  return ((_metaObject$_automati = metaObject._automaticallyAssignedMetaProps) === null || _metaObject$_automati === void 0 ? void 0 : _metaObject$_automati.has(propertyName)) || !hasOwnProperty(metaObject, propertyName);\n}\n\n/**\n * Expands \"type\" property of the meta object to single values. For example `type: 'numeric'` sets\n * \"renderer\", \"editor\", \"validator\" properties to specific functions designed for numeric values.\n * If \"type\" is passed as an object that object will be returned, excluding properties that\n * already exist in the \"metaObject\".\n *\n * The function utilizes `_automaticallyAssignedMetaProps` meta property that allows tracking what\n * properties are changed by the \"type\" expanding feature. That properties can be always overwritten by\n * the user.\n *\n * @param {object} metaObject The meta object.\n * @param {object} settings The settings object with the \"type\" setting.\n * @param {object} settingsToCompareWith The object to compare which properties need to be updated.\n */\nexport function extendByMetaType(metaObject, settings) {\n  var settingsToCompareWith = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : metaObject;\n  var validType = typeof settings.type === 'string' ? getCellType(settings.type) : settings.type;\n  if (metaObject._automaticallyAssignedMetaProps) {\n    objectEach(settings, function (value, key) {\n      return void metaObject._automaticallyAssignedMetaProps.delete(key);\n    });\n  }\n  if (!isObject(validType)) {\n    return;\n  }\n  if (settingsToCompareWith === metaObject && !metaObject._automaticallyAssignedMetaProps) {\n    metaObject._automaticallyAssignedMetaProps = new Set();\n  }\n  var expandedType = {};\n  objectEach(validType, function (value, property) {\n    if (canBeOverwritten(property, settingsToCompareWith)) {\n      var _metaObject$_automati2;\n      expandedType[property] = value;\n      (_metaObject$_automati2 = metaObject._automaticallyAssignedMetaProps) === null || _metaObject$_automati2 === void 0 ? void 0 : _metaObject$_automati2.add(property);\n    }\n  });\n  extend(metaObject, expandedType);\n}\n\n/**\n * Creates new class which extends properties from TableMeta layer class.\n *\n * @param {TableMeta} TableMeta The TableMeta which the new ColumnMeta is created from.\n * @param {string[]} [conflictList] List of the properties which are conflicted with the column meta layer.\n *                                  Conflicted properties are overwritten by `undefined` value, to separate them\n *                                  from the TableMeta layer.\n * @returns {ColumnMeta} Returns constructor ready to initialize with `new` operator.\n */\nexport function columnFactory(TableMeta) {\n  var conflictList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  // Do not use ES6 \"class extends\" syntax here. It seems that the babel produces code\n  // which drastically decreases the performance of the ColumnMeta class creation.\n\n  /**\n   * Base \"class\" for column meta.\n   */\n  function ColumnMeta() {}\n  inherit(ColumnMeta, TableMeta);\n\n  // Clear conflict settings\n  for (var i = 0; i < conflictList.length; i++) {\n    ColumnMeta.prototype[conflictList[i]] = void 0;\n  }\n  return ColumnMeta;\n}\n\n/**\n * Helper which checks if the provided argument is an unsigned number.\n *\n * @param {*} value Value to check.\n * @returns {boolean}\n */\nexport function isUnsignedNumber(value) {\n  return Number.isInteger(value) && value >= 0;\n}\n\n/**\n * Function which makes assertion by custom condition. Function throws an error when assertion doesn't meet the spec.\n *\n * @param {Function} condition Function with custom logic. The condition has to return boolean values.\n * @param {string} errorMessage String which describes assertion error.\n */\nexport function assert(condition, errorMessage) {\n  if (!condition()) {\n    throw new Error(\"Assertion failed: \".concat(errorMessage));\n  }\n}\n\n/**\n * Check if given variable is null or undefined.\n *\n * @param {*} variable Variable to check.\n * @returns {boolean}\n */\nexport function isNullish(variable) {\n  return variable === null || variable === void 0;\n}","map":{"version":3,"names":["hasOwnProperty","isObject","objectEach","inherit","extend","getCellType","canBeOverwritten","propertyName","metaObject","_metaObject$_automati","_automaticallyAssignedMetaProps","has","extendByMetaType","settings","settingsToCompareWith","arguments","length","undefined","validType","type","value","key","delete","Set","expandedType","property","_metaObject$_automati2","add","columnFactory","TableMeta","conflictList","ColumnMeta","i","prototype","isUnsignedNumber","Number","isInteger","assert","condition","errorMessage","Error","concat","isNullish","variable"],"sources":["/home/rstorey/wwwdev/Blucktool/node_modules/handsontable/dataMap/metaManager/utils.mjs"],"sourcesContent":["import \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.number.is-integer.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport { hasOwnProperty, isObject, objectEach, inherit, extend } from \"../../helpers/object.mjs\";\nimport { getCellType } from \"../../cellTypes/registry.mjs\";\n/**\n * Checks if the given property can be overwritten.\n *\n * @param {string} propertyName The property name to check.\n * @param {object} metaObject The current object meta settings.\n * @returns {boolean}\n */\nfunction canBeOverwritten(propertyName, metaObject) {\n  var _metaObject$_automati;\n  if (propertyName === 'CELL_TYPE') {\n    return false;\n  }\n  return ((_metaObject$_automati = metaObject._automaticallyAssignedMetaProps) === null || _metaObject$_automati === void 0 ? void 0 : _metaObject$_automati.has(propertyName)) || !hasOwnProperty(metaObject, propertyName);\n}\n\n/**\n * Expands \"type\" property of the meta object to single values. For example `type: 'numeric'` sets\n * \"renderer\", \"editor\", \"validator\" properties to specific functions designed for numeric values.\n * If \"type\" is passed as an object that object will be returned, excluding properties that\n * already exist in the \"metaObject\".\n *\n * The function utilizes `_automaticallyAssignedMetaProps` meta property that allows tracking what\n * properties are changed by the \"type\" expanding feature. That properties can be always overwritten by\n * the user.\n *\n * @param {object} metaObject The meta object.\n * @param {object} settings The settings object with the \"type\" setting.\n * @param {object} settingsToCompareWith The object to compare which properties need to be updated.\n */\nexport function extendByMetaType(metaObject, settings) {\n  var settingsToCompareWith = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : metaObject;\n  var validType = typeof settings.type === 'string' ? getCellType(settings.type) : settings.type;\n  if (metaObject._automaticallyAssignedMetaProps) {\n    objectEach(settings, function (value, key) {\n      return void metaObject._automaticallyAssignedMetaProps.delete(key);\n    });\n  }\n  if (!isObject(validType)) {\n    return;\n  }\n  if (settingsToCompareWith === metaObject && !metaObject._automaticallyAssignedMetaProps) {\n    metaObject._automaticallyAssignedMetaProps = new Set();\n  }\n  var expandedType = {};\n  objectEach(validType, function (value, property) {\n    if (canBeOverwritten(property, settingsToCompareWith)) {\n      var _metaObject$_automati2;\n      expandedType[property] = value;\n      (_metaObject$_automati2 = metaObject._automaticallyAssignedMetaProps) === null || _metaObject$_automati2 === void 0 ? void 0 : _metaObject$_automati2.add(property);\n    }\n  });\n  extend(metaObject, expandedType);\n}\n\n/**\n * Creates new class which extends properties from TableMeta layer class.\n *\n * @param {TableMeta} TableMeta The TableMeta which the new ColumnMeta is created from.\n * @param {string[]} [conflictList] List of the properties which are conflicted with the column meta layer.\n *                                  Conflicted properties are overwritten by `undefined` value, to separate them\n *                                  from the TableMeta layer.\n * @returns {ColumnMeta} Returns constructor ready to initialize with `new` operator.\n */\nexport function columnFactory(TableMeta) {\n  var conflictList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  // Do not use ES6 \"class extends\" syntax here. It seems that the babel produces code\n  // which drastically decreases the performance of the ColumnMeta class creation.\n\n  /**\n   * Base \"class\" for column meta.\n   */\n  function ColumnMeta() {}\n  inherit(ColumnMeta, TableMeta);\n\n  // Clear conflict settings\n  for (var i = 0; i < conflictList.length; i++) {\n    ColumnMeta.prototype[conflictList[i]] = void 0;\n  }\n  return ColumnMeta;\n}\n\n/**\n * Helper which checks if the provided argument is an unsigned number.\n *\n * @param {*} value Value to check.\n * @returns {boolean}\n */\nexport function isUnsignedNumber(value) {\n  return Number.isInteger(value) && value >= 0;\n}\n\n/**\n * Function which makes assertion by custom condition. Function throws an error when assertion doesn't meet the spec.\n *\n * @param {Function} condition Function with custom logic. The condition has to return boolean values.\n * @param {string} errorMessage String which describes assertion error.\n */\nexport function assert(condition, errorMessage) {\n  if (!condition()) {\n    throw new Error(\"Assertion failed: \".concat(errorMessage));\n  }\n}\n\n/**\n * Check if given variable is null or undefined.\n *\n * @param {*} variable Variable to check.\n * @returns {boolean}\n */\nexport function isNullish(variable) {\n  return variable === null || variable === void 0;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}