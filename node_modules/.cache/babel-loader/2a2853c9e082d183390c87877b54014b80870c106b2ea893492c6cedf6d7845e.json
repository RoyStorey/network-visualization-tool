{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (_x = (_i = _i.call(arr)).next, 0 === i) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n    } catch (err) {\n      _d = !0, _e = err;\n    } finally {\n      try {\n        if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nimport { hasClass, index, offset, removeClass, removeTextNodes, overlayContainsElement, closest, outerHeight, outerWidth, innerHeight, isVisible as _isVisible } from \"../../../helpers/dom/element.mjs\";\nimport { isFunction } from \"../../../helpers/function.mjs\";\nimport ColumnFilter from \"./filter/column.mjs\";\nimport RowFilter from \"./filter/row.mjs\";\nimport { Renderer } from \"./renderer/index.mjs\";\nimport ColumnUtils from \"./utils/column.mjs\";\nimport RowUtils from \"./utils/row.mjs\";\nimport { CLONE_TOP, CLONE_BOTTOM, CLONE_INLINE_START, CLONE_TOP_INLINE_START_CORNER, CLONE_BOTTOM_INLINE_START_CORNER } from \"./overlay/index.mjs\";\n/**\n * @todo These mixes are never added to the class Table, however their members are used here.\n * @todo Continue: Potentially it works only, because some of these mixes are added to every inherited class.\n * @todo Refactoring, move code from `if(this.isMaster)` into MasterTable, and others like that.\n * @mixes stickyColumnsStart\n * @mixes stickyRowsBottom\n * @mixes stickyRowsTop\n * @mixes calculatedRows\n * @mixes calculatedColumns\n * @abstract\n */\nvar Table = /*#__PURE__*/function () {\n  /**\n   * The walkontable settings.\n   *\n   * @protected\n   * @type {Settings}\n   */\n\n  /**\n   * Indicates if the table has height bigger than 0px.\n   *\n   * @type {boolean}\n   */\n\n  /**\n   * Indicates if the table has width bigger than 0px.\n   *\n   * @type {boolean}\n   */\n\n  /**\n   * Indicates if the table is visible. By visible, it means that the holder\n   * element has CSS 'display' property different than 'none'.\n   *\n   * @type {boolean}\n   */\n\n  /**\n   *\n   * @abstract\n   * @param {TableDao} dataAccessObject The data access object.\n   * @param {FacadeGetter} facadeGetter Function which return proper facade.\n   * @param {DomBindings} domBindings Bindings into DOM.\n   * @param {Settings} wtSettings The Walkontable settings.\n   * @param {'master'|CLONE_TYPES_ENUM} name Overlay name.\n   */\n  function Table(dataAccessObject, facadeGetter, domBindings, wtSettings, name) {\n    var _this = this;\n    _classCallCheck(this, Table);\n    _defineProperty(this, \"wtSettings\", null);\n    _defineProperty(this, \"domBindings\", void 0);\n    _defineProperty(this, \"TBODY\", null);\n    _defineProperty(this, \"THEAD\", null);\n    _defineProperty(this, \"COLGROUP\", null);\n    _defineProperty(this, \"hasTableHeight\", true);\n    _defineProperty(this, \"hasTableWidth\", true);\n    _defineProperty(this, \"isTableVisible\", false);\n    _defineProperty(this, \"tableOffset\", 0);\n    _defineProperty(this, \"holderOffset\", 0);\n    this.domBindings = domBindings;\n    /**\n     * Indicates if this instance is of type `MasterTable` (i.e. It is NOT an overlay).\n     *\n     * @type {boolean}\n     */\n    this.isMaster = name === 'master';\n    this.name = name;\n    this.dataAccessObject = dataAccessObject;\n    this.facadeGetter = facadeGetter;\n    this.wtSettings = wtSettings;\n\n    // legacy support\n    this.instance = this.dataAccessObject.wot; // TODO refactoring: it might be removed here, and provides legacy support through facade.\n    this.wot = this.dataAccessObject.wot;\n    this.TABLE = domBindings.rootTable;\n    removeTextNodes(this.TABLE);\n\n    // TODO refactoring, to recognize the legitimacy of moving them into domBidings\n    this.spreader = this.createSpreader(this.TABLE);\n    this.hider = this.createHider(this.spreader);\n    this.holder = this.createHolder(this.hider);\n    this.wtRootElement = this.holder.parentNode;\n    if (this.isMaster) {\n      this.alignOverlaysWithTrimmingContainer(); // todo wow, It calls method from child class (MasterTable).\n    }\n\n    this.fixTableDomTree();\n    this.rowFilter = null; // TODO refactoring, eliminate all (re)creations of this object, then updates state when needed.\n    this.columnFilter = null; // TODO refactoring, eliminate all (re)creations of this object, then updates state when needed.\n    this.correctHeaderWidth = false;\n    var origRowHeaderWidth = this.wtSettings.getSettingPure('rowHeaderWidth');\n\n    // Fix for jumping row headers (https://github.com/handsontable/handsontable/issues/3850)\n    this.wtSettings.update('rowHeaderWidth', function () {\n      return _this._modifyRowHeaderWidth(origRowHeaderWidth);\n    });\n    this.rowUtils = new RowUtils(this.dataAccessObject, this.wtSettings); // TODO refactoring, It can be passed through IOC.\n    this.columnUtils = new ColumnUtils(this.dataAccessObject, this.wtSettings); // TODO refactoring, It can be passed through IOC.\n\n    this.tableRenderer = new Renderer({\n      // TODO refactoring, It can be passed through IOC.\n      TABLE: this.TABLE,\n      THEAD: this.THEAD,\n      COLGROUP: this.COLGROUP,\n      TBODY: this.TBODY,\n      rowUtils: this.rowUtils,\n      columnUtils: this.columnUtils,\n      cellRenderer: this.wtSettings.getSettingPure('cellRenderer')\n    });\n  }\n\n  /**\n   * Returns a boolean that is true if this Table represents a specific overlay, identified by the overlay name.\n   * For MasterTable, it returns false.\n   *\n   * @param {string} overlayTypeName The overlay type.\n   * @returns {boolean}\n   */\n  _createClass(Table, [{\n    key: \"is\",\n    value: function is(overlayTypeName) {\n      // todo refactoring: eliminate all protected and private usages\n      return this.name === overlayTypeName;\n    }\n\n    /**\n     *\n     */\n  }, {\n    key: \"fixTableDomTree\",\n    value: function fixTableDomTree() {\n      var rootDocument = this.domBindings.rootDocument;\n      this.TBODY = this.TABLE.querySelector('tbody');\n      if (!this.TBODY) {\n        this.TBODY = rootDocument.createElement('tbody');\n        this.TABLE.appendChild(this.TBODY);\n      }\n      this.THEAD = this.TABLE.querySelector('thead');\n      if (!this.THEAD) {\n        this.THEAD = rootDocument.createElement('thead');\n        this.TABLE.insertBefore(this.THEAD, this.TBODY);\n      }\n      this.COLGROUP = this.TABLE.querySelector('colgroup');\n      if (!this.COLGROUP) {\n        this.COLGROUP = rootDocument.createElement('colgroup');\n        this.TABLE.insertBefore(this.COLGROUP, this.THEAD);\n      }\n    }\n\n    /**\n     * @param {HTMLTableElement} table An element to process.\n     * @returns {HTMLElement}\n     */\n  }, {\n    key: \"createSpreader\",\n    value: function createSpreader(table) {\n      var parent = table.parentNode;\n      var spreader;\n      if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, 'wtHolder')) {\n        spreader = this.domBindings.rootDocument.createElement('div');\n        spreader.className = 'wtSpreader';\n        if (parent) {\n          // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n          parent.insertBefore(spreader, table);\n        }\n        spreader.appendChild(table);\n      }\n      spreader.style.position = 'relative';\n      return spreader;\n    }\n\n    /**\n     * @param {HTMLElement} spreader An element to the hider element is injected.\n     * @returns {HTMLElement}\n     */\n  }, {\n    key: \"createHider\",\n    value: function createHider(spreader) {\n      var parent = spreader.parentNode;\n      var hider;\n      if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, 'wtHolder')) {\n        hider = this.domBindings.rootDocument.createElement('div');\n        hider.className = 'wtHider';\n        if (parent) {\n          // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n          parent.insertBefore(hider, spreader);\n        }\n        hider.appendChild(spreader);\n      }\n      return hider;\n    }\n\n    /**\n     *\n     * @param {HTMLElement} hider An element to the holder element is injected.\n     * @returns {HTMLElement}\n     */\n  }, {\n    key: \"createHolder\",\n    value: function createHolder(hider) {\n      var parent = hider.parentNode;\n      var holder;\n      if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, 'wtHolder')) {\n        holder = this.domBindings.rootDocument.createElement('div');\n        holder.style.position = 'relative';\n        holder.className = 'wtHolder';\n        if (parent) {\n          // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n          parent.insertBefore(holder, hider);\n        }\n        if (this.isMaster) {\n          holder.parentNode.className += 'ht_master handsontable';\n          holder.parentNode.setAttribute('dir', this.wtSettings.getSettingPure('rtlMode') ? 'rtl' : 'ltr');\n        }\n        holder.appendChild(hider);\n      }\n      return holder;\n    }\n\n    /**\n     * Redraws the table.\n     *\n     * @param {boolean} [fastDraw=false] If TRUE, will try to avoid full redraw and only update the border positions.\n     *                                   If FALSE or UNDEFINED, will perform a full redraw.\n     * @returns {Table}\n     */\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var wtSettings = this.wtSettings;\n      var _this$dataAccessObjec = this.dataAccessObject,\n        wtOverlays = _this$dataAccessObjec.wtOverlays,\n        wtViewport = _this$dataAccessObjec.wtViewport;\n      var totalRows = wtSettings.getSetting('totalRows');\n      var totalColumns = wtSettings.getSetting('totalColumns');\n      var rowHeaders = wtSettings.getSetting('rowHeaders');\n      var rowHeadersCount = rowHeaders.length;\n      var columnHeaders = wtSettings.getSetting('columnHeaders');\n      var columnHeadersCount = columnHeaders.length;\n      var syncScroll = false;\n      var runFastDraw = fastDraw;\n      if (this.isMaster) {\n        this.holderOffset = offset(this.holder);\n        runFastDraw = wtViewport.createRenderCalculators(runFastDraw);\n        if (rowHeadersCount && !wtSettings.getSetting('fixedColumnsStart')) {\n          var leftScrollPos = wtOverlays.inlineStartOverlay.getScrollPosition();\n          var previousState = this.correctHeaderWidth;\n          this.correctHeaderWidth = leftScrollPos !== 0;\n          if (previousState !== this.correctHeaderWidth) {\n            runFastDraw = false;\n          }\n        }\n      }\n      if (this.isMaster) {\n        syncScroll = wtOverlays.updateStateOfRendering();\n      }\n      if (runFastDraw) {\n        if (this.isMaster) {\n          // in case we only scrolled without redraw, update visible rows information in oldRowsCalculator\n          wtViewport.createVisibleCalculators();\n        }\n        if (wtOverlays) {\n          wtOverlays.refresh(true);\n        }\n      } else {\n        if (this.isMaster) {\n          this.tableOffset = offset(this.TABLE);\n        } else {\n          this.tableOffset = this.dataAccessObject.parentTableOffset;\n        }\n        var startRow = totalRows > 0 ? this.getFirstRenderedRow() : 0;\n        var startColumn = totalColumns > 0 ? this.getFirstRenderedColumn() : 0;\n        this.rowFilter = new RowFilter(startRow, totalRows, columnHeadersCount);\n        this.columnFilter = new ColumnFilter(startColumn, totalColumns, rowHeadersCount);\n        var performRedraw = true;\n\n        // Only master table rendering can be skipped\n        if (this.isMaster) {\n          this.alignOverlaysWithTrimmingContainer(); // todo It calls method from child class (MasterTable).\n          var skipRender = {};\n          this.wtSettings.getSetting('beforeDraw', true, skipRender);\n          performRedraw = skipRender.skipRender !== true;\n        }\n        if (performRedraw) {\n          this.tableRenderer.setHeaderContentRenderers(rowHeaders, columnHeaders);\n          if (this.is(CLONE_BOTTOM) || this.is(CLONE_BOTTOM_INLINE_START_CORNER)) {\n            // do NOT render headers on the bottom or bottom-left corner overlay\n            this.tableRenderer.setHeaderContentRenderers(rowHeaders, []);\n          }\n          this.resetOversizedRows();\n          this.tableRenderer.setViewportSize(this.getRenderedRowsCount(), this.getRenderedColumnsCount()).setFilters(this.rowFilter, this.columnFilter).render();\n          var workspaceWidth;\n          if (this.isMaster) {\n            workspaceWidth = this.dataAccessObject.workspaceWidth;\n            this.dataAccessObject.wtViewport.containerWidth = null;\n            this.markOversizedColumnHeaders();\n          }\n          this.adjustColumnHeaderHeights();\n          if (this.isMaster || this.is(CLONE_BOTTOM)) {\n            this.markOversizedRows();\n          }\n          if (this.isMaster) {\n            this.dataAccessObject.wtViewport.createVisibleCalculators();\n            this.dataAccessObject.wtOverlays.refresh(false);\n            this.dataAccessObject.wtOverlays.applyToDOM();\n            var hiderWidth = outerWidth(this.hider);\n            var tableWidth = outerWidth(this.TABLE);\n            if (hiderWidth !== 0 && tableWidth !== hiderWidth) {\n              // Recalculate the column widths, if width changes made in the overlays removed the scrollbar, thus changing the viewport width.\n              this.columnUtils.calculateWidths();\n              this.tableRenderer.renderer.colGroup.render();\n            }\n            if (workspaceWidth !== this.dataAccessObject.wtViewport.getWorkspaceWidth()) {\n              // workspace width changed though to shown/hidden vertical scrollbar. Let's reapply stretching\n              this.dataAccessObject.wtViewport.containerWidth = null;\n              this.columnUtils.calculateWidths();\n              this.tableRenderer.renderer.colGroup.render();\n            }\n            this.wtSettings.getSetting('onDraw', true);\n          } else if (this.is(CLONE_BOTTOM)) {\n            this.dataAccessObject.cloneSource.wtOverlays.adjustElementsSize();\n          }\n        }\n      }\n      var positionChanged = false;\n      if (this.isMaster) {\n        positionChanged = wtOverlays.topOverlay.resetFixedPosition();\n        if (wtOverlays.bottomOverlay.clone) {\n          positionChanged = wtOverlays.bottomOverlay.resetFixedPosition() || positionChanged;\n        }\n        positionChanged = wtOverlays.inlineStartOverlay.resetFixedPosition() || positionChanged;\n        if (wtOverlays.topInlineStartCornerOverlay) {\n          wtOverlays.topInlineStartCornerOverlay.resetFixedPosition();\n        }\n        if (wtOverlays.bottomInlineStartCornerOverlay && wtOverlays.bottomInlineStartCornerOverlay.clone) {\n          wtOverlays.bottomInlineStartCornerOverlay.resetFixedPosition();\n        }\n      }\n      if (positionChanged) {\n        // It refreshes the cells borders caused by a 1px shift (introduced by overlays which add or\n        // remove `innerBorderTop` and `innerBorderInlineStart` CSS classes to the DOM element. This happens\n        // when there is a switch between rendering from 0 to N rows/columns and vice versa).\n        wtOverlays.refreshAll(); // `refreshAll()` internally already calls `refreshSelections()` method\n        wtOverlays.adjustElementsSize();\n      } else {\n        this.refreshSelections(runFastDraw);\n      }\n      if (syncScroll) {\n        wtOverlays.syncScrollWithMaster();\n      }\n      this.dataAccessObject.drawn = true;\n      return this;\n    }\n\n    /**\n     * @param {number} col The visual column index.\n     */\n  }, {\n    key: \"markIfOversizedColumnHeader\",\n    value: function markIfOversizedColumnHeader(col) {\n      var sourceColIndex = this.columnFilter.renderedToSource(col);\n      var level = this.wtSettings.getSetting('columnHeaders').length;\n      var defaultRowHeight = this.wtSettings.getSetting('defaultRowHeight');\n      var previousColHeaderHeight;\n      var currentHeader;\n      var currentHeaderHeight;\n      var columnHeaderHeightSetting = this.wtSettings.getSetting('columnHeaderHeight') || [];\n      while (level) {\n        level -= 1;\n        previousColHeaderHeight = this.getColumnHeaderHeight(level);\n        currentHeader = this.getColumnHeader(sourceColIndex, level);\n        if (!currentHeader) {\n          /* eslint-disable no-continue */\n          continue;\n        }\n        currentHeaderHeight = innerHeight(currentHeader);\n        if (!previousColHeaderHeight && defaultRowHeight < currentHeaderHeight || previousColHeaderHeight < currentHeaderHeight) {\n          this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] = currentHeaderHeight;\n        }\n        if (Array.isArray(columnHeaderHeightSetting)) {\n          if (columnHeaderHeightSetting[level] !== null && columnHeaderHeightSetting[level] !== void 0) {\n            this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting[level];\n          }\n        } else if (!isNaN(columnHeaderHeightSetting)) {\n          this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting;\n        }\n        if (this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] < (columnHeaderHeightSetting[level] || columnHeaderHeightSetting)) {\n          this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting[level] || columnHeaderHeightSetting; // eslint-disable-line max-len\n        }\n      }\n    }\n\n    /**\n     *\n     */\n  }, {\n    key: \"adjustColumnHeaderHeights\",\n    value: function adjustColumnHeaderHeights() {\n      var wtSettings = this.wtSettings;\n      var children = this.THEAD.childNodes;\n      var oversizedColumnHeaders = this.dataAccessObject.wtViewport.oversizedColumnHeaders;\n      var columnHeaders = wtSettings.getSetting('columnHeaders');\n      for (var i = 0, len = columnHeaders.length; i < len; i++) {\n        if (oversizedColumnHeaders[i]) {\n          if (!children[i] || children[i].childNodes.length === 0) {\n            return;\n          }\n          children[i].childNodes[0].style.height = \"\".concat(oversizedColumnHeaders[i], \"px\");\n        }\n      }\n    }\n\n    /**\n     * Resets cache of row heights. The cache should be cached for each render cycle in a case\n     * when new cell values have content which increases/decreases cell height.\n     */\n  }, {\n    key: \"resetOversizedRows\",\n    value: function resetOversizedRows() {\n      var wtSettings = this.wtSettings;\n      var wtViewport = this.dataAccessObject.wtViewport;\n      if (!this.isMaster && !this.is(CLONE_BOTTOM)) {\n        return;\n      }\n      if (!wtSettings.getSetting('externalRowCalculator')) {\n        var rowsToRender = this.getRenderedRowsCount();\n\n        // Reset the oversized row cache for rendered rows\n        for (var visibleRowIndex = 0; visibleRowIndex < rowsToRender; visibleRowIndex++) {\n          var sourceRow = this.rowFilter.renderedToSource(visibleRowIndex);\n          if (wtViewport.oversizedRows && wtViewport.oversizedRows[sourceRow]) {\n            wtViewport.oversizedRows[sourceRow] = void 0;\n          }\n        }\n      }\n    }\n\n    /**\n     * @param {string} className The CSS class name to remove from the table cells.\n     */\n  }, {\n    key: \"removeClassFromCells\",\n    value: function removeClassFromCells(className) {\n      var nodes = this.TABLE.querySelectorAll(\".\".concat(className));\n      for (var i = 0, len = nodes.length; i < len; i++) {\n        removeClass(nodes[i], className);\n      }\n    }\n\n    /**\n     * Refresh the table selection by re-rendering Selection instances connected with that instance.\n     *\n     * @param {boolean} fastDraw If fast drawing is enabled than additionally className clearing is applied.\n     */\n  }, {\n    key: \"refreshSelections\",\n    value: function refreshSelections(fastDraw) {\n      var wtSettings = this.wtSettings;\n      var selections = this.dataAccessObject.selections;\n      if (!selections) {\n        return;\n      }\n      var highlights = Array.from(selections);\n      var len = highlights.length;\n      if (fastDraw) {\n        var classesToRemove = [];\n        for (var i = 0; i < len; i++) {\n          var _highlights$i$setting = highlights[i].settings,\n            highlightHeaderClassName = _highlights$i$setting.highlightHeaderClassName,\n            highlightRowClassName = _highlights$i$setting.highlightRowClassName,\n            highlightColumnClassName = _highlights$i$setting.highlightColumnClassName;\n          var classNames = highlights[i].classNames;\n          var classNamesLength = classNames.length;\n          for (var j = 0; j < classNamesLength; j++) {\n            if (!classesToRemove.includes(classNames[j])) {\n              classesToRemove.push(classNames[j]);\n            }\n          }\n          if (highlightHeaderClassName && !classesToRemove.includes(highlightHeaderClassName)) {\n            classesToRemove.push(highlightHeaderClassName);\n          }\n          if (highlightRowClassName && !classesToRemove.includes(highlightRowClassName)) {\n            classesToRemove.push(highlightRowClassName);\n          }\n          if (highlightColumnClassName && !classesToRemove.includes(highlightColumnClassName)) {\n            classesToRemove.push(highlightColumnClassName);\n          }\n        }\n        var additionalClassesToRemove = wtSettings.getSetting('onBeforeRemoveCellClassNames');\n        if (Array.isArray(additionalClassesToRemove)) {\n          for (var _i = 0; _i < additionalClassesToRemove.length; _i++) {\n            classesToRemove.push(additionalClassesToRemove[_i]);\n          }\n        }\n        var classesToRemoveLength = classesToRemove.length;\n        for (var _i2 = 0; _i2 < classesToRemoveLength; _i2++) {\n          // there was no rerender, so we need to remove classNames by ourselves\n          this.removeClassFromCells(classesToRemove[_i2]);\n        }\n      }\n      for (var _i3 = 0; _i3 < len; _i3++) {\n        highlights[_i3].draw(this.facadeGetter(), fastDraw);\n      }\n    }\n\n    /**\n     * Get cell element at coords.\n     * Negative coords.row or coords.col are used to retrieve header cells. If there are multiple header levels, the\n     * negative value corresponds to the distance from the working area. For example, when there are 3 levels of column\n     * headers, coords.col=-1 corresponds to the most inner header element, while coords.col=-3 corresponds to the\n     * outmost header element.\n     *\n     * In case an element for the coords is not rendered, the method returns an error code.\n     * To produce the error code, the input parameters are validated in the order in which they\n     * are given. Thus, if both the row and the column coords are out of the rendered bounds,\n     * the method returns the error code for the row.\n     *\n     * @param {CellCoords} coords The cell coordinates.\n     * @returns {HTMLElement|number} HTMLElement on success or Number one of the exit codes on error:\n     *  -1 row before viewport\n     *  -2 row after viewport\n     *  -3 column before viewport\n     *  -4 column after viewport.\n     */\n  }, {\n    key: \"getCell\",\n    value: function getCell(coords) {\n      var row = coords.row;\n      var column = coords.col;\n      var hookResult = this.wtSettings.getSetting('onModifyGetCellCoords', row, column);\n      if (hookResult && Array.isArray(hookResult)) {\n        var _hookResult = _slicedToArray(hookResult, 2);\n        row = _hookResult[0];\n        column = _hookResult[1];\n      }\n      if (this.isRowBeforeRenderedRows(row)) {\n        // row before rendered rows\n        return -1;\n      } else if (this.isRowAfterRenderedRows(row)) {\n        // row after rendered rows\n        return -2;\n      } else if (this.isColumnBeforeRenderedColumns(column)) {\n        // column before rendered columns\n        return -3;\n      } else if (this.isColumnAfterRenderedColumns(column)) {\n        // column after rendered columns\n        return -4;\n      }\n      var TR = this.getRow(row);\n      if (!TR && row >= 0) {\n        throw new Error('TR was expected to be rendered but is not');\n      }\n      var TD = TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(column)];\n      if (!TD && column >= 0) {\n        throw new Error('TD or TH was expected to be rendered but is not');\n      }\n      return TD;\n    }\n\n    /**\n     * Get the DOM element of the row with the provided index.\n     *\n     * @param {number} rowIndex Row index.\n     * @returns {HTMLTableRowElement|boolean} Return the row's DOM element or `false` if the row with the provided\n     * index doesn't exist.\n     */\n  }, {\n    key: \"getRow\",\n    value: function getRow(rowIndex) {\n      var renderedRowIndex = null;\n      var parentElement = null;\n      if (rowIndex < 0) {\n        var _this$rowFilter;\n        renderedRowIndex = (_this$rowFilter = this.rowFilter) === null || _this$rowFilter === void 0 ? void 0 : _this$rowFilter.sourceRowToVisibleColHeadedRow(rowIndex);\n        parentElement = this.THEAD;\n      } else {\n        var _this$rowFilter2;\n        renderedRowIndex = (_this$rowFilter2 = this.rowFilter) === null || _this$rowFilter2 === void 0 ? void 0 : _this$rowFilter2.sourceToRendered(rowIndex);\n        parentElement = this.TBODY;\n      }\n      if (renderedRowIndex !== void 0 && parentElement !== void 0) {\n        if (parentElement.childNodes.length < renderedRowIndex + 1) {\n          return false;\n        } else {\n          return parentElement.childNodes[renderedRowIndex];\n        }\n      } else {\n        return false;\n      }\n    }\n\n    /**\n     * GetColumnHeader.\n     *\n     * @param {number} col Column index.\n     * @param {number} [level=0] Header level (0 = most distant to the table).\n     * @returns {object} HTMLElement on success or undefined on error.\n     */\n  }, {\n    key: \"getColumnHeader\",\n    value: function getColumnHeader(col) {\n      var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var TR = this.THEAD.childNodes[level];\n      return TR === null || TR === void 0 ? void 0 : TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(col)];\n    }\n\n    /**\n     * Gets all columns headers (TH elements) from the table.\n     *\n     * @param {number} column A source column index.\n     * @returns {HTMLTableCellElement[]}\n     */\n  }, {\n    key: \"getColumnHeaders\",\n    value: function getColumnHeaders(column) {\n      var THs = [];\n      var visibleColumn = this.columnFilter.sourceColumnToVisibleRowHeadedColumn(column);\n      this.THEAD.childNodes.forEach(function (TR) {\n        var TH = TR.childNodes[visibleColumn];\n        if (TH) {\n          THs.push(TH);\n        }\n      });\n      return THs;\n    }\n\n    /**\n     * GetRowHeader.\n     *\n     * @param {number} row Row index.\n     * @param {number} [level=0] Header level (0 = most distant to the table).\n     * @returns {HTMLElement} HTMLElement on success or Number one of the exit codes on error: `null table doesn't have row headers`.\n     */\n  }, {\n    key: \"getRowHeader\",\n    value: function getRowHeader(row) {\n      var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      if (this.columnFilter.sourceColumnToVisibleRowHeadedColumn(0) === 0) {\n        return;\n      }\n      var rowHeadersCount = this.wtSettings.getSetting('rowHeaders').length;\n      if (level >= rowHeadersCount) {\n        return;\n      }\n      var TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n      return TR === null || TR === void 0 ? void 0 : TR.childNodes[level];\n    }\n\n    /**\n     * Gets all rows headers (TH elements) from the table.\n     *\n     * @param {number} row A source row index.\n     * @returns {HTMLTableCellElement[]}\n     */\n  }, {\n    key: \"getRowHeaders\",\n    value: function getRowHeaders(row) {\n      if (this.columnFilter.sourceColumnToVisibleRowHeadedColumn(0) === 0) {\n        return [];\n      }\n      var THs = [];\n      var rowHeadersCount = this.wtSettings.getSetting('rowHeaders').length;\n      for (var renderedRowIndex = 0; renderedRowIndex < rowHeadersCount; renderedRowIndex++) {\n        var TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n        var TH = TR === null || TR === void 0 ? void 0 : TR.childNodes[renderedRowIndex];\n        if (TH) {\n          THs.push(TH);\n        }\n      }\n      return THs;\n    }\n\n    /**\n     * Returns cell coords object for a given TD (or a child element of a TD element).\n     *\n     * @param {HTMLTableCellElement} TD A cell DOM element (or a child of one).\n     * @returns {CellCoords|null} The coordinates of the provided TD element (or the closest TD element) or null, if the provided element is not applicable.\n     */\n  }, {\n    key: \"getCoords\",\n    value: function getCoords(TD) {\n      var cellElement = TD;\n      if (cellElement.nodeName !== 'TD' && cellElement.nodeName !== 'TH') {\n        cellElement = closest(cellElement, ['TD', 'TH']);\n      }\n      if (cellElement === null) {\n        return null;\n      }\n      var TR = cellElement.parentNode;\n      var CONTAINER = TR.parentNode;\n      var row = index(TR);\n      var col = cellElement.cellIndex;\n      if (overlayContainsElement(CLONE_TOP_INLINE_START_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_TOP, cellElement, this.wtRootElement)) {\n        if (CONTAINER.nodeName === 'THEAD') {\n          row -= CONTAINER.childNodes.length;\n        }\n      } else if (overlayContainsElement(CLONE_BOTTOM_INLINE_START_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_BOTTOM, cellElement, this.wtRootElement)) {\n        var totalRows = this.wtSettings.getSetting('totalRows');\n        row = totalRows - CONTAINER.childNodes.length + row;\n      } else if (CONTAINER === this.THEAD) {\n        row = this.rowFilter.visibleColHeadedRowToSourceRow(row);\n      } else {\n        row = this.rowFilter.renderedToSource(row);\n      }\n      if (overlayContainsElement(CLONE_TOP_INLINE_START_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_INLINE_START, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_BOTTOM_INLINE_START_CORNER, cellElement, this.wtRootElement)) {\n        col = this.columnFilter.offsettedTH(col);\n      } else {\n        col = this.columnFilter.visibleRowHeadedColumnToSourceColumn(col);\n      }\n      return this.wot.createCellCoords(row, col);\n    }\n\n    /**\n     * Check if any of the rendered rows is higher than expected, and if so, cache them.\n     */\n  }, {\n    key: \"markOversizedRows\",\n    value: function markOversizedRows() {\n      if (this.wtSettings.getSetting('externalRowCalculator')) {\n        return;\n      }\n      var rowCount = this.TBODY.childNodes.length;\n      var expectedTableHeight = rowCount * this.wtSettings.getSetting('defaultRowHeight');\n      var actualTableHeight = innerHeight(this.TBODY) - 1;\n      var previousRowHeight;\n      var rowInnerHeight;\n      var sourceRowIndex;\n      var currentTr;\n      var rowHeader;\n      if (expectedTableHeight === actualTableHeight && !this.wtSettings.getSetting('fixedRowsBottom')) {\n        // If the actual table height equals rowCount * default single row height, no row is oversized -> no need to iterate over them\n        return;\n      }\n      while (rowCount) {\n        rowCount -= 1;\n        sourceRowIndex = this.rowFilter.renderedToSource(rowCount);\n        previousRowHeight = this.getRowHeight(sourceRowIndex);\n        currentTr = this.getTrForRow(sourceRowIndex);\n        rowHeader = currentTr.querySelector('th');\n        if (rowHeader) {\n          rowInnerHeight = innerHeight(rowHeader);\n        } else {\n          rowInnerHeight = innerHeight(currentTr) - 1;\n        }\n        if (!previousRowHeight && this.wtSettings.getSetting('defaultRowHeight') < rowInnerHeight || previousRowHeight < rowInnerHeight) {\n          rowInnerHeight += 1;\n          this.dataAccessObject.wtViewport.oversizedRows[sourceRowIndex] = rowInnerHeight;\n        }\n      }\n    }\n\n    /**\n     * @param {number} row The visual row index.\n     * @returns {HTMLTableElement}\n     */\n  }, {\n    key: \"getTrForRow\",\n    value: function getTrForRow(row) {\n      return this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n    }\n\n    /**\n     * Checks if the column index (negative value from -1 to N) is rendered.\n     *\n     * @param {number} column The column index (negative value from -1 to N).\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isColumnHeaderRendered\",\n    value: function isColumnHeaderRendered(column) {\n      if (column >= 0) {\n        return false;\n      }\n      var rowHeaders = this.wtSettings.getSetting('rowHeaders');\n      var rowHeadersCount = rowHeaders.length;\n      return Math.abs(column) <= rowHeadersCount;\n    }\n\n    /**\n     * Checks if the row index (negative value from -1 to N) is rendered.\n     *\n     * @param {number} row The row index (negative value from -1 to N).\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isRowHeaderRendered\",\n    value: function isRowHeaderRendered(row) {\n      if (row >= 0) {\n        return false;\n      }\n      var columnHeaders = this.wtSettings.getSetting('columnHeaders');\n      var columnHeadersCount = columnHeaders.length;\n      return Math.abs(row) <= columnHeadersCount;\n    }\n\n    /* eslint-disable jsdoc/require-description-complete-sentence */\n    /**\n     * Check if the given row index is lower than the index of the first row that\n     * is currently rendered and return TRUE in that case, or FALSE otherwise.\n     *\n     * Negative row index is used to check the columns' headers.\n     *\n     *  Headers\n     *           +--------------+                                     │\n     *       -3  │    │    │    │                                     │\n     *           +--------------+                                     │\n     *       -2  │    │    │    │                                     │ TRUE\n     *           +--------------+                                     │\n     *       -1  │    │    │    │                                     │\n     *  Cells  +==================+                                   │\n     *        0  ┇    ┇    ┇    ┇ <--- For fixedRowsTop: 1            │\n     *           +--------------+      the master overlay do       ---+ first rendered row (index 1)\n     *        1  │ A2 │ B2 │ C2 │      not render the first row.      │\n     *           +--------------+                                     │ FALSE\n     *        2  │ A3 │ B3 │ C3 │                                     │\n     *           +--------------+                                  ---+ last rendered row\n     *                                                                │\n     *                                                                │ FALSE\n     *\n     * @param {number} row The visual row index.\n     * @memberof Table#\n     * @function isRowBeforeRenderedRows\n     * @returns {boolean}\n     */\n    /* eslint-enable jsdoc/require-description-complete-sentence */\n  }, {\n    key: \"isRowBeforeRenderedRows\",\n    value: function isRowBeforeRenderedRows(row) {\n      var first = this.getFirstRenderedRow();\n\n      // Check the headers only in case when the first rendered row is -1 or 0.\n      // This is an indication that the overlay is placed on the most top position.\n      if (row < 0 && first <= 0) {\n        return !this.isRowHeaderRendered(row);\n      }\n      return row < first;\n    }\n\n    /* eslint-disable jsdoc/require-description-complete-sentence */\n    /**\n     * Check if the given column index is greater than the index of the last column that\n     * is currently rendered and return TRUE in that case, or FALSE otherwise.\n     *\n     * The negative row index is used to check the columns' headers. However,\n     * keep in mind that for negative indexes, the method always returns FALSE as\n     * it is not possible to render headers partially. The \"after\" index can not be\n     * lower than -1.\n     *\n     *  Headers\n     *           +--------------+                                     │\n     *       -3  │    │    │    │                                     │\n     *           +--------------+                                     │\n     *       -2  │    │    │    │                                     │ FALSE\n     *           +--------------+                                     │\n     *       -1  │    │    │    │                                     │\n     *  Cells  +==================+                                   │\n     *        0  ┇    ┇    ┇    ┇ <--- For fixedRowsTop: 1            │\n     *           +--------------+      the master overlay do       ---+ first rendered row (index 1)\n     *        1  │ A2 │ B2 │ C2 │      not render the first rows      │\n     *           +--------------+                                     │ FALSE\n     *        2  │ A3 │ B3 │ C3 │                                     │\n     *           +--------------+                                  ---+ last rendered row\n     *                                                                │\n     *                                                                │ TRUE\n     *\n     * @param {number} row The visual row index.\n     * @memberof Table#\n     * @function isRowAfterRenderedRows\n     * @returns {boolean}\n     */\n    /* eslint-enable jsdoc/require-description-complete-sentence */\n  }, {\n    key: \"isRowAfterRenderedRows\",\n    value: function isRowAfterRenderedRows(row) {\n      return row > this.getLastRenderedRow();\n    }\n\n    /* eslint-disable jsdoc/require-description-complete-sentence */\n    /**\n     * Check if the given column index is lower than the index of the first column that\n     * is currently rendered and return TRUE in that case, or FALSE otherwise.\n     *\n     * Negative column index is used to check the rows' headers.\n     *\n     *                            For fixedColumnsStart: 1 the master overlay\n     *                            do not render this first columns.\n     *  Headers    -3   -2   -1    |\n     *           +----+----+----║┄ ┄ +------+------+\n     *           │    │    │    ║    │  B1  │  C1  │\n     *           +--------------║┄ ┄ --------------│\n     *           │    │    │    ║    │  B2  │  C2  │\n     *           +--------------║┄ ┄ --------------│\n     *           │    │    │    ║    │  B3  │  C3  │\n     *           +----+----+----║┄ ┄ +------+------+\n     *                               ╷             ╷\n     *      -------------------------+-------------+---------------->\n     *          TRUE             first    FALSE   last         FALSE\n     *                           rendered         rendered\n     *                           column           column\n     *\n     * @param {number} column The visual column index.\n     * @memberof Table#\n     * @function isColumnBeforeRenderedColumns\n     * @returns {boolean}\n     */\n    /* eslint-enable jsdoc/require-description-complete-sentence */\n  }, {\n    key: \"isColumnBeforeRenderedColumns\",\n    value: function isColumnBeforeRenderedColumns(column) {\n      var first = this.getFirstRenderedColumn();\n\n      // Check the headers only in case when the first rendered column is -1 or 0.\n      // This is an indication that the overlay is placed on the most left position.\n      if (column < 0 && first <= 0) {\n        return !this.isColumnHeaderRendered(column);\n      }\n      return column < first;\n    }\n\n    /* eslint-disable jsdoc/require-description-complete-sentence */\n    /**\n     * Check if the given column index is greater than the index of the last column that\n     * is currently rendered and return TRUE in that case, or FALSE otherwise.\n     *\n     * The negative column index is used to check the rows' headers. However,\n     * keep in mind that for negative indexes, the method always returns FALSE as\n     * it is not possible to render headers partially. The \"after\" index can not be\n     * lower than -1.\n     *\n     *                            For fixedColumnsStart: 1 the master overlay\n     *                            do not render this first columns.\n     *  Headers    -3   -2   -1    |\n     *           +----+----+----║┄ ┄ +------+------+\n     *           │    │    │    ║    │  B1  │  C1  │\n     *           +--------------║┄ ┄ --------------│\n     *           │    │    │    ║    │  B2  │  C2  │\n     *           +--------------║┄ ┄ --------------│\n     *           │    │    │    ║    │  B3  │  C3  │\n     *           +----+----+----║┄ ┄ +------+------+\n     *                               ╷             ╷\n     *      -------------------------+-------------+---------------->\n     *          FALSE             first    FALSE   last         TRUE\n     *                           rendered         rendered\n     *                           column           column\n     *\n     * @param {number} column The visual column index.\n     * @memberof Table#\n     * @function isColumnAfterRenderedColumns\n     * @returns {boolean}\n     */\n    /* eslint-enable jsdoc/require-description-complete-sentence */\n  }, {\n    key: \"isColumnAfterRenderedColumns\",\n    value: function isColumnAfterRenderedColumns(column) {\n      return this.columnFilter && column > this.getLastRenderedColumn();\n    }\n  }, {\n    key: \"isColumnAfterViewport\",\n    value: function isColumnAfterViewport(column) {\n      return this.columnFilter && column > this.getLastVisibleColumn();\n    }\n  }, {\n    key: \"isRowAfterViewport\",\n    value: function isRowAfterViewport(row) {\n      return this.rowFilter && row > this.getLastVisibleRow();\n    }\n  }, {\n    key: \"isColumnBeforeViewport\",\n    value: function isColumnBeforeViewport(column) {\n      return this.columnFilter && this.columnFilter.sourceToRendered(column) < 0 && column >= 0;\n    }\n  }, {\n    key: \"isLastRowFullyVisible\",\n    value: function isLastRowFullyVisible() {\n      return this.getLastVisibleRow() === this.getLastRenderedRow();\n    }\n  }, {\n    key: \"isLastColumnFullyVisible\",\n    value: function isLastColumnFullyVisible() {\n      return this.getLastVisibleColumn() === this.getLastRenderedColumn();\n    }\n  }, {\n    key: \"allRowsInViewport\",\n    value: function allRowsInViewport() {\n      return this.wtSettings.getSetting('totalRows') === this.getVisibleRowsCount();\n    }\n  }, {\n    key: \"allColumnsInViewport\",\n    value: function allColumnsInViewport() {\n      return this.wtSettings.getSetting('totalColumns') === this.getVisibleColumnsCount();\n    }\n\n    /**\n     * Checks if any of the row's cells content exceeds its initial height, and if so, returns the oversized height.\n     *\n     * @param {number} sourceRow The physical row index.\n     * @returns {number}\n     */\n  }, {\n    key: \"getRowHeight\",\n    value: function getRowHeight(sourceRow) {\n      return this.rowUtils.getHeight(sourceRow);\n    }\n\n    /**\n     * @param {number} level The column level.\n     * @returns {number}\n     */\n  }, {\n    key: \"getColumnHeaderHeight\",\n    value: function getColumnHeaderHeight(level) {\n      return this.columnUtils.getHeaderHeight(level);\n    }\n\n    /**\n     * @param {number} sourceColumn The physical column index.\n     * @returns {number}\n     */\n  }, {\n    key: \"getColumnWidth\",\n    value: function getColumnWidth(sourceColumn) {\n      return this.columnUtils.getWidth(sourceColumn);\n    }\n\n    /**\n     * @param {number} sourceColumn The physical column index.\n     * @returns {number}\n     */\n  }, {\n    key: \"getStretchedColumnWidth\",\n    value: function getStretchedColumnWidth(sourceColumn) {\n      return this.columnUtils.getStretchedColumnWidth(sourceColumn);\n    }\n\n    /**\n     * Checks if the table has defined size. It returns `true` when the table has width and height\n     * set bigger than `0px`.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"hasDefinedSize\",\n    value: function hasDefinedSize() {\n      return this.hasTableHeight && this.hasTableWidth;\n    }\n\n    /**\n     * Gets table's width. The returned width is the width of the rendered cells that fit in the\n     * current viewport. The value may change depends on the viewport position (scroll position).\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getWidth\",\n    value: function getWidth() {\n      return outerWidth(this.TABLE);\n    }\n\n    /**\n     * Gets table's height. The returned height is the height of the rendered cells that fit in the\n     * current viewport. The value may change depends on the viewport position (scroll position).\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getHeight\",\n    value: function getHeight() {\n      return outerHeight(this.TABLE);\n    }\n\n    /**\n     * Gets table's total width. The returned width is the width of all rendered cells (including headers)\n     * that can be displayed in the table.\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getTotalWidth\",\n    value: function getTotalWidth() {\n      var width = outerWidth(this.hider);\n\n      // when the overlay's table does not have any cells the hider returns 0, get then width from the table element\n      return width !== 0 ? width : this.getWidth();\n    }\n\n    /**\n     * Gets table's total height. The returned height is the height of all rendered cells (including headers)\n     * that can be displayed in the table.\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getTotalHeight\",\n    value: function getTotalHeight() {\n      var height = outerHeight(this.hider);\n\n      // when the overlay's table does not have any cells the hider returns 0, get then height from the table element\n      return height !== 0 ? height : this.getHeight();\n    }\n\n    /**\n     * Checks if the table is visible. It returns `true` when the holder element (or its parents)\n     * has CSS 'display' property different than 'none'.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isVisible\",\n    value: function isVisible() {\n      return _isVisible(this.TABLE);\n    }\n\n    /**\n     * Modify row header widths provided by user in class contructor.\n     *\n     * @private\n     * @param {Function} rowHeaderWidthFactory The function which can provide default width values for rows..\n     * @returns {number}\n     */\n  }, {\n    key: \"_modifyRowHeaderWidth\",\n    value: function _modifyRowHeaderWidth(rowHeaderWidthFactory) {\n      var widths = isFunction(rowHeaderWidthFactory) ? rowHeaderWidthFactory() : null;\n      if (Array.isArray(widths)) {\n        widths = _toConsumableArray(widths);\n        widths[widths.length - 1] = this._correctRowHeaderWidth(widths[widths.length - 1]);\n      } else {\n        widths = this._correctRowHeaderWidth(widths);\n      }\n      return widths;\n    }\n\n    /**\n     * Correct row header width if necessary.\n     *\n     * @private\n     * @param {number} width The width to process.\n     * @returns {number}\n     */\n  }, {\n    key: \"_correctRowHeaderWidth\",\n    value: function _correctRowHeaderWidth(width) {\n      var rowHeaderWidth = width;\n      if (typeof width !== 'number') {\n        rowHeaderWidth = this.wtSettings.getSetting('defaultColumnWidth');\n      }\n      if (this.correctHeaderWidth) {\n        rowHeaderWidth += 1;\n      }\n      return rowHeaderWidth;\n    }\n  }]);\n  return Table;\n}();\nexport default Table;","map":{"version":3,"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","iter","Array","from","isArray","_arrayLikeToArray","_slicedToArray","i","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","o","minLen","n","Object","toString","call","slice","name","test","len","length","arr2","_i","_s","_e","_x","_r","_arr","_n","_d","next","done","push","value","err","return","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","_toPropertyKey","key","_createClass","protoProps","staticProps","_defineProperty","arg","_toPrimitive","String","input","hint","prim","toPrimitive","undefined","res","Number","hasClass","index","offset","removeClass","removeTextNodes","overlayContainsElement","closest","outerHeight","outerWidth","innerHeight","isVisible","_isVisible","isFunction","ColumnFilter","RowFilter","Renderer","ColumnUtils","RowUtils","CLONE_TOP","CLONE_BOTTOM","CLONE_INLINE_START","CLONE_TOP_INLINE_START_CORNER","CLONE_BOTTOM_INLINE_START_CORNER","Table","dataAccessObject","facadeGetter","domBindings","wtSettings","_this","isMaster","wot","TABLE","rootTable","spreader","createSpreader","hider","createHider","holder","createHolder","wtRootElement","parentNode","alignOverlaysWithTrimmingContainer","fixTableDomTree","rowFilter","columnFilter","correctHeaderWidth","origRowHeaderWidth","getSettingPure","update","_modifyRowHeaderWidth","rowUtils","columnUtils","tableRenderer","THEAD","COLGROUP","TBODY","cellRenderer","is","overlayTypeName","rootDocument","querySelector","createElement","appendChild","insertBefore","table","parent","nodeType","Node","ELEMENT_NODE","className","style","position","setAttribute","draw","fastDraw","arguments","_this$dataAccessObjec","wtOverlays","wtViewport","totalRows","getSetting","totalColumns","rowHeaders","rowHeadersCount","columnHeaders","columnHeadersCount","syncScroll","runFastDraw","holderOffset","createRenderCalculators","leftScrollPos","inlineStartOverlay","getScrollPosition","previousState","updateStateOfRendering","createVisibleCalculators","refresh","tableOffset","parentTableOffset","startRow","getFirstRenderedRow","startColumn","getFirstRenderedColumn","performRedraw","skipRender","setHeaderContentRenderers","resetOversizedRows","setViewportSize","getRenderedRowsCount","getRenderedColumnsCount","setFilters","render","workspaceWidth","containerWidth","markOversizedColumnHeaders","adjustColumnHeaderHeights","markOversizedRows","applyToDOM","hiderWidth","tableWidth","calculateWidths","renderer","colGroup","getWorkspaceWidth","cloneSource","adjustElementsSize","positionChanged","topOverlay","resetFixedPosition","bottomOverlay","clone","topInlineStartCornerOverlay","bottomInlineStartCornerOverlay","refreshAll","refreshSelections","syncScrollWithMaster","drawn","markIfOversizedColumnHeader","col","sourceColIndex","renderedToSource","level","defaultRowHeight","previousColHeaderHeight","currentHeader","currentHeaderHeight","columnHeaderHeightSetting","getColumnHeaderHeight","getColumnHeader","oversizedColumnHeaders","isNaN","children","childNodes","height","concat","rowsToRender","visibleRowIndex","sourceRow","oversizedRows","removeClassFromCells","nodes","querySelectorAll","selections","highlights","classesToRemove","_highlights$i$setting","settings","highlightHeaderClassName","highlightRowClassName","highlightColumnClassName","classNames","classNamesLength","j","includes","additionalClassesToRemove","classesToRemoveLength","_i2","_i3","getCell","coords","row","column","hookResult","_hookResult","isRowBeforeRenderedRows","isRowAfterRenderedRows","isColumnBeforeRenderedColumns","isColumnAfterRenderedColumns","TR","getRow","Error","TD","sourceColumnToVisibleRowHeadedColumn","rowIndex","renderedRowIndex","parentElement","_this$rowFilter","sourceRowToVisibleColHeadedRow","_this$rowFilter2","sourceToRendered","getColumnHeaders","THs","visibleColumn","forEach","TH","getRowHeader","getRowHeaders","getCoords","cellElement","nodeName","CONTAINER","cellIndex","visibleColHeadedRowToSourceRow","offsettedTH","visibleRowHeadedColumnToSourceColumn","createCellCoords","rowCount","expectedTableHeight","actualTableHeight","previousRowHeight","rowInnerHeight","sourceRowIndex","currentTr","rowHeader","getRowHeight","getTrForRow","isColumnHeaderRendered","Math","abs","isRowHeaderRendered","first","getLastRenderedRow","getLastRenderedColumn","isColumnAfterViewport","getLastVisibleColumn","isRowAfterViewport","getLastVisibleRow","isColumnBeforeViewport","isLastRowFullyVisible","isLastColumnFullyVisible","allRowsInViewport","getVisibleRowsCount","allColumnsInViewport","getVisibleColumnsCount","getHeight","getHeaderHeight","getColumnWidth","sourceColumn","getWidth","getStretchedColumnWidth","hasDefinedSize","hasTableHeight","hasTableWidth","getTotalWidth","width","getTotalHeight","rowHeaderWidthFactory","widths","_correctRowHeaderWidth","rowHeaderWidth"],"sources":["/home/rstorey/wwwdev/Blucktool/node_modules/handsontable/3rdparty/walkontable/src/table.mjs"],"sourcesContent":["function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.symbol.to-primitive.js\";\nimport \"core-js/modules/es.date.to-primitive.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { hasClass, index, offset, removeClass, removeTextNodes, overlayContainsElement, closest, outerHeight, outerWidth, innerHeight, isVisible as _isVisible } from \"../../../helpers/dom/element.mjs\";\nimport { isFunction } from \"../../../helpers/function.mjs\";\nimport ColumnFilter from \"./filter/column.mjs\";\nimport RowFilter from \"./filter/row.mjs\";\nimport { Renderer } from \"./renderer/index.mjs\";\nimport ColumnUtils from \"./utils/column.mjs\";\nimport RowUtils from \"./utils/row.mjs\";\nimport { CLONE_TOP, CLONE_BOTTOM, CLONE_INLINE_START, CLONE_TOP_INLINE_START_CORNER, CLONE_BOTTOM_INLINE_START_CORNER } from \"./overlay/index.mjs\";\n/**\n * @todo These mixes are never added to the class Table, however their members are used here.\n * @todo Continue: Potentially it works only, because some of these mixes are added to every inherited class.\n * @todo Refactoring, move code from `if(this.isMaster)` into MasterTable, and others like that.\n * @mixes stickyColumnsStart\n * @mixes stickyRowsBottom\n * @mixes stickyRowsTop\n * @mixes calculatedRows\n * @mixes calculatedColumns\n * @abstract\n */\nvar Table = /*#__PURE__*/function () {\n  /**\n   * The walkontable settings.\n   *\n   * @protected\n   * @type {Settings}\n   */\n\n  /**\n   * Indicates if the table has height bigger than 0px.\n   *\n   * @type {boolean}\n   */\n\n  /**\n   * Indicates if the table has width bigger than 0px.\n   *\n   * @type {boolean}\n   */\n\n  /**\n   * Indicates if the table is visible. By visible, it means that the holder\n   * element has CSS 'display' property different than 'none'.\n   *\n   * @type {boolean}\n   */\n\n  /**\n   *\n   * @abstract\n   * @param {TableDao} dataAccessObject The data access object.\n   * @param {FacadeGetter} facadeGetter Function which return proper facade.\n   * @param {DomBindings} domBindings Bindings into DOM.\n   * @param {Settings} wtSettings The Walkontable settings.\n   * @param {'master'|CLONE_TYPES_ENUM} name Overlay name.\n   */\n  function Table(dataAccessObject, facadeGetter, domBindings, wtSettings, name) {\n    var _this = this;\n    _classCallCheck(this, Table);\n    _defineProperty(this, \"wtSettings\", null);\n    _defineProperty(this, \"domBindings\", void 0);\n    _defineProperty(this, \"TBODY\", null);\n    _defineProperty(this, \"THEAD\", null);\n    _defineProperty(this, \"COLGROUP\", null);\n    _defineProperty(this, \"hasTableHeight\", true);\n    _defineProperty(this, \"hasTableWidth\", true);\n    _defineProperty(this, \"isTableVisible\", false);\n    _defineProperty(this, \"tableOffset\", 0);\n    _defineProperty(this, \"holderOffset\", 0);\n    this.domBindings = domBindings;\n    /**\n     * Indicates if this instance is of type `MasterTable` (i.e. It is NOT an overlay).\n     *\n     * @type {boolean}\n     */\n    this.isMaster = name === 'master';\n    this.name = name;\n    this.dataAccessObject = dataAccessObject;\n    this.facadeGetter = facadeGetter;\n    this.wtSettings = wtSettings;\n\n    // legacy support\n    this.instance = this.dataAccessObject.wot; // TODO refactoring: it might be removed here, and provides legacy support through facade.\n    this.wot = this.dataAccessObject.wot;\n    this.TABLE = domBindings.rootTable;\n    removeTextNodes(this.TABLE);\n\n    // TODO refactoring, to recognize the legitimacy of moving them into domBidings\n    this.spreader = this.createSpreader(this.TABLE);\n    this.hider = this.createHider(this.spreader);\n    this.holder = this.createHolder(this.hider);\n    this.wtRootElement = this.holder.parentNode;\n    if (this.isMaster) {\n      this.alignOverlaysWithTrimmingContainer(); // todo wow, It calls method from child class (MasterTable).\n    }\n\n    this.fixTableDomTree();\n    this.rowFilter = null; // TODO refactoring, eliminate all (re)creations of this object, then updates state when needed.\n    this.columnFilter = null; // TODO refactoring, eliminate all (re)creations of this object, then updates state when needed.\n    this.correctHeaderWidth = false;\n    var origRowHeaderWidth = this.wtSettings.getSettingPure('rowHeaderWidth');\n\n    // Fix for jumping row headers (https://github.com/handsontable/handsontable/issues/3850)\n    this.wtSettings.update('rowHeaderWidth', function () {\n      return _this._modifyRowHeaderWidth(origRowHeaderWidth);\n    });\n    this.rowUtils = new RowUtils(this.dataAccessObject, this.wtSettings); // TODO refactoring, It can be passed through IOC.\n    this.columnUtils = new ColumnUtils(this.dataAccessObject, this.wtSettings); // TODO refactoring, It can be passed through IOC.\n\n    this.tableRenderer = new Renderer({\n      // TODO refactoring, It can be passed through IOC.\n      TABLE: this.TABLE,\n      THEAD: this.THEAD,\n      COLGROUP: this.COLGROUP,\n      TBODY: this.TBODY,\n      rowUtils: this.rowUtils,\n      columnUtils: this.columnUtils,\n      cellRenderer: this.wtSettings.getSettingPure('cellRenderer')\n    });\n  }\n\n  /**\n   * Returns a boolean that is true if this Table represents a specific overlay, identified by the overlay name.\n   * For MasterTable, it returns false.\n   *\n   * @param {string} overlayTypeName The overlay type.\n   * @returns {boolean}\n   */\n  _createClass(Table, [{\n    key: \"is\",\n    value: function is(overlayTypeName) {\n      // todo refactoring: eliminate all protected and private usages\n      return this.name === overlayTypeName;\n    }\n\n    /**\n     *\n     */\n  }, {\n    key: \"fixTableDomTree\",\n    value: function fixTableDomTree() {\n      var rootDocument = this.domBindings.rootDocument;\n      this.TBODY = this.TABLE.querySelector('tbody');\n      if (!this.TBODY) {\n        this.TBODY = rootDocument.createElement('tbody');\n        this.TABLE.appendChild(this.TBODY);\n      }\n      this.THEAD = this.TABLE.querySelector('thead');\n      if (!this.THEAD) {\n        this.THEAD = rootDocument.createElement('thead');\n        this.TABLE.insertBefore(this.THEAD, this.TBODY);\n      }\n      this.COLGROUP = this.TABLE.querySelector('colgroup');\n      if (!this.COLGROUP) {\n        this.COLGROUP = rootDocument.createElement('colgroup');\n        this.TABLE.insertBefore(this.COLGROUP, this.THEAD);\n      }\n    }\n\n    /**\n     * @param {HTMLTableElement} table An element to process.\n     * @returns {HTMLElement}\n     */\n  }, {\n    key: \"createSpreader\",\n    value: function createSpreader(table) {\n      var parent = table.parentNode;\n      var spreader;\n      if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, 'wtHolder')) {\n        spreader = this.domBindings.rootDocument.createElement('div');\n        spreader.className = 'wtSpreader';\n        if (parent) {\n          // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n          parent.insertBefore(spreader, table);\n        }\n        spreader.appendChild(table);\n      }\n      spreader.style.position = 'relative';\n      return spreader;\n    }\n\n    /**\n     * @param {HTMLElement} spreader An element to the hider element is injected.\n     * @returns {HTMLElement}\n     */\n  }, {\n    key: \"createHider\",\n    value: function createHider(spreader) {\n      var parent = spreader.parentNode;\n      var hider;\n      if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, 'wtHolder')) {\n        hider = this.domBindings.rootDocument.createElement('div');\n        hider.className = 'wtHider';\n        if (parent) {\n          // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n          parent.insertBefore(hider, spreader);\n        }\n        hider.appendChild(spreader);\n      }\n      return hider;\n    }\n\n    /**\n     *\n     * @param {HTMLElement} hider An element to the holder element is injected.\n     * @returns {HTMLElement}\n     */\n  }, {\n    key: \"createHolder\",\n    value: function createHolder(hider) {\n      var parent = hider.parentNode;\n      var holder;\n      if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, 'wtHolder')) {\n        holder = this.domBindings.rootDocument.createElement('div');\n        holder.style.position = 'relative';\n        holder.className = 'wtHolder';\n        if (parent) {\n          // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n          parent.insertBefore(holder, hider);\n        }\n        if (this.isMaster) {\n          holder.parentNode.className += 'ht_master handsontable';\n          holder.parentNode.setAttribute('dir', this.wtSettings.getSettingPure('rtlMode') ? 'rtl' : 'ltr');\n        }\n        holder.appendChild(hider);\n      }\n      return holder;\n    }\n\n    /**\n     * Redraws the table.\n     *\n     * @param {boolean} [fastDraw=false] If TRUE, will try to avoid full redraw and only update the border positions.\n     *                                   If FALSE or UNDEFINED, will perform a full redraw.\n     * @returns {Table}\n     */\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var wtSettings = this.wtSettings;\n      var _this$dataAccessObjec = this.dataAccessObject,\n        wtOverlays = _this$dataAccessObjec.wtOverlays,\n        wtViewport = _this$dataAccessObjec.wtViewport;\n      var totalRows = wtSettings.getSetting('totalRows');\n      var totalColumns = wtSettings.getSetting('totalColumns');\n      var rowHeaders = wtSettings.getSetting('rowHeaders');\n      var rowHeadersCount = rowHeaders.length;\n      var columnHeaders = wtSettings.getSetting('columnHeaders');\n      var columnHeadersCount = columnHeaders.length;\n      var syncScroll = false;\n      var runFastDraw = fastDraw;\n      if (this.isMaster) {\n        this.holderOffset = offset(this.holder);\n        runFastDraw = wtViewport.createRenderCalculators(runFastDraw);\n        if (rowHeadersCount && !wtSettings.getSetting('fixedColumnsStart')) {\n          var leftScrollPos = wtOverlays.inlineStartOverlay.getScrollPosition();\n          var previousState = this.correctHeaderWidth;\n          this.correctHeaderWidth = leftScrollPos !== 0;\n          if (previousState !== this.correctHeaderWidth) {\n            runFastDraw = false;\n          }\n        }\n      }\n      if (this.isMaster) {\n        syncScroll = wtOverlays.updateStateOfRendering();\n      }\n      if (runFastDraw) {\n        if (this.isMaster) {\n          // in case we only scrolled without redraw, update visible rows information in oldRowsCalculator\n          wtViewport.createVisibleCalculators();\n        }\n        if (wtOverlays) {\n          wtOverlays.refresh(true);\n        }\n      } else {\n        if (this.isMaster) {\n          this.tableOffset = offset(this.TABLE);\n        } else {\n          this.tableOffset = this.dataAccessObject.parentTableOffset;\n        }\n        var startRow = totalRows > 0 ? this.getFirstRenderedRow() : 0;\n        var startColumn = totalColumns > 0 ? this.getFirstRenderedColumn() : 0;\n        this.rowFilter = new RowFilter(startRow, totalRows, columnHeadersCount);\n        this.columnFilter = new ColumnFilter(startColumn, totalColumns, rowHeadersCount);\n        var performRedraw = true;\n\n        // Only master table rendering can be skipped\n        if (this.isMaster) {\n          this.alignOverlaysWithTrimmingContainer(); // todo It calls method from child class (MasterTable).\n          var skipRender = {};\n          this.wtSettings.getSetting('beforeDraw', true, skipRender);\n          performRedraw = skipRender.skipRender !== true;\n        }\n        if (performRedraw) {\n          this.tableRenderer.setHeaderContentRenderers(rowHeaders, columnHeaders);\n          if (this.is(CLONE_BOTTOM) || this.is(CLONE_BOTTOM_INLINE_START_CORNER)) {\n            // do NOT render headers on the bottom or bottom-left corner overlay\n            this.tableRenderer.setHeaderContentRenderers(rowHeaders, []);\n          }\n          this.resetOversizedRows();\n          this.tableRenderer.setViewportSize(this.getRenderedRowsCount(), this.getRenderedColumnsCount()).setFilters(this.rowFilter, this.columnFilter).render();\n          var workspaceWidth;\n          if (this.isMaster) {\n            workspaceWidth = this.dataAccessObject.workspaceWidth;\n            this.dataAccessObject.wtViewport.containerWidth = null;\n            this.markOversizedColumnHeaders();\n          }\n          this.adjustColumnHeaderHeights();\n          if (this.isMaster || this.is(CLONE_BOTTOM)) {\n            this.markOversizedRows();\n          }\n          if (this.isMaster) {\n            this.dataAccessObject.wtViewport.createVisibleCalculators();\n            this.dataAccessObject.wtOverlays.refresh(false);\n            this.dataAccessObject.wtOverlays.applyToDOM();\n            var hiderWidth = outerWidth(this.hider);\n            var tableWidth = outerWidth(this.TABLE);\n            if (hiderWidth !== 0 && tableWidth !== hiderWidth) {\n              // Recalculate the column widths, if width changes made in the overlays removed the scrollbar, thus changing the viewport width.\n              this.columnUtils.calculateWidths();\n              this.tableRenderer.renderer.colGroup.render();\n            }\n            if (workspaceWidth !== this.dataAccessObject.wtViewport.getWorkspaceWidth()) {\n              // workspace width changed though to shown/hidden vertical scrollbar. Let's reapply stretching\n              this.dataAccessObject.wtViewport.containerWidth = null;\n              this.columnUtils.calculateWidths();\n              this.tableRenderer.renderer.colGroup.render();\n            }\n            this.wtSettings.getSetting('onDraw', true);\n          } else if (this.is(CLONE_BOTTOM)) {\n            this.dataAccessObject.cloneSource.wtOverlays.adjustElementsSize();\n          }\n        }\n      }\n      var positionChanged = false;\n      if (this.isMaster) {\n        positionChanged = wtOverlays.topOverlay.resetFixedPosition();\n        if (wtOverlays.bottomOverlay.clone) {\n          positionChanged = wtOverlays.bottomOverlay.resetFixedPosition() || positionChanged;\n        }\n        positionChanged = wtOverlays.inlineStartOverlay.resetFixedPosition() || positionChanged;\n        if (wtOverlays.topInlineStartCornerOverlay) {\n          wtOverlays.topInlineStartCornerOverlay.resetFixedPosition();\n        }\n        if (wtOverlays.bottomInlineStartCornerOverlay && wtOverlays.bottomInlineStartCornerOverlay.clone) {\n          wtOverlays.bottomInlineStartCornerOverlay.resetFixedPosition();\n        }\n      }\n      if (positionChanged) {\n        // It refreshes the cells borders caused by a 1px shift (introduced by overlays which add or\n        // remove `innerBorderTop` and `innerBorderInlineStart` CSS classes to the DOM element. This happens\n        // when there is a switch between rendering from 0 to N rows/columns and vice versa).\n        wtOverlays.refreshAll(); // `refreshAll()` internally already calls `refreshSelections()` method\n        wtOverlays.adjustElementsSize();\n      } else {\n        this.refreshSelections(runFastDraw);\n      }\n      if (syncScroll) {\n        wtOverlays.syncScrollWithMaster();\n      }\n      this.dataAccessObject.drawn = true;\n      return this;\n    }\n\n    /**\n     * @param {number} col The visual column index.\n     */\n  }, {\n    key: \"markIfOversizedColumnHeader\",\n    value: function markIfOversizedColumnHeader(col) {\n      var sourceColIndex = this.columnFilter.renderedToSource(col);\n      var level = this.wtSettings.getSetting('columnHeaders').length;\n      var defaultRowHeight = this.wtSettings.getSetting('defaultRowHeight');\n      var previousColHeaderHeight;\n      var currentHeader;\n      var currentHeaderHeight;\n      var columnHeaderHeightSetting = this.wtSettings.getSetting('columnHeaderHeight') || [];\n      while (level) {\n        level -= 1;\n        previousColHeaderHeight = this.getColumnHeaderHeight(level);\n        currentHeader = this.getColumnHeader(sourceColIndex, level);\n        if (!currentHeader) {\n          /* eslint-disable no-continue */\n          continue;\n        }\n        currentHeaderHeight = innerHeight(currentHeader);\n        if (!previousColHeaderHeight && defaultRowHeight < currentHeaderHeight || previousColHeaderHeight < currentHeaderHeight) {\n          this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] = currentHeaderHeight;\n        }\n        if (Array.isArray(columnHeaderHeightSetting)) {\n          if (columnHeaderHeightSetting[level] !== null && columnHeaderHeightSetting[level] !== void 0) {\n            this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting[level];\n          }\n        } else if (!isNaN(columnHeaderHeightSetting)) {\n          this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting;\n        }\n        if (this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] < (columnHeaderHeightSetting[level] || columnHeaderHeightSetting)) {\n          this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting[level] || columnHeaderHeightSetting; // eslint-disable-line max-len\n        }\n      }\n    }\n\n    /**\n     *\n     */\n  }, {\n    key: \"adjustColumnHeaderHeights\",\n    value: function adjustColumnHeaderHeights() {\n      var wtSettings = this.wtSettings;\n      var children = this.THEAD.childNodes;\n      var oversizedColumnHeaders = this.dataAccessObject.wtViewport.oversizedColumnHeaders;\n      var columnHeaders = wtSettings.getSetting('columnHeaders');\n      for (var i = 0, len = columnHeaders.length; i < len; i++) {\n        if (oversizedColumnHeaders[i]) {\n          if (!children[i] || children[i].childNodes.length === 0) {\n            return;\n          }\n          children[i].childNodes[0].style.height = \"\".concat(oversizedColumnHeaders[i], \"px\");\n        }\n      }\n    }\n\n    /**\n     * Resets cache of row heights. The cache should be cached for each render cycle in a case\n     * when new cell values have content which increases/decreases cell height.\n     */\n  }, {\n    key: \"resetOversizedRows\",\n    value: function resetOversizedRows() {\n      var wtSettings = this.wtSettings;\n      var wtViewport = this.dataAccessObject.wtViewport;\n      if (!this.isMaster && !this.is(CLONE_BOTTOM)) {\n        return;\n      }\n      if (!wtSettings.getSetting('externalRowCalculator')) {\n        var rowsToRender = this.getRenderedRowsCount();\n\n        // Reset the oversized row cache for rendered rows\n        for (var visibleRowIndex = 0; visibleRowIndex < rowsToRender; visibleRowIndex++) {\n          var sourceRow = this.rowFilter.renderedToSource(visibleRowIndex);\n          if (wtViewport.oversizedRows && wtViewport.oversizedRows[sourceRow]) {\n            wtViewport.oversizedRows[sourceRow] = void 0;\n          }\n        }\n      }\n    }\n\n    /**\n     * @param {string} className The CSS class name to remove from the table cells.\n     */\n  }, {\n    key: \"removeClassFromCells\",\n    value: function removeClassFromCells(className) {\n      var nodes = this.TABLE.querySelectorAll(\".\".concat(className));\n      for (var i = 0, len = nodes.length; i < len; i++) {\n        removeClass(nodes[i], className);\n      }\n    }\n\n    /**\n     * Refresh the table selection by re-rendering Selection instances connected with that instance.\n     *\n     * @param {boolean} fastDraw If fast drawing is enabled than additionally className clearing is applied.\n     */\n  }, {\n    key: \"refreshSelections\",\n    value: function refreshSelections(fastDraw) {\n      var wtSettings = this.wtSettings;\n      var selections = this.dataAccessObject.selections;\n      if (!selections) {\n        return;\n      }\n      var highlights = Array.from(selections);\n      var len = highlights.length;\n      if (fastDraw) {\n        var classesToRemove = [];\n        for (var i = 0; i < len; i++) {\n          var _highlights$i$setting = highlights[i].settings,\n            highlightHeaderClassName = _highlights$i$setting.highlightHeaderClassName,\n            highlightRowClassName = _highlights$i$setting.highlightRowClassName,\n            highlightColumnClassName = _highlights$i$setting.highlightColumnClassName;\n          var classNames = highlights[i].classNames;\n          var classNamesLength = classNames.length;\n          for (var j = 0; j < classNamesLength; j++) {\n            if (!classesToRemove.includes(classNames[j])) {\n              classesToRemove.push(classNames[j]);\n            }\n          }\n          if (highlightHeaderClassName && !classesToRemove.includes(highlightHeaderClassName)) {\n            classesToRemove.push(highlightHeaderClassName);\n          }\n          if (highlightRowClassName && !classesToRemove.includes(highlightRowClassName)) {\n            classesToRemove.push(highlightRowClassName);\n          }\n          if (highlightColumnClassName && !classesToRemove.includes(highlightColumnClassName)) {\n            classesToRemove.push(highlightColumnClassName);\n          }\n        }\n        var additionalClassesToRemove = wtSettings.getSetting('onBeforeRemoveCellClassNames');\n        if (Array.isArray(additionalClassesToRemove)) {\n          for (var _i = 0; _i < additionalClassesToRemove.length; _i++) {\n            classesToRemove.push(additionalClassesToRemove[_i]);\n          }\n        }\n        var classesToRemoveLength = classesToRemove.length;\n        for (var _i2 = 0; _i2 < classesToRemoveLength; _i2++) {\n          // there was no rerender, so we need to remove classNames by ourselves\n          this.removeClassFromCells(classesToRemove[_i2]);\n        }\n      }\n      for (var _i3 = 0; _i3 < len; _i3++) {\n        highlights[_i3].draw(this.facadeGetter(), fastDraw);\n      }\n    }\n\n    /**\n     * Get cell element at coords.\n     * Negative coords.row or coords.col are used to retrieve header cells. If there are multiple header levels, the\n     * negative value corresponds to the distance from the working area. For example, when there are 3 levels of column\n     * headers, coords.col=-1 corresponds to the most inner header element, while coords.col=-3 corresponds to the\n     * outmost header element.\n     *\n     * In case an element for the coords is not rendered, the method returns an error code.\n     * To produce the error code, the input parameters are validated in the order in which they\n     * are given. Thus, if both the row and the column coords are out of the rendered bounds,\n     * the method returns the error code for the row.\n     *\n     * @param {CellCoords} coords The cell coordinates.\n     * @returns {HTMLElement|number} HTMLElement on success or Number one of the exit codes on error:\n     *  -1 row before viewport\n     *  -2 row after viewport\n     *  -3 column before viewport\n     *  -4 column after viewport.\n     */\n  }, {\n    key: \"getCell\",\n    value: function getCell(coords) {\n      var row = coords.row;\n      var column = coords.col;\n      var hookResult = this.wtSettings.getSetting('onModifyGetCellCoords', row, column);\n      if (hookResult && Array.isArray(hookResult)) {\n        var _hookResult = _slicedToArray(hookResult, 2);\n        row = _hookResult[0];\n        column = _hookResult[1];\n      }\n      if (this.isRowBeforeRenderedRows(row)) {\n        // row before rendered rows\n        return -1;\n      } else if (this.isRowAfterRenderedRows(row)) {\n        // row after rendered rows\n        return -2;\n      } else if (this.isColumnBeforeRenderedColumns(column)) {\n        // column before rendered columns\n        return -3;\n      } else if (this.isColumnAfterRenderedColumns(column)) {\n        // column after rendered columns\n        return -4;\n      }\n      var TR = this.getRow(row);\n      if (!TR && row >= 0) {\n        throw new Error('TR was expected to be rendered but is not');\n      }\n      var TD = TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(column)];\n      if (!TD && column >= 0) {\n        throw new Error('TD or TH was expected to be rendered but is not');\n      }\n      return TD;\n    }\n\n    /**\n     * Get the DOM element of the row with the provided index.\n     *\n     * @param {number} rowIndex Row index.\n     * @returns {HTMLTableRowElement|boolean} Return the row's DOM element or `false` if the row with the provided\n     * index doesn't exist.\n     */\n  }, {\n    key: \"getRow\",\n    value: function getRow(rowIndex) {\n      var renderedRowIndex = null;\n      var parentElement = null;\n      if (rowIndex < 0) {\n        var _this$rowFilter;\n        renderedRowIndex = (_this$rowFilter = this.rowFilter) === null || _this$rowFilter === void 0 ? void 0 : _this$rowFilter.sourceRowToVisibleColHeadedRow(rowIndex);\n        parentElement = this.THEAD;\n      } else {\n        var _this$rowFilter2;\n        renderedRowIndex = (_this$rowFilter2 = this.rowFilter) === null || _this$rowFilter2 === void 0 ? void 0 : _this$rowFilter2.sourceToRendered(rowIndex);\n        parentElement = this.TBODY;\n      }\n      if (renderedRowIndex !== void 0 && parentElement !== void 0) {\n        if (parentElement.childNodes.length < renderedRowIndex + 1) {\n          return false;\n        } else {\n          return parentElement.childNodes[renderedRowIndex];\n        }\n      } else {\n        return false;\n      }\n    }\n\n    /**\n     * GetColumnHeader.\n     *\n     * @param {number} col Column index.\n     * @param {number} [level=0] Header level (0 = most distant to the table).\n     * @returns {object} HTMLElement on success or undefined on error.\n     */\n  }, {\n    key: \"getColumnHeader\",\n    value: function getColumnHeader(col) {\n      var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var TR = this.THEAD.childNodes[level];\n      return TR === null || TR === void 0 ? void 0 : TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(col)];\n    }\n\n    /**\n     * Gets all columns headers (TH elements) from the table.\n     *\n     * @param {number} column A source column index.\n     * @returns {HTMLTableCellElement[]}\n     */\n  }, {\n    key: \"getColumnHeaders\",\n    value: function getColumnHeaders(column) {\n      var THs = [];\n      var visibleColumn = this.columnFilter.sourceColumnToVisibleRowHeadedColumn(column);\n      this.THEAD.childNodes.forEach(function (TR) {\n        var TH = TR.childNodes[visibleColumn];\n        if (TH) {\n          THs.push(TH);\n        }\n      });\n      return THs;\n    }\n\n    /**\n     * GetRowHeader.\n     *\n     * @param {number} row Row index.\n     * @param {number} [level=0] Header level (0 = most distant to the table).\n     * @returns {HTMLElement} HTMLElement on success or Number one of the exit codes on error: `null table doesn't have row headers`.\n     */\n  }, {\n    key: \"getRowHeader\",\n    value: function getRowHeader(row) {\n      var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      if (this.columnFilter.sourceColumnToVisibleRowHeadedColumn(0) === 0) {\n        return;\n      }\n      var rowHeadersCount = this.wtSettings.getSetting('rowHeaders').length;\n      if (level >= rowHeadersCount) {\n        return;\n      }\n      var TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n      return TR === null || TR === void 0 ? void 0 : TR.childNodes[level];\n    }\n\n    /**\n     * Gets all rows headers (TH elements) from the table.\n     *\n     * @param {number} row A source row index.\n     * @returns {HTMLTableCellElement[]}\n     */\n  }, {\n    key: \"getRowHeaders\",\n    value: function getRowHeaders(row) {\n      if (this.columnFilter.sourceColumnToVisibleRowHeadedColumn(0) === 0) {\n        return [];\n      }\n      var THs = [];\n      var rowHeadersCount = this.wtSettings.getSetting('rowHeaders').length;\n      for (var renderedRowIndex = 0; renderedRowIndex < rowHeadersCount; renderedRowIndex++) {\n        var TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n        var TH = TR === null || TR === void 0 ? void 0 : TR.childNodes[renderedRowIndex];\n        if (TH) {\n          THs.push(TH);\n        }\n      }\n      return THs;\n    }\n\n    /**\n     * Returns cell coords object for a given TD (or a child element of a TD element).\n     *\n     * @param {HTMLTableCellElement} TD A cell DOM element (or a child of one).\n     * @returns {CellCoords|null} The coordinates of the provided TD element (or the closest TD element) or null, if the provided element is not applicable.\n     */\n  }, {\n    key: \"getCoords\",\n    value: function getCoords(TD) {\n      var cellElement = TD;\n      if (cellElement.nodeName !== 'TD' && cellElement.nodeName !== 'TH') {\n        cellElement = closest(cellElement, ['TD', 'TH']);\n      }\n      if (cellElement === null) {\n        return null;\n      }\n      var TR = cellElement.parentNode;\n      var CONTAINER = TR.parentNode;\n      var row = index(TR);\n      var col = cellElement.cellIndex;\n      if (overlayContainsElement(CLONE_TOP_INLINE_START_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_TOP, cellElement, this.wtRootElement)) {\n        if (CONTAINER.nodeName === 'THEAD') {\n          row -= CONTAINER.childNodes.length;\n        }\n      } else if (overlayContainsElement(CLONE_BOTTOM_INLINE_START_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_BOTTOM, cellElement, this.wtRootElement)) {\n        var totalRows = this.wtSettings.getSetting('totalRows');\n        row = totalRows - CONTAINER.childNodes.length + row;\n      } else if (CONTAINER === this.THEAD) {\n        row = this.rowFilter.visibleColHeadedRowToSourceRow(row);\n      } else {\n        row = this.rowFilter.renderedToSource(row);\n      }\n      if (overlayContainsElement(CLONE_TOP_INLINE_START_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_INLINE_START, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_BOTTOM_INLINE_START_CORNER, cellElement, this.wtRootElement)) {\n        col = this.columnFilter.offsettedTH(col);\n      } else {\n        col = this.columnFilter.visibleRowHeadedColumnToSourceColumn(col);\n      }\n      return this.wot.createCellCoords(row, col);\n    }\n\n    /**\n     * Check if any of the rendered rows is higher than expected, and if so, cache them.\n     */\n  }, {\n    key: \"markOversizedRows\",\n    value: function markOversizedRows() {\n      if (this.wtSettings.getSetting('externalRowCalculator')) {\n        return;\n      }\n      var rowCount = this.TBODY.childNodes.length;\n      var expectedTableHeight = rowCount * this.wtSettings.getSetting('defaultRowHeight');\n      var actualTableHeight = innerHeight(this.TBODY) - 1;\n      var previousRowHeight;\n      var rowInnerHeight;\n      var sourceRowIndex;\n      var currentTr;\n      var rowHeader;\n      if (expectedTableHeight === actualTableHeight && !this.wtSettings.getSetting('fixedRowsBottom')) {\n        // If the actual table height equals rowCount * default single row height, no row is oversized -> no need to iterate over them\n        return;\n      }\n      while (rowCount) {\n        rowCount -= 1;\n        sourceRowIndex = this.rowFilter.renderedToSource(rowCount);\n        previousRowHeight = this.getRowHeight(sourceRowIndex);\n        currentTr = this.getTrForRow(sourceRowIndex);\n        rowHeader = currentTr.querySelector('th');\n        if (rowHeader) {\n          rowInnerHeight = innerHeight(rowHeader);\n        } else {\n          rowInnerHeight = innerHeight(currentTr) - 1;\n        }\n        if (!previousRowHeight && this.wtSettings.getSetting('defaultRowHeight') < rowInnerHeight || previousRowHeight < rowInnerHeight) {\n          rowInnerHeight += 1;\n          this.dataAccessObject.wtViewport.oversizedRows[sourceRowIndex] = rowInnerHeight;\n        }\n      }\n    }\n\n    /**\n     * @param {number} row The visual row index.\n     * @returns {HTMLTableElement}\n     */\n  }, {\n    key: \"getTrForRow\",\n    value: function getTrForRow(row) {\n      return this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n    }\n\n    /**\n     * Checks if the column index (negative value from -1 to N) is rendered.\n     *\n     * @param {number} column The column index (negative value from -1 to N).\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isColumnHeaderRendered\",\n    value: function isColumnHeaderRendered(column) {\n      if (column >= 0) {\n        return false;\n      }\n      var rowHeaders = this.wtSettings.getSetting('rowHeaders');\n      var rowHeadersCount = rowHeaders.length;\n      return Math.abs(column) <= rowHeadersCount;\n    }\n\n    /**\n     * Checks if the row index (negative value from -1 to N) is rendered.\n     *\n     * @param {number} row The row index (negative value from -1 to N).\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isRowHeaderRendered\",\n    value: function isRowHeaderRendered(row) {\n      if (row >= 0) {\n        return false;\n      }\n      var columnHeaders = this.wtSettings.getSetting('columnHeaders');\n      var columnHeadersCount = columnHeaders.length;\n      return Math.abs(row) <= columnHeadersCount;\n    }\n\n    /* eslint-disable jsdoc/require-description-complete-sentence */\n    /**\n     * Check if the given row index is lower than the index of the first row that\n     * is currently rendered and return TRUE in that case, or FALSE otherwise.\n     *\n     * Negative row index is used to check the columns' headers.\n     *\n     *  Headers\n     *           +--------------+                                     │\n     *       -3  │    │    │    │                                     │\n     *           +--------------+                                     │\n     *       -2  │    │    │    │                                     │ TRUE\n     *           +--------------+                                     │\n     *       -1  │    │    │    │                                     │\n     *  Cells  +==================+                                   │\n     *        0  ┇    ┇    ┇    ┇ <--- For fixedRowsTop: 1            │\n     *           +--------------+      the master overlay do       ---+ first rendered row (index 1)\n     *        1  │ A2 │ B2 │ C2 │      not render the first row.      │\n     *           +--------------+                                     │ FALSE\n     *        2  │ A3 │ B3 │ C3 │                                     │\n     *           +--------------+                                  ---+ last rendered row\n     *                                                                │\n     *                                                                │ FALSE\n     *\n     * @param {number} row The visual row index.\n     * @memberof Table#\n     * @function isRowBeforeRenderedRows\n     * @returns {boolean}\n     */\n    /* eslint-enable jsdoc/require-description-complete-sentence */\n  }, {\n    key: \"isRowBeforeRenderedRows\",\n    value: function isRowBeforeRenderedRows(row) {\n      var first = this.getFirstRenderedRow();\n\n      // Check the headers only in case when the first rendered row is -1 or 0.\n      // This is an indication that the overlay is placed on the most top position.\n      if (row < 0 && first <= 0) {\n        return !this.isRowHeaderRendered(row);\n      }\n      return row < first;\n    }\n\n    /* eslint-disable jsdoc/require-description-complete-sentence */\n    /**\n     * Check if the given column index is greater than the index of the last column that\n     * is currently rendered and return TRUE in that case, or FALSE otherwise.\n     *\n     * The negative row index is used to check the columns' headers. However,\n     * keep in mind that for negative indexes, the method always returns FALSE as\n     * it is not possible to render headers partially. The \"after\" index can not be\n     * lower than -1.\n     *\n     *  Headers\n     *           +--------------+                                     │\n     *       -3  │    │    │    │                                     │\n     *           +--------------+                                     │\n     *       -2  │    │    │    │                                     │ FALSE\n     *           +--------------+                                     │\n     *       -1  │    │    │    │                                     │\n     *  Cells  +==================+                                   │\n     *        0  ┇    ┇    ┇    ┇ <--- For fixedRowsTop: 1            │\n     *           +--------------+      the master overlay do       ---+ first rendered row (index 1)\n     *        1  │ A2 │ B2 │ C2 │      not render the first rows      │\n     *           +--------------+                                     │ FALSE\n     *        2  │ A3 │ B3 │ C3 │                                     │\n     *           +--------------+                                  ---+ last rendered row\n     *                                                                │\n     *                                                                │ TRUE\n     *\n     * @param {number} row The visual row index.\n     * @memberof Table#\n     * @function isRowAfterRenderedRows\n     * @returns {boolean}\n     */\n    /* eslint-enable jsdoc/require-description-complete-sentence */\n  }, {\n    key: \"isRowAfterRenderedRows\",\n    value: function isRowAfterRenderedRows(row) {\n      return row > this.getLastRenderedRow();\n    }\n\n    /* eslint-disable jsdoc/require-description-complete-sentence */\n    /**\n     * Check if the given column index is lower than the index of the first column that\n     * is currently rendered and return TRUE in that case, or FALSE otherwise.\n     *\n     * Negative column index is used to check the rows' headers.\n     *\n     *                            For fixedColumnsStart: 1 the master overlay\n     *                            do not render this first columns.\n     *  Headers    -3   -2   -1    |\n     *           +----+----+----║┄ ┄ +------+------+\n     *           │    │    │    ║    │  B1  │  C1  │\n     *           +--------------║┄ ┄ --------------│\n     *           │    │    │    ║    │  B2  │  C2  │\n     *           +--------------║┄ ┄ --------------│\n     *           │    │    │    ║    │  B3  │  C3  │\n     *           +----+----+----║┄ ┄ +------+------+\n     *                               ╷             ╷\n     *      -------------------------+-------------+---------------->\n     *          TRUE             first    FALSE   last         FALSE\n     *                           rendered         rendered\n     *                           column           column\n     *\n     * @param {number} column The visual column index.\n     * @memberof Table#\n     * @function isColumnBeforeRenderedColumns\n     * @returns {boolean}\n     */\n    /* eslint-enable jsdoc/require-description-complete-sentence */\n  }, {\n    key: \"isColumnBeforeRenderedColumns\",\n    value: function isColumnBeforeRenderedColumns(column) {\n      var first = this.getFirstRenderedColumn();\n\n      // Check the headers only in case when the first rendered column is -1 or 0.\n      // This is an indication that the overlay is placed on the most left position.\n      if (column < 0 && first <= 0) {\n        return !this.isColumnHeaderRendered(column);\n      }\n      return column < first;\n    }\n\n    /* eslint-disable jsdoc/require-description-complete-sentence */\n    /**\n     * Check if the given column index is greater than the index of the last column that\n     * is currently rendered and return TRUE in that case, or FALSE otherwise.\n     *\n     * The negative column index is used to check the rows' headers. However,\n     * keep in mind that for negative indexes, the method always returns FALSE as\n     * it is not possible to render headers partially. The \"after\" index can not be\n     * lower than -1.\n     *\n     *                            For fixedColumnsStart: 1 the master overlay\n     *                            do not render this first columns.\n     *  Headers    -3   -2   -1    |\n     *           +----+----+----║┄ ┄ +------+------+\n     *           │    │    │    ║    │  B1  │  C1  │\n     *           +--------------║┄ ┄ --------------│\n     *           │    │    │    ║    │  B2  │  C2  │\n     *           +--------------║┄ ┄ --------------│\n     *           │    │    │    ║    │  B3  │  C3  │\n     *           +----+----+----║┄ ┄ +------+------+\n     *                               ╷             ╷\n     *      -------------------------+-------------+---------------->\n     *          FALSE             first    FALSE   last         TRUE\n     *                           rendered         rendered\n     *                           column           column\n     *\n     * @param {number} column The visual column index.\n     * @memberof Table#\n     * @function isColumnAfterRenderedColumns\n     * @returns {boolean}\n     */\n    /* eslint-enable jsdoc/require-description-complete-sentence */\n  }, {\n    key: \"isColumnAfterRenderedColumns\",\n    value: function isColumnAfterRenderedColumns(column) {\n      return this.columnFilter && column > this.getLastRenderedColumn();\n    }\n  }, {\n    key: \"isColumnAfterViewport\",\n    value: function isColumnAfterViewport(column) {\n      return this.columnFilter && column > this.getLastVisibleColumn();\n    }\n  }, {\n    key: \"isRowAfterViewport\",\n    value: function isRowAfterViewport(row) {\n      return this.rowFilter && row > this.getLastVisibleRow();\n    }\n  }, {\n    key: \"isColumnBeforeViewport\",\n    value: function isColumnBeforeViewport(column) {\n      return this.columnFilter && this.columnFilter.sourceToRendered(column) < 0 && column >= 0;\n    }\n  }, {\n    key: \"isLastRowFullyVisible\",\n    value: function isLastRowFullyVisible() {\n      return this.getLastVisibleRow() === this.getLastRenderedRow();\n    }\n  }, {\n    key: \"isLastColumnFullyVisible\",\n    value: function isLastColumnFullyVisible() {\n      return this.getLastVisibleColumn() === this.getLastRenderedColumn();\n    }\n  }, {\n    key: \"allRowsInViewport\",\n    value: function allRowsInViewport() {\n      return this.wtSettings.getSetting('totalRows') === this.getVisibleRowsCount();\n    }\n  }, {\n    key: \"allColumnsInViewport\",\n    value: function allColumnsInViewport() {\n      return this.wtSettings.getSetting('totalColumns') === this.getVisibleColumnsCount();\n    }\n\n    /**\n     * Checks if any of the row's cells content exceeds its initial height, and if so, returns the oversized height.\n     *\n     * @param {number} sourceRow The physical row index.\n     * @returns {number}\n     */\n  }, {\n    key: \"getRowHeight\",\n    value: function getRowHeight(sourceRow) {\n      return this.rowUtils.getHeight(sourceRow);\n    }\n\n    /**\n     * @param {number} level The column level.\n     * @returns {number}\n     */\n  }, {\n    key: \"getColumnHeaderHeight\",\n    value: function getColumnHeaderHeight(level) {\n      return this.columnUtils.getHeaderHeight(level);\n    }\n\n    /**\n     * @param {number} sourceColumn The physical column index.\n     * @returns {number}\n     */\n  }, {\n    key: \"getColumnWidth\",\n    value: function getColumnWidth(sourceColumn) {\n      return this.columnUtils.getWidth(sourceColumn);\n    }\n\n    /**\n     * @param {number} sourceColumn The physical column index.\n     * @returns {number}\n     */\n  }, {\n    key: \"getStretchedColumnWidth\",\n    value: function getStretchedColumnWidth(sourceColumn) {\n      return this.columnUtils.getStretchedColumnWidth(sourceColumn);\n    }\n\n    /**\n     * Checks if the table has defined size. It returns `true` when the table has width and height\n     * set bigger than `0px`.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"hasDefinedSize\",\n    value: function hasDefinedSize() {\n      return this.hasTableHeight && this.hasTableWidth;\n    }\n\n    /**\n     * Gets table's width. The returned width is the width of the rendered cells that fit in the\n     * current viewport. The value may change depends on the viewport position (scroll position).\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getWidth\",\n    value: function getWidth() {\n      return outerWidth(this.TABLE);\n    }\n\n    /**\n     * Gets table's height. The returned height is the height of the rendered cells that fit in the\n     * current viewport. The value may change depends on the viewport position (scroll position).\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getHeight\",\n    value: function getHeight() {\n      return outerHeight(this.TABLE);\n    }\n\n    /**\n     * Gets table's total width. The returned width is the width of all rendered cells (including headers)\n     * that can be displayed in the table.\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getTotalWidth\",\n    value: function getTotalWidth() {\n      var width = outerWidth(this.hider);\n\n      // when the overlay's table does not have any cells the hider returns 0, get then width from the table element\n      return width !== 0 ? width : this.getWidth();\n    }\n\n    /**\n     * Gets table's total height. The returned height is the height of all rendered cells (including headers)\n     * that can be displayed in the table.\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getTotalHeight\",\n    value: function getTotalHeight() {\n      var height = outerHeight(this.hider);\n\n      // when the overlay's table does not have any cells the hider returns 0, get then height from the table element\n      return height !== 0 ? height : this.getHeight();\n    }\n\n    /**\n     * Checks if the table is visible. It returns `true` when the holder element (or its parents)\n     * has CSS 'display' property different than 'none'.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isVisible\",\n    value: function isVisible() {\n      return _isVisible(this.TABLE);\n    }\n\n    /**\n     * Modify row header widths provided by user in class contructor.\n     *\n     * @private\n     * @param {Function} rowHeaderWidthFactory The function which can provide default width values for rows..\n     * @returns {number}\n     */\n  }, {\n    key: \"_modifyRowHeaderWidth\",\n    value: function _modifyRowHeaderWidth(rowHeaderWidthFactory) {\n      var widths = isFunction(rowHeaderWidthFactory) ? rowHeaderWidthFactory() : null;\n      if (Array.isArray(widths)) {\n        widths = _toConsumableArray(widths);\n        widths[widths.length - 1] = this._correctRowHeaderWidth(widths[widths.length - 1]);\n      } else {\n        widths = this._correctRowHeaderWidth(widths);\n      }\n      return widths;\n    }\n\n    /**\n     * Correct row header width if necessary.\n     *\n     * @private\n     * @param {number} width The width to process.\n     * @returns {number}\n     */\n  }, {\n    key: \"_correctRowHeaderWidth\",\n    value: function _correctRowHeaderWidth(width) {\n      var rowHeaderWidth = width;\n      if (typeof width !== 'number') {\n        rowHeaderWidth = this.wtSettings.getSetting('defaultColumnWidth');\n      }\n      if (this.correctHeaderWidth) {\n        rowHeaderWidth += 1;\n      }\n      return rowHeaderWidth;\n    }\n  }]);\n  return Table;\n}();\nexport default Table;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}