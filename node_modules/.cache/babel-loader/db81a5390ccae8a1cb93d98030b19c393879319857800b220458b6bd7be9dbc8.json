{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nimport { getScrollableElement, getTrimmingContainer, getScrollbarWidth } from \"../../../../helpers/dom/element.mjs\";\nimport { defineGetter } from \"../../../../helpers/object.mjs\";\nimport { arrayEach } from \"../../../../helpers/array.mjs\";\nimport { warn } from \"../../../../helpers/console.mjs\";\nimport { CLONE_TYPES, CLONE_CLASS_NAMES, CLONE_TOP, CLONE_INLINE_START } from \"./constants.mjs\";\nimport Clone from \"../core/clone.mjs\";\n/**\n * Creates an overlay over the original Walkontable instance. The overlay renders the clone of the original Walkontable\n * and (optionally) implements behavior needed for native horizontal and vertical scrolling.\n *\n * @abstract\n * @class Overlay\n * @property {Walkontable} wot The Walkontable instance.\n */\nexport var Overlay = /*#__PURE__*/function () {\n  /**\n   *  The Walkontable settings.\n   *\n   * @private\n   * @type {Settings}\n   */\n\n  /**\n   * @param {Walkontable} wotInstance The Walkontable instance. @TODO refactoring: check if can be deleted.\n   * @param {FacadeGetter} facadeGetter Function which return proper facade.\n   * @param {CLONE_TYPES_ENUM} type The overlay type name (clone name).\n   * @param {Settings} wtSettings The Walkontable settings.\n   * @param {DomBindings} domBindings Dom elements bound to the current instance.\n   */\n  function Overlay(wotInstance, facadeGetter, type, wtSettings, domBindings) {\n    _classCallCheck(this, Overlay);\n    _defineProperty(this, \"wtSettings\", null);\n    defineGetter(this, 'wot', wotInstance, {\n      writable: false\n    });\n    this.domBindings = domBindings;\n    this.facadeGetter = facadeGetter;\n    this.wtSettings = wtSettings;\n    var _this$wot$wtTable = this.wot.wtTable,\n      TABLE = _this$wot$wtTable.TABLE,\n      hider = _this$wot$wtTable.hider,\n      spreader = _this$wot$wtTable.spreader,\n      holder = _this$wot$wtTable.holder,\n      wtRootElement = _this$wot$wtTable.wtRootElement; // todo ioc\n\n    // legacy support, deprecated in the future\n    this.instance = this.wot;\n    this.type = type;\n    this.mainTableScrollableElement = null;\n    this.TABLE = TABLE;\n    this.hider = hider;\n    this.spreader = spreader;\n    this.holder = holder;\n    this.wtRootElement = wtRootElement;\n    this.trimmingContainer = getTrimmingContainer(this.hider.parentNode.parentNode);\n    this.updateStateOfRendering();\n    this.clone = this.makeClone();\n  }\n\n  /**\n   * Update internal state of object with an information about the need of full rendering of the overlay.\n   *\n   * @returns {boolean} Returns `true` if the state has changed since the last check.\n   */\n  _createClass(Overlay, [{\n    key: \"updateStateOfRendering\",\n    value: function updateStateOfRendering() {\n      // todo refactoring: conceive introducing final state machine, normal -> changed (once) -> needs-full-render -> ...? -> normal\n      var previousState = this.needFullRender;\n      this.needFullRender = this.shouldBeRendered();\n      var changed = previousState !== this.needFullRender;\n      if (changed && !this.needFullRender) {\n        this.reset();\n      }\n      return changed;\n    }\n\n    /**\n     * Checks if overlay should be fully rendered.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"shouldBeRendered\",\n    value: function shouldBeRendered() {\n      return true;\n    }\n\n    /**\n     * Update the trimming container.\n     */\n  }, {\n    key: \"updateTrimmingContainer\",\n    value: function updateTrimmingContainer() {\n      this.trimmingContainer = getTrimmingContainer(this.hider.parentNode.parentNode);\n    }\n\n    /**\n     * Update the main scrollable element.\n     */\n  }, {\n    key: \"updateMainScrollableElement\",\n    value: function updateMainScrollableElement() {\n      var wtTable = this.wot.wtTable;\n      var rootWindow = this.domBindings.rootWindow;\n      if (rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyValue('overflow') === 'hidden') {\n        this.mainTableScrollableElement = this.wot.wtTable.holder;\n      } else {\n        this.mainTableScrollableElement = getScrollableElement(wtTable.TABLE);\n      }\n    }\n\n    /**\n     * Calculates coordinates of the provided element, relative to the root Handsontable element.\n     * NOTE: The element needs to be a child of the overlay in order for the method to work correctly.\n     *\n     * @param {HTMLElement} element The cell element to calculate the position for.\n     * @param {number} rowIndex Visual row index.\n     * @param {number} columnIndex Visual column index.\n     * @returns {{top: number, start: number}|undefined}\n     */\n  }, {\n    key: \"getRelativeCellPosition\",\n    value: function getRelativeCellPosition(element, rowIndex, columnIndex) {\n      if (this.clone.wtTable.holder.contains(element) === false) {\n        warn(\"The provided element is not a child of the \".concat(this.type, \" overlay\"));\n        return;\n      }\n      var windowScroll = this.mainTableScrollableElement === this.domBindings.rootWindow;\n      var fixedColumnStart = columnIndex < this.wtSettings.getSetting('fixedColumnsStart');\n      var fixedRowTop = rowIndex < this.wtSettings.getSetting('fixedRowsTop');\n      var fixedRowBottom = rowIndex >= this.wtSettings.getSetting('totalRows') - this.wtSettings.getSetting('fixedRowsBottom');\n      var spreader = this.clone.wtTable.spreader;\n      var spreaderOffset = {\n        start: this.getRelativeStartPosition(spreader),\n        top: spreader.offsetTop\n      };\n      var elementOffset = {\n        start: this.getRelativeStartPosition(element),\n        top: element.offsetTop\n      };\n      var offsetObject = null;\n      if (windowScroll) {\n        offsetObject = this.getRelativeCellPositionWithinWindow(fixedRowTop, fixedColumnStart, elementOffset, spreaderOffset);\n      } else {\n        offsetObject = this.getRelativeCellPositionWithinHolder(fixedRowTop, fixedRowBottom, fixedColumnStart, elementOffset, spreaderOffset);\n      }\n      return offsetObject;\n    }\n\n    /**\n     * Get inline start value depending of direction.\n     *\n     * @param {HTMLElement} el Element.\n     * @returns {number}\n     */\n  }, {\n    key: \"getRelativeStartPosition\",\n    value: function getRelativeStartPosition(el) {\n      return this.isRtl() ? el.offsetParent.offsetWidth - el.offsetLeft - el.offsetWidth : el.offsetLeft;\n    }\n\n    /**\n     * Calculates coordinates of the provided element, relative to the root Handsontable element within a table with window\n     * as a scrollable element.\n     *\n     * @private\n     * @param {boolean} onFixedRowTop `true` if the coordinates point to a place within the top fixed rows.\n     * @param {boolean} onFixedColumn `true` if the coordinates point to a place within the fixed columns.\n     * @param {number} elementOffset Offset position of the cell element.\n     * @param {number} spreaderOffset Offset position of the spreader element.\n     * @returns {{top: number, left: number}}\n     */\n  }, {\n    key: \"getRelativeCellPositionWithinWindow\",\n    value: function getRelativeCellPositionWithinWindow(onFixedRowTop, onFixedColumn, elementOffset, spreaderOffset) {\n      var absoluteRootElementPosition = this.wot.wtTable.wtRootElement.getBoundingClientRect(); // todo refactoring: DEMETER\n      var horizontalOffset = 0;\n      var verticalOffset = 0;\n      if (!onFixedColumn) {\n        horizontalOffset = spreaderOffset.start;\n      } else {\n        var absoluteRootElementStartPosition = absoluteRootElementPosition.left;\n        if (this.isRtl()) {\n          absoluteRootElementStartPosition = this.domBindings.rootWindow.innerWidth - (absoluteRootElementPosition.left + absoluteRootElementPosition.width + getScrollbarWidth());\n        }\n        horizontalOffset = absoluteRootElementStartPosition <= 0 ? -1 * absoluteRootElementStartPosition : 0;\n      }\n      if (onFixedRowTop) {\n        var absoluteOverlayPosition = this.clone.wtTable.TABLE.getBoundingClientRect();\n        verticalOffset = absoluteOverlayPosition.top - absoluteRootElementPosition.top;\n      } else {\n        verticalOffset = spreaderOffset.top;\n      }\n      return {\n        start: elementOffset.start + horizontalOffset,\n        top: elementOffset.top + verticalOffset\n      };\n    }\n\n    /**\n     * Calculates coordinates of the provided element, relative to the root Handsontable element within a table with window\n     * as a scrollable element.\n     *\n     * @private\n     * @param {boolean} onFixedRowTop `true` if the coordinates point to a place within the top fixed rows.\n     * @param {boolean} onFixedRowBottom `true` if the coordinates point to a place within the bottom fixed rows.\n     * @param {boolean} onFixedColumn `true` if the coordinates point to a place within the fixed columns.\n     * @param {number} elementOffset Offset position of the cell element.\n     * @param {number} spreaderOffset Offset position of the spreader element.\n     * @returns {{top: number, left: number}}\n     */\n  }, {\n    key: \"getRelativeCellPositionWithinHolder\",\n    value: function getRelativeCellPositionWithinHolder(onFixedRowTop, onFixedRowBottom, onFixedColumn, elementOffset, spreaderOffset) {\n      var tableScrollPosition = {\n        horizontal: this.wot.wtOverlays.inlineStartOverlay.getScrollPosition(),\n        vertical: this.wot.wtOverlays.topOverlay.getScrollPosition()\n      };\n      var horizontalOffset = 0;\n      var verticalOffset = 0;\n      if (!onFixedColumn) {\n        horizontalOffset = tableScrollPosition.horizontal - spreaderOffset.start;\n      }\n      if (onFixedRowBottom) {\n        var absoluteRootElementPosition = this.wot.wtTable.wtRootElement.getBoundingClientRect(); // todo refactoring: DEMETER\n        var absoluteOverlayPosition = this.clone.wtTable.TABLE.getBoundingClientRect(); // todo refactoring: DEMETER\n\n        verticalOffset = absoluteOverlayPosition.top * -1 + absoluteRootElementPosition.top;\n      } else if (!onFixedRowTop) {\n        verticalOffset = tableScrollPosition.vertical - spreaderOffset.top;\n      }\n      return {\n        start: elementOffset.start - horizontalOffset,\n        top: elementOffset.top - verticalOffset\n      };\n    }\n\n    /**\n     * Make a clone of table for overlay.\n     *\n     * @returns {Clone}\n     */\n  }, {\n    key: \"makeClone\",\n    value: function makeClone() {\n      if (CLONE_TYPES.indexOf(this.type) === -1) {\n        throw new Error(\"Clone type \\\"\".concat(this.type, \"\\\" is not supported.\"));\n      }\n      var wtTable = this.wot.wtTable;\n      var _this$domBindings = this.domBindings,\n        rootDocument = _this$domBindings.rootDocument,\n        rootWindow = _this$domBindings.rootWindow;\n      var clone = rootDocument.createElement('DIV');\n      var clonedTable = rootDocument.createElement('TABLE');\n      var tableParent = wtTable.wtRootElement.parentNode;\n      clone.className = \"\".concat(CLONE_CLASS_NAMES.get(this.type), \" handsontable\");\n      clone.setAttribute('dir', this.isRtl() ? 'rtl' : 'ltr');\n      clone.style.position = 'absolute';\n      clone.style.top = 0;\n      clone.style.overflow = 'visible';\n      if (this.isRtl()) {\n        clone.style.right = 0;\n      } else {\n        clone.style.left = 0;\n      }\n      clonedTable.className = wtTable.TABLE.className;\n      clone.appendChild(clonedTable);\n      tableParent.appendChild(clone);\n      var preventOverflow = this.wtSettings.getSetting('preventOverflow');\n      if (preventOverflow === true || preventOverflow === 'horizontal' && this.type === CLONE_TOP || preventOverflow === 'vertical' && this.type === CLONE_INLINE_START) {\n        this.mainTableScrollableElement = rootWindow;\n      } else if (rootWindow.getComputedStyle(tableParent).getPropertyValue('overflow') === 'hidden') {\n        this.mainTableScrollableElement = wtTable.holder;\n      } else {\n        this.mainTableScrollableElement = getScrollableElement(wtTable.TABLE);\n      }\n\n      // Create a new instance of the Walkontable class\n      return new Clone(clonedTable, this.wtSettings, {\n        // todo ioc factory\n        source: this.wot,\n        overlay: this,\n        viewport: this.wot.wtViewport,\n        // todo ioc , or factor func if used only here\n        event: this.wot.wtEvent,\n        // todo ioc , or factory func if used only here\n        selections: this.wot.selections // todo ioc , or factory func if used only here\n      });\n    }\n\n    /**\n     * Refresh/Redraw overlay.\n     *\n     * @param {boolean} [fastDraw=false] When `true`, try to refresh only the positions of borders without rerendering\n     *                                   the data. It will only work if Table.draw() does not force\n     *                                   rendering anyway.\n     */\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      var fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      // When hot settings are changed we allow to refresh overlay once before blocking\n      var nextCycleRenderFlag = this.shouldBeRendered();\n      if (this.clone && (this.needFullRender || nextCycleRenderFlag)) {\n        this.clone.draw(fastDraw);\n      }\n      this.needFullRender = nextCycleRenderFlag;\n    }\n\n    /**\n     * Reset overlay styles to initial values.\n     */\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      if (!this.clone) {\n        return;\n      }\n      var holder = this.clone.wtTable.holder; // todo refactoring: DEMETER\n      var hider = this.clone.wtTable.hider; // todo refactoring: DEMETER\n      var holderStyle = holder.style;\n      var hiderStyle = hider.style;\n      var rootStyle = holder.parentNode.style;\n      arrayEach([holderStyle, hiderStyle, rootStyle], function (style) {\n        style.width = '';\n        style.height = '';\n      });\n    }\n\n    /**\n     * Determine if Walkontable is running in RTL mode.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isRtl\",\n    value: function isRtl() {\n      return this.wtSettings.getSetting('rtlMode');\n    }\n\n    /**\n     * Destroy overlay instance.\n     */\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.clone.eventManager.destroy(); // todo check if it is good place for that operation\n    }\n  }]);\n\n  return Overlay;\n}();","map":{"version":3,"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","_toPropertyKey","key","_createClass","protoProps","staticProps","_defineProperty","value","arg","_toPrimitive","String","input","hint","prim","toPrimitive","undefined","res","call","Number","getScrollableElement","getTrimmingContainer","getScrollbarWidth","defineGetter","arrayEach","warn","CLONE_TYPES","CLONE_CLASS_NAMES","CLONE_TOP","CLONE_INLINE_START","Clone","Overlay","wotInstance","facadeGetter","type","wtSettings","domBindings","_this$wot$wtTable","wot","wtTable","TABLE","hider","spreader","holder","wtRootElement","mainTableScrollableElement","trimmingContainer","parentNode","updateStateOfRendering","clone","makeClone","previousState","needFullRender","shouldBeRendered","changed","reset","updateTrimmingContainer","updateMainScrollableElement","rootWindow","getComputedStyle","getPropertyValue","getRelativeCellPosition","element","rowIndex","columnIndex","contains","concat","windowScroll","fixedColumnStart","getSetting","fixedRowTop","fixedRowBottom","spreaderOffset","start","getRelativeStartPosition","top","offsetTop","elementOffset","offsetObject","getRelativeCellPositionWithinWindow","getRelativeCellPositionWithinHolder","el","isRtl","offsetParent","offsetWidth","offsetLeft","onFixedRowTop","onFixedColumn","absoluteRootElementPosition","getBoundingClientRect","horizontalOffset","verticalOffset","absoluteRootElementStartPosition","left","innerWidth","width","absoluteOverlayPosition","onFixedRowBottom","tableScrollPosition","horizontal","wtOverlays","inlineStartOverlay","getScrollPosition","vertical","topOverlay","indexOf","Error","_this$domBindings","rootDocument","createElement","clonedTable","tableParent","className","get","setAttribute","style","position","overflow","right","appendChild","preventOverflow","source","overlay","viewport","wtViewport","event","wtEvent","selections","refresh","fastDraw","arguments","nextCycleRenderFlag","draw","holderStyle","hiderStyle","rootStyle","height","destroy","eventManager"],"sources":["/home/rstorey/wwwdev/Blucktool/node_modules/handsontable/3rdparty/walkontable/src/overlay/_base.mjs"],"sourcesContent":["function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.symbol.to-primitive.js\";\nimport \"core-js/modules/es.date.to-primitive.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { getScrollableElement, getTrimmingContainer, getScrollbarWidth } from \"../../../../helpers/dom/element.mjs\";\nimport { defineGetter } from \"../../../../helpers/object.mjs\";\nimport { arrayEach } from \"../../../../helpers/array.mjs\";\nimport { warn } from \"../../../../helpers/console.mjs\";\nimport { CLONE_TYPES, CLONE_CLASS_NAMES, CLONE_TOP, CLONE_INLINE_START } from \"./constants.mjs\";\nimport Clone from \"../core/clone.mjs\";\n/**\n * Creates an overlay over the original Walkontable instance. The overlay renders the clone of the original Walkontable\n * and (optionally) implements behavior needed for native horizontal and vertical scrolling.\n *\n * @abstract\n * @class Overlay\n * @property {Walkontable} wot The Walkontable instance.\n */\nexport var Overlay = /*#__PURE__*/function () {\n  /**\n   *  The Walkontable settings.\n   *\n   * @private\n   * @type {Settings}\n   */\n\n  /**\n   * @param {Walkontable} wotInstance The Walkontable instance. @TODO refactoring: check if can be deleted.\n   * @param {FacadeGetter} facadeGetter Function which return proper facade.\n   * @param {CLONE_TYPES_ENUM} type The overlay type name (clone name).\n   * @param {Settings} wtSettings The Walkontable settings.\n   * @param {DomBindings} domBindings Dom elements bound to the current instance.\n   */\n  function Overlay(wotInstance, facadeGetter, type, wtSettings, domBindings) {\n    _classCallCheck(this, Overlay);\n    _defineProperty(this, \"wtSettings\", null);\n    defineGetter(this, 'wot', wotInstance, {\n      writable: false\n    });\n    this.domBindings = domBindings;\n    this.facadeGetter = facadeGetter;\n    this.wtSettings = wtSettings;\n    var _this$wot$wtTable = this.wot.wtTable,\n      TABLE = _this$wot$wtTable.TABLE,\n      hider = _this$wot$wtTable.hider,\n      spreader = _this$wot$wtTable.spreader,\n      holder = _this$wot$wtTable.holder,\n      wtRootElement = _this$wot$wtTable.wtRootElement; // todo ioc\n\n    // legacy support, deprecated in the future\n    this.instance = this.wot;\n    this.type = type;\n    this.mainTableScrollableElement = null;\n    this.TABLE = TABLE;\n    this.hider = hider;\n    this.spreader = spreader;\n    this.holder = holder;\n    this.wtRootElement = wtRootElement;\n    this.trimmingContainer = getTrimmingContainer(this.hider.parentNode.parentNode);\n    this.updateStateOfRendering();\n    this.clone = this.makeClone();\n  }\n\n  /**\n   * Update internal state of object with an information about the need of full rendering of the overlay.\n   *\n   * @returns {boolean} Returns `true` if the state has changed since the last check.\n   */\n  _createClass(Overlay, [{\n    key: \"updateStateOfRendering\",\n    value: function updateStateOfRendering() {\n      // todo refactoring: conceive introducing final state machine, normal -> changed (once) -> needs-full-render -> ...? -> normal\n      var previousState = this.needFullRender;\n      this.needFullRender = this.shouldBeRendered();\n      var changed = previousState !== this.needFullRender;\n      if (changed && !this.needFullRender) {\n        this.reset();\n      }\n      return changed;\n    }\n\n    /**\n     * Checks if overlay should be fully rendered.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"shouldBeRendered\",\n    value: function shouldBeRendered() {\n      return true;\n    }\n\n    /**\n     * Update the trimming container.\n     */\n  }, {\n    key: \"updateTrimmingContainer\",\n    value: function updateTrimmingContainer() {\n      this.trimmingContainer = getTrimmingContainer(this.hider.parentNode.parentNode);\n    }\n\n    /**\n     * Update the main scrollable element.\n     */\n  }, {\n    key: \"updateMainScrollableElement\",\n    value: function updateMainScrollableElement() {\n      var wtTable = this.wot.wtTable;\n      var rootWindow = this.domBindings.rootWindow;\n      if (rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyValue('overflow') === 'hidden') {\n        this.mainTableScrollableElement = this.wot.wtTable.holder;\n      } else {\n        this.mainTableScrollableElement = getScrollableElement(wtTable.TABLE);\n      }\n    }\n\n    /**\n     * Calculates coordinates of the provided element, relative to the root Handsontable element.\n     * NOTE: The element needs to be a child of the overlay in order for the method to work correctly.\n     *\n     * @param {HTMLElement} element The cell element to calculate the position for.\n     * @param {number} rowIndex Visual row index.\n     * @param {number} columnIndex Visual column index.\n     * @returns {{top: number, start: number}|undefined}\n     */\n  }, {\n    key: \"getRelativeCellPosition\",\n    value: function getRelativeCellPosition(element, rowIndex, columnIndex) {\n      if (this.clone.wtTable.holder.contains(element) === false) {\n        warn(\"The provided element is not a child of the \".concat(this.type, \" overlay\"));\n        return;\n      }\n      var windowScroll = this.mainTableScrollableElement === this.domBindings.rootWindow;\n      var fixedColumnStart = columnIndex < this.wtSettings.getSetting('fixedColumnsStart');\n      var fixedRowTop = rowIndex < this.wtSettings.getSetting('fixedRowsTop');\n      var fixedRowBottom = rowIndex >= this.wtSettings.getSetting('totalRows') - this.wtSettings.getSetting('fixedRowsBottom');\n      var spreader = this.clone.wtTable.spreader;\n      var spreaderOffset = {\n        start: this.getRelativeStartPosition(spreader),\n        top: spreader.offsetTop\n      };\n      var elementOffset = {\n        start: this.getRelativeStartPosition(element),\n        top: element.offsetTop\n      };\n      var offsetObject = null;\n      if (windowScroll) {\n        offsetObject = this.getRelativeCellPositionWithinWindow(fixedRowTop, fixedColumnStart, elementOffset, spreaderOffset);\n      } else {\n        offsetObject = this.getRelativeCellPositionWithinHolder(fixedRowTop, fixedRowBottom, fixedColumnStart, elementOffset, spreaderOffset);\n      }\n      return offsetObject;\n    }\n\n    /**\n     * Get inline start value depending of direction.\n     *\n     * @param {HTMLElement} el Element.\n     * @returns {number}\n     */\n  }, {\n    key: \"getRelativeStartPosition\",\n    value: function getRelativeStartPosition(el) {\n      return this.isRtl() ? el.offsetParent.offsetWidth - el.offsetLeft - el.offsetWidth : el.offsetLeft;\n    }\n\n    /**\n     * Calculates coordinates of the provided element, relative to the root Handsontable element within a table with window\n     * as a scrollable element.\n     *\n     * @private\n     * @param {boolean} onFixedRowTop `true` if the coordinates point to a place within the top fixed rows.\n     * @param {boolean} onFixedColumn `true` if the coordinates point to a place within the fixed columns.\n     * @param {number} elementOffset Offset position of the cell element.\n     * @param {number} spreaderOffset Offset position of the spreader element.\n     * @returns {{top: number, left: number}}\n     */\n  }, {\n    key: \"getRelativeCellPositionWithinWindow\",\n    value: function getRelativeCellPositionWithinWindow(onFixedRowTop, onFixedColumn, elementOffset, spreaderOffset) {\n      var absoluteRootElementPosition = this.wot.wtTable.wtRootElement.getBoundingClientRect(); // todo refactoring: DEMETER\n      var horizontalOffset = 0;\n      var verticalOffset = 0;\n      if (!onFixedColumn) {\n        horizontalOffset = spreaderOffset.start;\n      } else {\n        var absoluteRootElementStartPosition = absoluteRootElementPosition.left;\n        if (this.isRtl()) {\n          absoluteRootElementStartPosition = this.domBindings.rootWindow.innerWidth - (absoluteRootElementPosition.left + absoluteRootElementPosition.width + getScrollbarWidth());\n        }\n        horizontalOffset = absoluteRootElementStartPosition <= 0 ? -1 * absoluteRootElementStartPosition : 0;\n      }\n      if (onFixedRowTop) {\n        var absoluteOverlayPosition = this.clone.wtTable.TABLE.getBoundingClientRect();\n        verticalOffset = absoluteOverlayPosition.top - absoluteRootElementPosition.top;\n      } else {\n        verticalOffset = spreaderOffset.top;\n      }\n      return {\n        start: elementOffset.start + horizontalOffset,\n        top: elementOffset.top + verticalOffset\n      };\n    }\n\n    /**\n     * Calculates coordinates of the provided element, relative to the root Handsontable element within a table with window\n     * as a scrollable element.\n     *\n     * @private\n     * @param {boolean} onFixedRowTop `true` if the coordinates point to a place within the top fixed rows.\n     * @param {boolean} onFixedRowBottom `true` if the coordinates point to a place within the bottom fixed rows.\n     * @param {boolean} onFixedColumn `true` if the coordinates point to a place within the fixed columns.\n     * @param {number} elementOffset Offset position of the cell element.\n     * @param {number} spreaderOffset Offset position of the spreader element.\n     * @returns {{top: number, left: number}}\n     */\n  }, {\n    key: \"getRelativeCellPositionWithinHolder\",\n    value: function getRelativeCellPositionWithinHolder(onFixedRowTop, onFixedRowBottom, onFixedColumn, elementOffset, spreaderOffset) {\n      var tableScrollPosition = {\n        horizontal: this.wot.wtOverlays.inlineStartOverlay.getScrollPosition(),\n        vertical: this.wot.wtOverlays.topOverlay.getScrollPosition()\n      };\n      var horizontalOffset = 0;\n      var verticalOffset = 0;\n      if (!onFixedColumn) {\n        horizontalOffset = tableScrollPosition.horizontal - spreaderOffset.start;\n      }\n      if (onFixedRowBottom) {\n        var absoluteRootElementPosition = this.wot.wtTable.wtRootElement.getBoundingClientRect(); // todo refactoring: DEMETER\n        var absoluteOverlayPosition = this.clone.wtTable.TABLE.getBoundingClientRect(); // todo refactoring: DEMETER\n\n        verticalOffset = absoluteOverlayPosition.top * -1 + absoluteRootElementPosition.top;\n      } else if (!onFixedRowTop) {\n        verticalOffset = tableScrollPosition.vertical - spreaderOffset.top;\n      }\n      return {\n        start: elementOffset.start - horizontalOffset,\n        top: elementOffset.top - verticalOffset\n      };\n    }\n\n    /**\n     * Make a clone of table for overlay.\n     *\n     * @returns {Clone}\n     */\n  }, {\n    key: \"makeClone\",\n    value: function makeClone() {\n      if (CLONE_TYPES.indexOf(this.type) === -1) {\n        throw new Error(\"Clone type \\\"\".concat(this.type, \"\\\" is not supported.\"));\n      }\n      var wtTable = this.wot.wtTable;\n      var _this$domBindings = this.domBindings,\n        rootDocument = _this$domBindings.rootDocument,\n        rootWindow = _this$domBindings.rootWindow;\n      var clone = rootDocument.createElement('DIV');\n      var clonedTable = rootDocument.createElement('TABLE');\n      var tableParent = wtTable.wtRootElement.parentNode;\n      clone.className = \"\".concat(CLONE_CLASS_NAMES.get(this.type), \" handsontable\");\n      clone.setAttribute('dir', this.isRtl() ? 'rtl' : 'ltr');\n      clone.style.position = 'absolute';\n      clone.style.top = 0;\n      clone.style.overflow = 'visible';\n      if (this.isRtl()) {\n        clone.style.right = 0;\n      } else {\n        clone.style.left = 0;\n      }\n      clonedTable.className = wtTable.TABLE.className;\n      clone.appendChild(clonedTable);\n      tableParent.appendChild(clone);\n      var preventOverflow = this.wtSettings.getSetting('preventOverflow');\n      if (preventOverflow === true || preventOverflow === 'horizontal' && this.type === CLONE_TOP || preventOverflow === 'vertical' && this.type === CLONE_INLINE_START) {\n        this.mainTableScrollableElement = rootWindow;\n      } else if (rootWindow.getComputedStyle(tableParent).getPropertyValue('overflow') === 'hidden') {\n        this.mainTableScrollableElement = wtTable.holder;\n      } else {\n        this.mainTableScrollableElement = getScrollableElement(wtTable.TABLE);\n      }\n\n      // Create a new instance of the Walkontable class\n      return new Clone(clonedTable, this.wtSettings, {\n        // todo ioc factory\n        source: this.wot,\n        overlay: this,\n        viewport: this.wot.wtViewport,\n        // todo ioc , or factor func if used only here\n        event: this.wot.wtEvent,\n        // todo ioc , or factory func if used only here\n        selections: this.wot.selections // todo ioc , or factory func if used only here\n      });\n    }\n\n    /**\n     * Refresh/Redraw overlay.\n     *\n     * @param {boolean} [fastDraw=false] When `true`, try to refresh only the positions of borders without rerendering\n     *                                   the data. It will only work if Table.draw() does not force\n     *                                   rendering anyway.\n     */\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      var fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      // When hot settings are changed we allow to refresh overlay once before blocking\n      var nextCycleRenderFlag = this.shouldBeRendered();\n      if (this.clone && (this.needFullRender || nextCycleRenderFlag)) {\n        this.clone.draw(fastDraw);\n      }\n      this.needFullRender = nextCycleRenderFlag;\n    }\n\n    /**\n     * Reset overlay styles to initial values.\n     */\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      if (!this.clone) {\n        return;\n      }\n      var holder = this.clone.wtTable.holder; // todo refactoring: DEMETER\n      var hider = this.clone.wtTable.hider; // todo refactoring: DEMETER\n      var holderStyle = holder.style;\n      var hiderStyle = hider.style;\n      var rootStyle = holder.parentNode.style;\n      arrayEach([holderStyle, hiderStyle, rootStyle], function (style) {\n        style.width = '';\n        style.height = '';\n      });\n    }\n\n    /**\n     * Determine if Walkontable is running in RTL mode.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isRtl\",\n    value: function isRtl() {\n      return this.wtSettings.getSetting('rtlMode');\n    }\n\n    /**\n     * Destroy overlay instance.\n     */\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.clone.eventManager.destroy(); // todo check if it is good place for that operation\n    }\n  }]);\n  return Overlay;\n}();"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}